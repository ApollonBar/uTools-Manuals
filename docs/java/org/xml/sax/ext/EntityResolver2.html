<div class="header">
<div class="subTitle">
     compact2, compact3 
   </div>
<div class="subTitle">
     org.xml.sax.ext 
   </div>
<h2 class="title" title="Interface EntityResolver2">Interface EntityResolver2</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Superinterfaces: 
       </dt>
<dd>
<span><a href="../../../../org/xml/sax/EntityResolver.html" title="org.xml.sax中的接口">EntityResolver</a></span>
</dd>
</dl>
<dl>
<dt>
        所有已知实现类：
       </dt>
<dd>
<span><a href="../../../../org/xml/sax/ext/DefaultHandler2.html" title="org.xml.sax.ext中的类">DefaultHandler2</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public interface <span class="typeNameLabel">EntityResolver2</span>
extends <a href="../../../../org/xml/sax/EntityResolver.html" title="interface in org.xml.sax">EntityResolver</a></pre>
<div class="block">
<span>用于将外部实体引用映射到输入源的扩展接口，或提供缺少的外部子集。</span>
<span><a href="../../../../org/xml/sax/XMLReader.html#setEntityResolver-org.xml.sax.EntityResolver-"><code>XMLReader.setEntityResolver()</code></a>方法用于向解析器提供此接口的实现。</span>
<span>当解析器使用此接口中的方法时，将使用<a href="../../../../org/xml/sax/ext/EntityResolver2.html#resolveEntity-java.lang.String-java.lang.String-java.lang.String-java.lang.String-"><code>EntityResolver2.resolveEntity()</code></a>方法（在此界面中） <em>而不是</em>较旧的（SAX 1.0） <a href="../../../../org/xml/sax/EntityResolver.html#resolveEntity-java.lang.String-java.lang.String-"><code>EntityResolver.resolveEntity()</code></a>方法。</span>
<blockquote>
<span><em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em></span>
</blockquote>
<p> <span>如果SAX应用程序需要此接口为外部实体定义的自定义处理，则必须确保它使用XMLReader，将<em>http://xml.org/sax/features/use-entity-resolver2</em>功能标志设置为<em>true</em> （其中是识别功能时的默认值）。</span> <span>如果该标志无法识别，或其值为false，或解析器不实现此接口，则仅使用<a href="../../../../org/xml/sax/EntityResolver.html" title="org.xml.sax中的接口"><code>EntityResolver</code></a>方法。</span> </p>
<p> <span>它支持修改实体分辨率的三类应用程序。</span> <span><em>旧样式的</em>应用程序不会知道这个界面;</span> <span>他们将提供一个EntityResolver。</span> <span><em>过渡模式</em>提供了一个EntityResolver2，并且由于多态性，在任何支持它的系统（解析器或其他工具）中自动获得其方法的好处。</span> <span><em>旧样式</em>和<em>过渡模式应用</em>程序都可以与任何SAX2解析器配合使用。</span> <span>除了支持该特定功能的SAX2解析器之外， <em>新样式应用</em>程序将无法运行。</span> <span>他们会坚持feature标志的值为“true”，如果调用了原来的SAX 1.0风格的实体解析方法，它们提供的EntityResolver2实现可能会引发异常。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         SAX 2.0（扩展1.1 alpha） 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../../org/xml/sax/XMLReader.html#setEntityResolver-org.xml.sax.EntityResolver-"><code>XMLReader.setEntityResolver(org.xml.sax.EntityResolver)</code></a>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../../../org/xml/sax/InputSource.html" title="class in org.xml.sax">InputSource</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/xml/sax/ext/EntityResolver2.html#getExternalSubset-java.lang.String-java.lang.String-">getExternalSubset</a></span>(<a href="../../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> baseURI)</code>
<div class="block">
              允许应用程序为未明确定义的文档提供外部子集。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../../../org/xml/sax/InputSource.html" title="class in org.xml.sax">InputSource</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/xml/sax/ext/EntityResolver2.html#resolveEntity-java.lang.String-java.lang.String-java.lang.String-java.lang.String-">resolveEntity</a></span>(<a href="../../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> publicId, <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> baseURI, <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> systemId)</code>
<div class="block">
              允许应用程序将对外部实体的引用映射到输入源中，或者告诉解析器它应该使用传统的URI解析。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.org.xml.sax.EntityResolver">
<!-- --> </a> <h3>Methods inherited from interface org.xml.sax.<a href="../../../../org/xml/sax/EntityResolver.html" title="interface in org.xml.sax">EntityResolver</a></h3> <code><a href="../../../../org/xml/sax/EntityResolver.html#resolveEntity-java.lang.String-java.lang.String-">resolveEntity</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getExternalSubset-java.lang.String-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getExternalSubset</h4> <pre><a href="../../../../org/xml/sax/InputSource.html" title="class in org.xml.sax">InputSource</a> getExternalSubset(<a href="../../../../java/lang/String.html" title="class in java.lang">String</a> name,
                              <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> baseURI)
                       throws <a href="../../../../org/xml/sax/SAXException.html" title="class in org.xml.sax">SAXException</a>,
                              <a href="../../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>允许应用程序为未明确定义的文档提供外部子集。</span>
<span>因此，省略外部子集的DOCTYPE声明的文档可以增加可用于验证，实体处理和属性处理（规范化，默认和包括ID的报告类型）的声明。</span>
<span>这种增加通过<a href="../../../../org/xml/sax/ext/LexicalHandler.html#startDTD-java.lang.String-java.lang.String-java.lang.String-"><code>startDTD()</code></a>方法报告，就好像文档文本最初包含外部子集;</span>
<span>此回调是在任何内部子集数据或错误报告之前进行的。</span>
<p></p>
<p> <span>此方法也可以与没有DOCTYPE声明的文档一起使用。</span> <span>当遇到根元素，但没有看到DOCTYPE声明时，将调用此方法。</span> <span>如果它返回外部子集的值，则该根元素被声明为根元素，从而产生在文档的序列结束时拼接DOCTYPE声明的效果，否则无法生效。</span> <span>在这种情况下，解析器回调的顺序在逻辑上类似于：</span> </p>
<pre>  <span>... comments and PIs from the prolog (as usual)
 startDTD ("rootName", source.getPublicId (), source.getSystemId ());
 startEntity ("[dtd]");
 ... declarations, comments, and PIs from the external subset
 endEntity ("[dtd]");
 endDTD ();
 ... then the rest of the document (as usual)
 startElement (..., "rootName", ...);</span> </pre>
<p> <span>请注意，InputSource不会进一步解析。</span> <span>该方法的实施可能希望调用<a href="../../../../org/xml/sax/ext/EntityResolver2.html#resolveEntity-java.lang.String-java.lang.String-java.lang.String-java.lang.String-"><code>resolveEntity()</code></a>以获得诸如使用DTD实体的本地高速缓存的益处。</span> <span>而且，这种方法永远不会被不包括外部参数实体的（非验证）处理器使用。</span> </p>
<p> <span>这种方法的使用包括在与总是需要外部实体的不需要的网络访问的XML处理器进行互操作时进行数据验证，或者由于其他原因采用“无DTD”策略。</span> <span>非验证动机包括强制文档包含DTD，以便一致地处理属性。</span> <span>例如，XPath处理器需要知道哪些attibutes具有类型“ID”才能处理广泛使用的引用类型。</span> </p>
<p> <span><strong>警告：</strong>返回外部子组修改输入文档。</span> <span>通过为一般实体提供定义，可以使格式错误的文档看起来形成良好。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>name</code> - 标识文档根元素。</span>
<span>该名称来自DOCTYPE声明（如果可用）或实际根元素。</span>
</dd>
<dd>
<span><code>baseURI</code> - 文档的基本URI，作为选择外部子集的附加提示。</span>
<span>这总是一个绝对的URI，除非它是null，因为XMLReader没有一个InputSource。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             描述要由解析器使用的新外部子集的InputSource对象，或null表示没有提供外部子集。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../org/xml/sax/SAXException.html" title="class in org.xml.sax">SAXException</a></code> - 任何SAX异常，可能包装另一个异常。 
           </dd>
<dd>
<code><a href="../../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 可能表示无法创建新的InputStream或Reader或非法URL。 
           </dd>
</dl> </li>
</ul> <a name="resolveEntity-java.lang.String-java.lang.String-java.lang.String-java.lang.String-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>resolveEntity</h4> <pre><a href="../../../../org/xml/sax/InputSource.html" title="class in org.xml.sax">InputSource</a> resolveEntity(<a href="../../../../java/lang/String.html" title="class in java.lang">String</a> name,
                          <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> publicId,
                          <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> baseURI,
                          <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> systemId)
                   throws <a href="../../../../org/xml/sax/SAXException.html" title="class in org.xml.sax">SAXException</a>,
                          <a href="../../../../java/io/IOException.html" title="class in java.io">IOException</a></pre>
<div class="block">
<span>允许应用程序将对外部实体的引用映射到输入源中，或者告诉解析器它应该使用传统的URI解析。</span>
<span>此方法仅适用于已正确声明的外部实体。</span>
<span>该方法比<a href="../../../../org/xml/sax/EntityResolver.html" title="org.xml.sax中的接口"><code>EntityResolver</code></a>接口提供更多的<a href="../../../../org/xml/sax/EntityResolver.html" title="org.xml.sax中的接口">灵活性</a> ，支持更复杂的目录方案的实现，例如由<a href="http://www.oasis-open.org/committees/entity/spec-2001-08-06.html">OASIS XML Catalogs</a>规范定义的目录方案。</span>
<p></p>
<p> <span>配置为使用此解析器方法的解析器将调用它来确定由于XML文本中的引用而被包含的任何外部实体使用的输入源。</span> <span>不包括文件实体，以及<a href="../../../../org/xml/sax/ext/EntityResolver2.html#getExternalSubset-java.lang.String-java.lang.String-"><code>getExternalSubset()</code></a>返回的任何外部实体。</span> <span>当（非验证）处理器配置为不通过使用特征标记包括一类实体（参数或一般）时，不会为此类实体调用此方法。</span> </p>
<p> <span>请注意，这里使用的实体命名方案与<a href="../../../../org/xml/sax/ext/LexicalHandler.html" title="org.xml.sax.ext中的接口"><code>LexicalHandler</code></a>或<a href="../../../../org/xml/sax/ContentHandler.html#skippedEntity-java.lang.String-"><code>ContentHandler.skippedEntity()</code></a>方法中使用的实体命名方案相同。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>name</code> - 标识正在解析的外部实体。</span>
<span>外部子集的“[dtd]”或以“％”开头的名称表示参数实体，或者是一般实体的名称。</span>
<span>当SAX2解析器调用时，这从不为空。</span>
</dd>
<dd>
<code>publicId</code> - 被引用的外部实体的公共标识符（按照XML规范的要求进行规范化），如果没有提供，则为null。 
           </dd>
<dd>
<span><code>baseURI</code> - 相对于哪个相对的系统ID进行解释的URI。</span>
<span>这绝对是一个绝对URI，除非它是null（可能是因为XMLReader没有一个InputSource）。</span>
<span>该URI由XML规范定义为与启动相关声明的“&lt;”相关联的URI。</span>
</dd>
<dd>
<span><code>systemId</code> - 被引用的外部实体的系统标识符;</span>
<span>一个相对或绝对的URI。</span>
<span>当SAX2解析器调用时，这不会为空;</span>
<span>只有声明的实体和任何外部子集才能被这样的解析器解析。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>描述由解析器使用的新输入源的InputSource对象。</span>
<span>返回null指示解析器根据基本URI解析系统ID，并打开到结果URI的连接。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../org/xml/sax/SAXException.html" title="class in org.xml.sax">SAXException</a></code> - 任何SAX异常，可能包装另一个异常。 
           </dd>
<dd>
<code><a href="../../../../java/io/IOException.html" title="class in java.io">IOException</a></code> - 可能表示无法创建新的InputStream或Reader或非法URL。 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>