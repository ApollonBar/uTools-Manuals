<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util.stream 
   </div>
<h2 class="title" title="Class Collectors">Class Collectors</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.stream.Collectors</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public final class <span class="typeNameLabel">Collectors</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>的实施方式中<a href="../../../java/util/stream/Collector.html" title="java.util.stream中的接口"><code>Collector</code></a>实现各种有用的还原操作，如累加元件到集合，根据各种标准总结元件等</span>
<p> <span>以下是使用预定义的收集器执行常见的可变缩减任务的示例：</span> </p>
<pre>  <span><code> // Accumulate names into a List List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList()); // Accumulate names into a TreeSet Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new)); // Convert elements to strings and concatenate them, separated by commas String joined = things.stream() .map(Object::toString) .collect(Collectors.joining(", ")); // Compute sum of salaries of employee int total = employees.stream() .collect(Collectors.summingInt(Employee::getSalary))); // Group employees by department Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); // Compute sum of salaries by department Map&lt;Department, Integer&gt; totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary))); // Partition students into passing and failing Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream() .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD)); </code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.8 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#averagingDouble-java.util.function.ToDoubleFunction-">averagingDouble</a></span>(<a href="../../../java/util/function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它产生应用于输入元素的双值函数的算术平均值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#averagingInt-java.util.function.ToIntFunction-">averagingInt</a></span>(<a href="../../../java/util/function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它产生应用于输入元素的整数值函数的算术平均值。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#averagingLong-java.util.function.ToLongFunction-">averagingLong</a></span>(<a href="../../../java/util/function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它产生应用于输入元素的长值函数的算术平均值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static &lt;T,A,R,RR&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,A,RR&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#collectingAndThen-java.util.stream.Collector-java.util.function.Function-">collectingAndThen</a></span>(<a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,A,R&gt; downstream, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;R,RR&gt; finisher)</code>
<div class="block">
              适应 
             <code>Collector</code>进行额外的整理转换。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Long.html" title="class in java.lang">Long</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#counting--">counting</a></span>()</code>
<div class="block">
              返回 
             <code>Collector</code>类型的接受元件 
             <code>T</code>计数输入元件的数量。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static &lt;T,K&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-">groupingBy</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier)</code>
<div class="block">
              返回 
             <code>Collector</code> “由基团”上的类型的输入元件操作实现 
             <code>T</code> ，根据分类功能分组元素，并且在返回的结果 
             <code>Map</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static &lt;T,K,A,D&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,D&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-">groupingBy</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier, <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</code>
<div class="block">
              返回 
             <code>Collector</code> “由基团”上的类型的输入元件操作实现级联 
             <code>T</code> ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 
             <code>Collector</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static &lt;T,K,D,A,M extends <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,D&gt;&gt;<br/><a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-">groupingBy</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier, <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory, <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</code>
<div class="block">
              返回 
             <code>Collector</code> “由基团”上的类型的输入元件操作实现级联 
             <code>T</code> ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 
             <code>Collector</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static &lt;T,K&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-">groupingByConcurrent</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier)</code>
<div class="block">
              返回一个并发 
             <code>Collector</code> “由基团”上的类型的输入元件操作实现 
             <code>T</code> ，根据分类功能分组元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static &lt;T,K,A,D&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,D&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-">groupingByConcurrent</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier, <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</code>
<div class="block">
              返回一个并发 
             <code>Collector</code> “由基团”上的类型的输入元件操作实现级联 
             <code>T</code> ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 
             <code>Collector</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static &lt;T,K,A,D,M extends <a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,D&gt;&gt;<br/><a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-">groupingByConcurrent</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier, <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory, <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</code>
<div class="block">
              返回一个并发 
             <code>Collector</code> “由基团”上的类型的输入元件操作实现级联 
             <code>T</code> ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算 
             <code>Collector</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,?,<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#joining--">joining</a></span>()</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，按照遇到的顺序将输入元素连接到一个 
             <code>String</code>中。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,?,<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#joining-java.lang.CharSequence-">joining</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> delimiter)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，按照遇到的顺序连接由指定的分隔符分隔的输入元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,?,<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#joining-java.lang.CharSequence-java.lang.CharSequence-java.lang.CharSequence-">joining</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> delimiter, <a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> prefix, <a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> suffix)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它将按照指定的 
             <code>Collector</code>分隔的输入元素与指定的前缀和后缀进行连接。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static &lt;T,U,A,R&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#mapping-java.util.function.Function-java.util.stream.Collector-">mapping</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; mapper, <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super U,A,R&gt; downstream)</code>
<div class="block">
              适应一个 
             <code>Collector</code>类型的接受元件 
             <code>U</code>至类型的一个接受元件 
             <code>T</code>通过积累前应用映射函数到每个输入元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#maxBy-java.util.Comparator-">maxBy</a></span>(<a href="../../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comparator)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它根据给出的 
             <code>Comparator</code>产生最大元素，描述为 
             <code>Optional&lt;T&gt;</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#minBy-java.util.Comparator-">minBy</a></span>(<a href="../../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comparator)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，根据给出的 
             <code>Comparator</code>产生最小元素，描述为 
             <code>Optional&lt;T&gt;</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-">partitioningBy</a></span>(<a href="../../../java/util/function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt; predicate)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，根据Predicate对输入元素进行 
             <code>Predicate</code> ，并将它们组织成 
             <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static &lt;T,D,A&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>,D&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-java.util.stream.Collector-">partitioningBy</a></span>(<a href="../../../java/util/function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt; predicate, <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它根据Predicate对输入元素进行 
             <code>Predicate</code> ，根据另一个 
             <code>Collector</code>减少每个分区的值，并将其组织成 
             <code>Map&lt;Boolean, D&gt;</code> ，其值是下游缩减的结果。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#reducing-java.util.function.BinaryOperator-">reducing</a></span>(<a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它在指定的 
             <code>Collector</code>下执行其输入元素的 
             <code>BinaryOperator</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#reducing-T-java.util.function.BinaryOperator-">reducing</a></span>(T identity, <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</code>
<div class="block">
              返回 
             <code>Collector</code>执行下一个指定的减少其输入元件的 
             <code>BinaryOperator</code>使用所提供的身份。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>static &lt;T,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,U&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#reducing-U-java.util.function.Function-java.util.function.BinaryOperator-">reducing</a></span>(U identity, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; mapper, <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; op)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它在指定的映射函数和 
             <code>BinaryOperator</code>下执行其输入元素的 
             <code>BinaryOperator</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/DoubleSummaryStatistics.html" title="class in java.util">DoubleSummaryStatistics</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#summarizingDouble-java.util.function.ToDoubleFunction-">summarizingDouble</a></span>(<a href="../../../java/util/function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ， 
             <code>double</code>生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/IntSummaryStatistics.html" title="class in java.util">IntSummaryStatistics</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#summarizingInt-java.util.function.ToIntFunction-">summarizingInt</a></span>(<a href="../../../java/util/function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ， 
             <code>int</code>生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/LongSummaryStatistics.html" title="class in java.util">LongSummaryStatistics</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#summarizingLong-java.util.function.ToLongFunction-">summarizingLong</a></span>(<a href="../../../java/util/function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ， 
             <code>long</code>生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#summingDouble-java.util.function.ToDoubleFunction-">summingDouble</a></span>(<a href="../../../java/util/function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它产生应用于输入元素的双值函数的和。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#summingInt-java.util.function.ToIntFunction-">summingInt</a></span>(<a href="../../../java/util/function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它产生应用于输入元素的整数值函数的和。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Long.html" title="class in java.lang">Long</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#summingLong-java.util.function.ToLongFunction-">summingLong</a></span>(<a href="../../../java/util/function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它产生应用于输入元素的长值函数的和。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>static &lt;T,C extends <a href="../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt;&gt;<br/><a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,C&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toCollection-java.util.function.Supplier-">toCollection</a></span>(<a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;C&gt; collectionFactory)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，按照遇到的顺序将输入元素累加到一个新的 
             <code>Collection</code>中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,U&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-">toConcurrentMap</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper)</code>
<div class="block">
              返回一个并发的 
             <code>Collector</code> ，它将元素累加到 
             <code>ConcurrentMap</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,U&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-">toConcurrentMap</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper, <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction)</code>
<div class="block">
              返回一个并发的 
             <code>Collector</code> ，它将元素累加到一个 
             <code>ConcurrentMap</code> ，其键和值是将提供的映射函数应用于输入元素的结果。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>static &lt;T,K,U,M extends <a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,U&gt;&gt;<br/><a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-">toConcurrentMap</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper, <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction, <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapSupplier)</code>
<div class="block">
              返回一个并发的 
             <code>Collector</code> ，它将元素累加到一个 
             <code>ConcurrentMap</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toList--">toList</a></span>()</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它将输入元素 
             <code>List</code>到一个新的 
             <code>List</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,U&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-">toMap</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它将元素累加到一个 
             <code>Map</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。 
            </div> </td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,U&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-">toMap</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper, <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它将元素累加到 
             <code>Map</code> ，其键和值是将提供的映射函数应用于输入元素的结果。 
            </div> </td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code>static &lt;T,K,U,M extends <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,U&gt;&gt;<br/><a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-">toMap</a></span>(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper, <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper, <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction, <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapSupplier)</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，它将元素累加到一个 
             <code>Map</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。 
            </div> </td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/stream/Collectors.html#toSet--">toSet</a></span>()</code>
<div class="block">
              返回一个 
             <code>Collector</code> ，将输入元素 
             <code>Set</code>到一个新的 
             <code>Set</code> 。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="toCollection-java.util.function.Supplier-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toCollection</h4> <pre>public static &lt;T,C extends <a href="../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;T&gt;&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,C&gt; toCollection(<a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;C&gt; collectionFactory)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，按照遇到的顺序将输入元素累加到一个新的<code>Collection</code>中。</span>
<span><code>Collection</code>由提供的工厂创建。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>C</code> -所得的类型 
            <code>Collection</code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>collectionFactory</code> - 一个 
            <code>Supplier</code> ，返回一个新的，空的 
            <code>Collection</code>的适当类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>将所有输入元素收集到一个 
            <code>Collection</code>中，按照顺序 
           </dd>
</dl> </li>
</ul> <a name="toList--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toList</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt; toList()</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它将输入元素<code>List</code>到一个新的<code>List</code> 。</span>
<span>List返回的类型，可变性，可序列化或线程安全性没有<code>List</code> ;</span>
<span>如果需要对返回的<code>List</code>进行更多的控制，请使用<a href="../../../java/util/stream/Collectors.html#toCollection-java.util.function.Supplier-"><code>toCollection(Supplier)</code></a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它将所有输入元素收集到一个 
            <code>List</code>中，按照顺序 
           </dd>
</dl> </li>
</ul> <a name="toSet--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toSet</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Set.html" title="interface in java.util">Set</a>&lt;T&gt;&gt; toSet()</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，将输入元素<code>Set</code>到一个新的<code>Set</code> 。</span>
<span>Set返回的类型，可变性，可串行性或线程安全性没有<code>Set</code> ;</span>
<span>如果需要更多控制返回的<code>Set</code> ，请使用<a href="../../../java/util/stream/Collectors.html#toCollection-java.util.function.Supplier-"><code>toCollection(Supplier)</code></a> 。</span>
<p> <span>这是一个<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>将所有输入元素收集到一个 
            <code>Set</code>
</dd>
</dl> </li>
</ul> <a name="joining--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>joining</h4> <pre>public static <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,?,<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt; joining()</pre>
<div class="block">
            返回一个 
           <code>Collector</code> ，将输入元素连接到一个 
           <code>String</code> ，按照顺序。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，将输入元素连接到一个 
            <code>String</code>中，按照顺序 
           </dd>
</dl> </li>
</ul> <a name="joining-java.lang.CharSequence-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>joining</h4> <pre>public static <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,?,<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt; joining(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> delimiter)</pre>
<div class="block">
            返回一个 
           <code>Collector</code> ，以遇到的顺序连接由指定的分隔符分隔的输入元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>delimiter</code> - 要在每个元素之间使用的分隔符 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             A 
            <code>Collector</code> ，它以相遇顺序连接由指定的分隔符分隔的CharSequence元素 
           </dd>
</dl> </li>
</ul> <a name="joining-java.lang.CharSequence-java.lang.CharSequence-java.lang.CharSequence-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>joining</h4> <pre>public static <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,?,<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt; joining(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> delimiter,
                                                       <a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> prefix,
                                                       <a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a> suffix)</pre>
<div class="block">
            返回一个 
           <code>Collector</code> ，以按照顺序将指定的 
           <code>Collector</code>分隔的输入元素与指定的前缀和后缀相连接。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>delimiter</code> - 要在每个元素之间使用的分隔符 
           </dd>
<dd>
<code>prefix</code> - 在连接结果开始时使用的字符序列 
           </dd>
<dd>
<code>suffix</code> - 连接结果末尾要使用的字符序列 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它以相遇的顺序连接由指定的分隔符分隔的CharSequence元素 
           </dd>
</dl> </li>
</ul> <a name="mapping-java.util.function.Function-java.util.stream.Collector-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>mapping</h4> <pre>public static &lt;T,U,A,R&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,R&gt; mapping(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; mapper,
                                                 <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super U,A,R&gt; downstream)</pre>
<div class="block">
            适应一个 
           <code>Collector</code>类型的接受元件 
           <code>U</code>至类型的一个接受元件 
           <code>T</code>通过积累前应用映射函数到每个输入元素。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span><code>mapping()</code>收集器在多级别缩减时最为有用，例如<code>groupingBy</code>或<code>partitioningBy</code> 。</span>
<span>例如，给出一个<code>Person</code>的流，以累积每个城市中的一组姓氏：</span>
<pre>  <span><code> Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); </code></span> </pre>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>U</code> - 下游收集器接受的元素类型 
           </dd>
<dd>
<code>A</code> - 下游收集器的中间堆积型 
           </dd>
<dd>
<code>R</code> - 
            <code>R</code>结果类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 要应用于输入元素的函数 
           </dd>
<dd>
<code>downstream</code> - 将接受映射值的收集器 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个收集器，将映射函数应用于输入元素，并将映射结果提供给下游收集器 
           </dd>
</dl> </li>
</ul> <a name="collectingAndThen-java.util.stream.Collector-java.util.function.Function-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>collectingAndThen</h4> <pre>public static &lt;T,A,R,RR&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,A,RR&gt; collectingAndThen(<a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,A,R&gt; downstream,
                                                             <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;R,RR&gt; finisher)</pre>
<div class="block">
<span>适应<code>Collector</code>进行额外的整理转换。</span>
<span>例如，可以调整<a href="../../../java/util/stream/Collectors.html#toList--"><code>toList()</code></a>收集器总是生成一个不可变的列表：</span>
<pre>  <span><code> List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); </code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>A</code> - 下游收集器的中间堆积型 
           </dd>
<dd>
<code>R</code> - 下游收集器的结果类型 
           </dd>
<dd>
<code>RR</code> - 结果 
            <code>RR</code>结果类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>downstream</code> - 收藏家 
           </dd>
<dd>
<code>finisher</code> - 应用于下游收集器的最终结果的函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             执行下游收集器的动作的收集器，随后进行另外的精加工步骤 
           </dd>
</dl> </li>
</ul> <a name="counting--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>counting</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Long.html" title="class in java.lang">Long</a>&gt; counting()</pre>
<div class="block">
<span>返回一个<code>Collector</code>类型的接受元素，类型为<code>T</code> ，它计算输入元素的数量。</span>
<span>如果没有元素，结果为0。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
<span>这产生的结果相当于：</span>
<pre>  <span><code> reducing(0L, e -&gt; 1L, Long::sum) </code></span> </pre>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个计算输入元素的 
            <code>Collector</code>
</dd>
</dl> </li>
</ul> <a name="minBy-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>minBy</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt; minBy(<a href="../../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comparator)</pre>
<div class="block">
            返回一个 
           <code>Collector</code> ，它根据给定的 
           <code>Comparator</code>产生最小元素，描述为 
           <code>Optional&lt;T&gt;</code> 。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
<span>这产生的结果相当于：</span>
<pre>  <span><code> reducing(BinaryOperator.minBy(comparator)) </code></span> </pre>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>comparator</code> - a 
            <code>Comparator</code>用于比较元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>产生最小值 
           </dd>
</dl> </li>
</ul> <a name="maxBy-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>maxBy</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt; maxBy(<a href="../../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; comparator)</pre>
<div class="block">
            返回 
           <code>Collector</code> ，它根据给定的 
           <code>Comparator</code>产生最大元素，描述为 
           <code>Optional&lt;T&gt;</code> 。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
<span>这产生的结果相当于：</span>
<pre>  <span><code> reducing(BinaryOperator.maxBy(comparator)) </code></span> </pre>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>comparator</code> -一个 
            <code>Comparator</code>用于比较的元件 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个产生最大值的 
            <code>Collector</code>
</dd>
</dl> </li>
</ul> <a name="summingInt-java.util.function.ToIntFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>summingInt</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Integer.html" title="class in java.lang">Integer</a>&gt; summingInt(<a href="../../../java/util/function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它产生应用于输入元素的整数值函数的和。</span>
<span>如果没有元素，结果为0。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 提取要求和的属性的函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它产生派生属性的总和 
           </dd>
</dl> </li>
</ul> <a name="summingLong-java.util.function.ToLongFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>summingLong</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Long.html" title="class in java.lang">Long</a>&gt; summingLong(<a href="../../../java/util/function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它产生应用于输入元素的长值函数的和。</span>
<span>如果没有元素，结果为0。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 提取要求和的属性的函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它产生一个派生属性的总和 
           </dd>
</dl> </li>
</ul> <a name="summingDouble-java.util.function.ToDoubleFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>summingDouble</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt; summingDouble(<a href="../../../java/util/function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它产生应用于输入元素的双值函数的和。</span>
<span>如果没有元素，结果为0。</span>
<p> <span>返回的总和可以根据记录值的顺序而变化，这是由于除了不同数值的值之外的累积舍入误差。</span> <span>按绝对数量增加排列的数值往往会产生更准确的结果。</span> <span>如果任何记录值为<code>NaN</code>或者总和为<code>NaN</code>则总和将为<code>NaN</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 提取要求和的属性的函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>产生派生属性的和 
           </dd>
</dl> </li>
</ul> <a name="averagingInt-java.util.function.ToIntFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>averagingInt</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt; averagingInt(<a href="../../../java/util/function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它产生应用于输入元素的整数值函数的算术平均值。</span>
<span>如果没有元素，结果为0。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 提取要求和的属性的函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它产生派生属性的总和 
           </dd>
</dl> </li>
</ul> <a name="averagingLong-java.util.function.ToLongFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>averagingLong</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt; averagingLong(<a href="../../../java/util/function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它产生应用于输入元素的长值函数的算术平均值。</span>
<span>如果没有元素，结果为0。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 提取要求和的属性的函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>产生一个派生属性的总和 
           </dd>
</dl> </li>
</ul> <a name="averagingDouble-java.util.function.ToDoubleFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>averagingDouble</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/lang/Double.html" title="class in java.lang">Double</a>&gt; averagingDouble(<a href="../../../java/util/function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它产生应用于输入元素的双值函数的算术平均值。</span>
<span>如果没有元素，结果为0。</span>
<p> <span>返回的平均值可以根据记录值的顺序而变化，这是由于除了不同数值的值之外的累积舍入误差。</span> <span>按绝对数量增加排列的数值往往会产生更准确的结果。</span> <span>如果任何记录值是<code>NaN</code>或总和在任何一点<code>NaN</code>则平均值将为<code>NaN</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span><code>double</code>格式可以表示-2 <sup>53</sup>至2 <sup>53</sup>范围内的所有连续整数。</span>
<span>如果管道超过2 <sup>53个</sup>值，平均计算中的除数将在23 <sup>53度</sup>饱和，导致额外的数值误差。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 提取要求和的属性的函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>产生一个派生属性的总和 
           </dd>
</dl> </li>
</ul> <a name="reducing-java.lang.Object-java.util.function.BinaryOperator-">
<!-- --> </a><a name="reducing-T-java.util.function.BinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reducing</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,T&gt; reducing(T identity,
                                            <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</pre>
<div class="block">
            返回 
           <code>Collector</code>执行下一个指定的减少其输入元件的 
           <code>BinaryOperator</code>使用所提供的身份。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span><code>reducing()</code>收集器在多级别减少中使用时最有用， <code>groupingBy</code>或<code>partitioningBy</code> 。</span>
<span>要简单地减少流，请使用<a href="../../../java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-"><code>Stream.reduce(Object, BinaryOperator)</code></a> }。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 减少的输入和输出的元素类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>identity</code> - 减少的标识值（也是没有输入元素时返回的值） 
           </dd>
<dd>
<code>op</code> - a 
            <code>BinaryOperator&lt;T&gt;</code>用于减少输入元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>缩小操作的Collector 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#reducing-java.util.function.BinaryOperator-"><code>reducing(BinaryOperator)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#reducing-U-java.util.function.Function-java.util.function.BinaryOperator-"><code>reducing(Object, Function, BinaryOperator)</code></a>
</dd>
</dl> </li>
</ul> <a name="reducing-java.util.function.BinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reducing</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt; reducing(<a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它在指定的<code>Collector</code>下执行其输入元素的<code>BinaryOperator</code> 。</span>
<span>结果被描述为<code>Optional&lt;T&gt;</code> 。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>的<code>reducing()</code>收集器是在多级降低使用时最有用的，下游<code>groupingBy</code>或<code>partitioningBy</code> 。</span>
<span>要简单地减少流，请<a href="../../../java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-">改用<code>Stream.reduce(BinaryOperator)</code></a> 。</span>
<p> <span>例如，给出<code>Person</code>的流， <code>Person</code>每个城市的最高人数：</span> </p>
<pre>  <span><code> Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight); Map&lt;City, Person&gt; tallestByCity = people.stream().collect(groupingBy(Person::getCity, reducing(BinaryOperator.maxBy(byHeight)))); </code></span> </pre>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 减少输入和输出的元素类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>op</code> - 一个 
            <code>BinaryOperator&lt;T&gt;</code>用于减少输入元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>缩小操作的Collector 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#reducing-T-java.util.function.BinaryOperator-"><code>reducing(Object, BinaryOperator)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#reducing-U-java.util.function.Function-java.util.function.BinaryOperator-"><code>reducing(Object, Function, BinaryOperator)</code></a>
</dd>
</dl> </li>
</ul> <a name="reducing-java.lang.Object-java.util.function.Function-java.util.function.BinaryOperator-">
<!-- --> </a><a name="reducing-U-java.util.function.Function-java.util.function.BinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reducing</h4> <pre>public static &lt;T,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,U&gt; reducing(U identity,
                                              <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; mapper,
                                              <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; op)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它在指定的映射函数和<code>BinaryOperator</code>下执行其输入元素的<code>BinaryOperator</code> 。</span>
<span>这是<code>reducing(Object, BinaryOperator)</code>的<a href="../../../java/util/stream/Collectors.html#reducing-T-java.util.function.BinaryOperator-">泛化</a> ，其允许在还原之前转换元素。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>的<code>reducing()</code>收集器是在多级降低使用时最有用的，下游<code>groupingBy</code>或<code>partitioningBy</code> 。</span>
<span>要在流上执行简单的map-reduce，请<a href="../../../java/util/stream/Stream.html#map-java.util.function.Function-">改用<code>Stream.map(Function)</code></a>和<a href="../../../java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-"><code>Stream.reduce(Object, BinaryOperator)</code></a> 。</span>
<p> <span>例如，给出一个<code>Person</code>的流， <code>Person</code>每个城市居民最长的姓氏：</span> </p>
<pre>  <span><code> Comparator&lt;String&gt; byLength = Comparator.comparing(String::length); Map&lt;City, String&gt; longestLastNameByCity = people.stream().collect(groupingBy(Person::getCity, reducing(Person::getLastName, BinaryOperator.maxBy(byLength)))); </code></span> </pre>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>U</code> - 映射值的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>identity</code> - 减少的标识值（也是没有输入元素时返回的值） 
           </dd>
<dd>
<code>mapper</code> - 应用于每个输入值的映射函数 
           </dd>
<dd>
<code>op</code> - a 
            <code>BinaryOperator&lt;U&gt;</code>用于减少映射值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>实现了map-reduce操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#reducing-T-java.util.function.BinaryOperator-"><code>reducing(Object, BinaryOperator)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#reducing-java.util.function.BinaryOperator-"><code>reducing(BinaryOperator)</code></a>
</dd>
</dl> </li>
</ul> <a name="groupingBy-java.util.function.Function-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>groupingBy</h4> <pre>public static &lt;T,K&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt; groupingBy(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier)</pre>
<div class="block">
<span>返回<code>Collector</code> “由基团”上的类型的输入元件操作实现<code>T</code> ，根据分类功能分组元素，并且在返回的结果<code>Map</code> 。</span>
<p> <span>分类功能将元素映射到某些键类型<code>K</code> 。</span> <span>集电极产生一个<code>Map&lt;K, List&lt;T&gt;&gt;</code>的键是从施加所述分类功能的输入元件，并且其相应的值是所得的值<code>List</code>包含输入元件，其映射到分类函数下的相关联的密钥s。</span> </p>
<p> <span>对返回的<code>Map</code>或<code>List</code>对象的类型，可变性，可串行性或线程安全性没有<code>Map</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
<span>这产生的结果类似于：</span>
<pre>  <span><code> groupingBy(classifier, toList()); </code></span> </pre>
</dd>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>返回的<code>Collector</code>不是并发的。</span>
<span>对于并行流管线， <code>combiner</code>功能通过将一个地图的密钥合并到另一个地图中进行操作，这可能是一项昂贵的操作。</span>
<span>如果保存元素出现在生成的Map <code>Map</code>器中的顺序不需要，使用<a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-"><code>groupingByConcurrent(Function)</code></a>可能会提供更好的并行性能。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>classifier</code> - 分类器函数将输入元素映射到键 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>实现分组操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-"><code>groupingBy(Function, Collector)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-"><code>groupingBy(Function, Supplier, Collector)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-"><code>groupingByConcurrent(Function)</code></a>
</dd>
</dl> </li>
</ul> <a name="groupingBy-java.util.function.Function-java.util.stream.Collector-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>groupingBy</h4> <pre>public static &lt;T,K,A,D&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,D&gt;&gt; groupingBy(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier,
                                                           <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</pre>
<div class="block">
<span>返回<code>Collector</code> “由基团”上的类型的输入元件操作实现级联<code>T</code> ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算<code>Collector</code> 。</span>
<p> <span>分类功能将元素映射到某些键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>所得的收集器产生一个<code>Map&lt;K, D&gt;</code> 。</span> </p>
<p> <span>Map返回的类型，可变性，可串行性或线程安全性没有<code>Map</code> 。</span> </p>
<p> <span>例如，要计算每个城市的一组姓氏：</span> </p>
<pre>  <span><code> Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); </code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>返回的<code>Collector</code>不是并发的。</span>
<span>对于并行流管线， <code>combiner</code>功能通过将密钥从一个映射合并到另一个地址来进行操作，这可能是昂贵的操作。</span>
<span>如果不需要保存向下游收集器提供元素的顺序，则使用<a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Collector)</code></a>可以提供更好的并行性能。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键的类型 
           </dd>
<dd>
<code>A</code> - 下游收集器的中间堆积型 
           </dd>
<dd>
<code>D</code> - 
            <code>D</code>的结果类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>classifier</code> - 将输入元素映射到键的分类器函数 
           </dd>
<dd>
<code>downstream</code> - 一个 
            <code>Collector</code>实现下游缩减 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>级联组合操作的Collector 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-"><code>groupingBy(Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-"><code>groupingBy(Function, Supplier, Collector)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Collector)</code></a>
</dd>
</dl> </li>
</ul> <a name="groupingBy-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>groupingBy</h4> <pre>public static &lt;T,K,D,A,M extends <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,D&gt;&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt; groupingBy(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier,
                                                                       <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory,
                                                                       <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</pre>
<div class="block">
<span>返回<code>Collector</code> “由基团”上的类型的输入元件操作实现级联<code>T</code> ，根据分类功能分组元素，然后使用下游的指定执行与给定键相关联的值的归约运算<code>Collector</code> 。</span>
<span>由<code>Map</code>生成的Map是由提供的工厂功能创建的。</span>
<p> <span>分类功能将元素映射到一些关键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>所得的收集器产生一个<code>Map&lt;K, D&gt;</code> 。</span> </p>
<p> <span>例如，计算城市名称排序的每个城市的人姓名集：</span> </p>
<pre>  <span><code> Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, TreeMap::new, mapping(Person::getLastName, toSet()))); </code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>返回的<code>Collector</code>不是并发的。</span>
<span>对于并行流管线， <code>combiner</code>功能通过将一个地图的密钥合并到另一个地图中进行操作，这可能是一项昂贵的操作。</span>
<span>如果不要求将元素提交给下游收集器的顺序保留，则使用<a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>可以提供更好的并行性能。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键的类型 
           </dd>
<dd>
<code>A</code> - 下游收集器的中间堆积型 
           </dd>
<dd>
<code>D</code> - 
            <code>D</code>的结果类型 
           </dd>
<dd>
<code>M</code> -所得的类型 
            <code>Map</code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>classifier</code> - 将输入元素映射到键的分类器函数 
           </dd>
<dd>
<code>downstream</code> - a 
            <code>Collector</code>实现下游缩减 
           </dd>
<dd>
<code>mapFactory</code> - 一个函数，当被调用时，产生一个新的空的 
            <code>Map</code>所需的类型 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>级联组合操作的Collector 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-"><code>groupingBy(Function, Collector)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-"><code>groupingBy(Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>
</dd>
</dl> </li>
</ul> <a name="groupingByConcurrent-java.util.function.Function-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>groupingByConcurrent</h4> <pre>public static &lt;T,K&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt; groupingByConcurrent(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier)</pre>
<div class="block">
<span>返回一个并发<code>Collector</code> “由基团”上的类型的输入元件操作实现<code>T</code> ，根据分类功能分组元素。</span>
<p> <span>这是一个<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p>
<p> <span>分类功能将元素映射到某些键类型<code>K</code> 。</span> <span>集电极产生一个<code>ConcurrentMap&lt;K, List&lt;T&gt;&gt;</code>的键是从施加所述分类功能的输入元件，并且其相应的值是所得的值<code>List</code>包含输入元件，其映射到分类函数下的相关联的密钥s。</span> </p>
<p> <span>对返回的<code>Map</code>或<code>List</code>对象的类型，可变性或可序列性，或返回的<code>List</code>对象的线程安全性没有<code>List</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">实现要求：</span>
</dt>
<dd>
<span>这产生的结果类似于：</span>
<pre>  <span><code> groupingByConcurrent(classifier, toList()); </code></span> </pre>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>classifier</code> - 将输入元素映射到键的分类器函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个并发的，无序的 
            <code>Collector</code>实现了group-by操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-"><code>groupingBy(Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Collector)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>
</dd>
</dl> </li>
</ul> <a name="groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>groupingByConcurrent</h4> <pre>public static &lt;T,K,A,D&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,D&gt;&gt; groupingByConcurrent(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier,
                                                                               <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</pre>
<div class="block">
<span>返回一个并发的<code>Collector</code> ，对类型为<code>T</code>输入元素进行级联“分组”操作，根据分类功能对元素进行分组，然后使用指定的下游Collector对与给定键相关联的值执行缩减<code>Collector</code> 。</span>
<p> <span>这是一个<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p>
<p> <span>分类功能将元素映射到一些关键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>所得的收集器产生一个<code>Map&lt;K, D&gt;</code> 。</span> </p>
<p> <span>例如，计算城市名称排序的每个城市的人姓名集：</span> </p>
<pre>  <span><code> ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingByConcurrent(Person::getCity, mapping(Person::getLastName, toSet()))); </code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键的类型 
           </dd>
<dd>
<code>A</code> - 下游收集器的中间堆积型 
           </dd>
<dd>
<code>D</code> - 
            <code>D</code>的结果类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>classifier</code> - 将输入元素映射到键的分类器函数 
           </dd>
<dd>
<code>downstream</code> - a 
            <code>Collector</code>实现下游减排 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个并发的，无序的 
            <code>Collector</code>实现了级联组合操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-"><code>groupingBy(Function, Collector)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-"><code>groupingByConcurrent(Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>
</dd>
</dl> </li>
</ul> <a name="groupingByConcurrent-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>groupingByConcurrent</h4> <pre>public static &lt;T,K,A,D,M extends <a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,D&gt;&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt; groupingByConcurrent(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; classifier,
                                                                                           <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapFactory,
                                                                                           <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</pre>
<div class="block">
<span>返回一个并发的<code>Collector</code>它对类型为<code>T</code>输入元素进行级联“分组”操作，根据分类功能分组元素，然后使用指定的下游Collector对与给定键相关联的值执行缩减<code>Collector</code> 。</span>
<span>由<code>ConcurrentMap</code>生产的ConcurrentMap由提供的工厂功能创建。</span>
<p> <span>这是一个<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p>
<p> <span>分类功能将元素映射到某些键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>所得的收集器产生一个<code>Map&lt;K, D&gt;</code> 。</span> </p>
<p> <span>例如，计算城市名称排序的每个城市的人姓名集：</span> </p>
<pre>  <span><code> ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new, mapping(Person::getLastName, toSet()))); </code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键的类型 
           </dd>
<dd>
<code>A</code> - 下游收集器的中间累积类型 
           </dd>
<dd>
<code>D</code> - 
            <code>D</code>的结果类型 
           </dd>
<dd>
<code>M</code> -所得的类型 
            <code>ConcurrentMap</code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>classifier</code> - 将输入元素映射到键的分类器函数 
           </dd>
<dd>
<code>downstream</code> - a 
            <code>Collector</code>实现下游减少 
           </dd>
<dd>
<code>mapFactory</code> - 当被调用时产生所需类型的新的空的 
            <code>ConcurrentMap</code>的功能 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个并发的，无序的 
            <code>Collector</code>实现了级联组合操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-"><code>groupingByConcurrent(Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-java.util.stream.Collector-"><code>groupingByConcurrent(Function, Collector)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.function.Supplier-java.util.stream.Collector-"><code>groupingBy(Function, Supplier, Collector)</code></a>
</dd>
</dl> </li>
</ul> <a name="partitioningBy-java.util.function.Predicate-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>partitioningBy</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>,<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt; partitioningBy(<a href="../../../java/util/function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt; predicate)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它根据Predicate对输入元素进行<code>Predicate</code> ，并将它们组织成<code>Map&lt;Boolean, List&lt;T&gt;&gt;</code> 。</span>
<span>Map返回的类型，可变性，可串行性或线程安全性没有<code>Map</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>predicate</code> - 用于对输入元素进行分类的谓词 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>实现分区操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-java.util.stream.Collector-"><code>partitioningBy(Predicate, Collector)</code></a>
</dd>
</dl> </li>
</ul> <a name="partitioningBy-java.util.function.Predicate-java.util.stream.Collector-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>partitioningBy</h4> <pre>public static &lt;T,D,A&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../../../java/lang/Boolean.html" title="class in java.lang">Boolean</a>,D&gt;&gt; partitioningBy(<a href="../../../java/util/function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt; predicate,
                                                                   <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,A,D&gt; downstream)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它根据Predicate对输入元素进行<code>Predicate</code> ，根据另一个<code>Collector</code>减少每个分区中的值，并将其组织成<code>Map&lt;Boolean, D&gt;</code> ，其值是下游缩减的结果。</span>
<p> <span>Map返回的类型，可变性，可串行性或线程安全性没有<code>Map</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>A</code> - 下游收集器的中间堆积型 
           </dd>
<dd>
<code>D</code> - 
            <code>D</code>的结果类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>predicate</code> - 用于对输入元素进行分类的谓词 
           </dd>
<dd>
<code>downstream</code> - a 
            <code>Collector</code>实现下游减少 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>实现级联分区操作 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-"><code>partitioningBy(Predicate)</code></a>
</dd>
</dl> </li>
</ul> <a name="toMap-java.util.function.Function-java.util.function.Function-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toMap</h4> <pre>public static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,U&gt;&gt; toMap(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper,
                                                    <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它将元素累加到一个<code>Map</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。</span>
<p> <span>如果映射键包含重复（如<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a> ），一个<code>IllegalStateException</code>执行收集操作时被抛出。</span> <span>如果映射的密钥可能有重复，请<a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-">改用<code>toMap(Function, Function, BinaryOperator)</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>键或值作为输入元素是常见的。</span>
<span>在这种情况下，实用方法<a href="../../../java/util/function/Function.html#identity--"><code>Function.identity()</code></a>可能是有帮助的。</span>
<span>例如，以下产生一个<code>Map</code>映射学生到他们的平均成绩：</span>
<pre>  <span><code> Map&lt;Student, Double&gt; studentToGPA students.stream().collect(toMap(Functions.identity(), student -&gt; computeGPA(student))); </code></span> </pre>
<span>以下产生一个<code>Map</code>映射学生的唯一标识符：</span>
<pre>  <span><code> Map&lt;String, Student&gt; studentIdToStudent students.stream().collect(toMap(Student::getId, Functions.identity()); </code></span> </pre>
</dd>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>返回的<code>Collector</code>不是并发的。</span>
<span>对于并行流管线， <code>combiner</code>功能通过将一个地图的密钥合并到另一个地图中进行操作，这可能是一项昂贵的操作。</span>
<span>如果不需要将结果插入到<code>Map</code>中，使用<a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-"><code>toConcurrentMap(Function, Function)</code></a>可能会提供更好的并行性能。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键映射功能的输出类型 
           </dd>
<dd>
<code>U</code> - 值映射函数的输出类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>keyMapper</code> - 产生密钥的映射函数 
           </dd>
<dd>
<code>valueMapper</code> - 产生值的映射函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它将元素收集到一个 
            <code>Map</code> ，其键和值是将映射函数应用于输入元素的结果 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-"><code>toMap(Function, Function, BinaryOperator)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-"><code>toConcurrentMap(Function, Function)</code></a>
</dd>
</dl> </li>
</ul> <a name="toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toMap</h4> <pre>public static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,U&gt;&gt; toMap(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper,
                                                    <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper,
                                                    <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它将元素累加到一个<code>Map</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。</span>
<p> <span>如果映射的密钥包含重复（根据<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a> ），则值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>有多种方法来处理映射到同一个密钥的多个元素之间的冲突。</span>
<span>其他形式的<code>toMap</code>只是使用无条件抛出的合并函数，但您可以轻松编写更灵活的合并策略。</span>
<span>例如，如果您有一个<code>Person</code>的流，并且您想要生成一个“电话簿”映射名称来解决，但是可能有两个人具有相同的名称，您可以按照以下方式优雅地处理这些冲突，并产生一个<code>Map</code>映射名称到一个并置的地址列表：</span>
<pre>  <span><code> Map&lt;String, String&gt; phoneBook people.stream().collect(toMap(Person::getName, Person::getAddress, (s, a) -&gt; s + ", " + a)); </code></span> </pre>
</dd>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>返回的<code>Collector</code>不是并发的。</span>
<span>对于并行流管线， <code>combiner</code>功能通过将一个地图的密钥合并到另一个地图中进行操作，这可能是一项昂贵的操作。</span>
<span>如果不需要将结果合并到<code>Map</code>中，使用<a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a>可能会提供更好的并行性能。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键映射功能的输出类型 
           </dd>
<dd>
<code>U</code> - 值映射函数的输出类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>keyMapper</code> - 产生密钥的映射函数 
           </dd>
<dd>
<code>valueMapper</code> - 产生值的映射函数 
           </dd>
<dd>
<code>mergeFunction</code> - 一个合并函数，用于解决与相同键相关联的值之间的冲突，提供给 
            <a href="../../../java/util/Map.html#merge-K-V-java.util.function.BiFunction-"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它将元素收集到一个 
            <code>Map</code> ，其关键是将键映射函数应用于输入元素，其值是将值映射函数应用于所有等于键的输入元素的结果，并使用合并功能 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-"><code>toMap(Function, Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a>
</dd>
</dl> </li>
</ul> <a name="toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toMap</h4> <pre>public static &lt;T,K,U,M extends <a href="../../../java/util/Map.html" title="interface in java.util">Map</a>&lt;K,U&gt;&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt; toMap(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper,
                                                                <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper,
                                                                <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction,
                                                                <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapSupplier)</pre>
<div class="block">
<span>返回一个<code>Collector</code> ，它将元素累加到一个<code>Map</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。</span>
<p> <span>如果映射的密钥包含重复（根据<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a> ），则值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> <span><code>Map</code>由提供的供应商功能创建。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>返回的<code>Collector</code>不是并发的。</span>
<span>对于并行流管线， <code>combiner</code>功能通过将一个地图的密钥合并到另一个地图来进行操作，这可能是一项昂贵的操作。</span>
<span>如果不需要将结果合并到<code>Map</code>中，使用<a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a>可能会提供更好的并行性能。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键映射功能的输出类型 
           </dd>
<dd>
<code>U</code> - 值映射函数的输出类型 
           </dd>
<dd>
<code>M</code> - 结果的类型 
            <code>Map</code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>keyMapper</code> - 产生密钥的映射函数 
           </dd>
<dd>
<code>valueMapper</code> - 产生值的映射函数 
           </dd>
<dd>
<code>mergeFunction</code> - 一个合并函数，用于解决与相同键相关联的值之间的冲突，提供给 
            <a href="../../../java/util/Map.html#merge-K-V-java.util.function.BiFunction-"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd>
<dd>
<code>mapSupplier</code> - 返回一个新的空的 
            <code>Map</code>的函数，其中将插入结果 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code> ，它将元素收集到一个 
            <code>Map</code> ，其关键是将键映射函数应用于输入元素，其值是将值映射函数应用于等于该键的所有输入元素的结果，并使用合并功能 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-"><code>toMap(Function, Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-"><code>toMap(Function, Function, BinaryOperator)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a>
</dd>
</dl> </li>
</ul> <a name="toConcurrentMap-java.util.function.Function-java.util.function.Function-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toConcurrentMap</h4> <pre>public static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,U&gt;&gt; toConcurrentMap(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper,
                                                                        <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper)</pre>
<div class="block">
<span>返回一个并发的<code>Collector</code> ，它将元素累加到一个<code>ConcurrentMap</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。</span>
<p> <span>如果映射的密钥包含重复（根据<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a> ），则<code>IllegalStateException</code>操作时将抛出IllegalStateException。</span> <span>如果映射的密钥可能有重复，请<a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-">改用<code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>键或值作为输入元素是常见的。</span>
<span>在这种情况下，实用方法<a href="../../../java/util/function/Function.html#identity--"><code>Function.identity()</code></a>可能是有帮助的。</span>
<span>例如，以下产生一个<code>Map</code>映射学生到他们的平均成绩：</span>
<pre>  <span><code> Map&lt;Student, Double&gt; studentToGPA students.stream().collect(toMap(Functions.identity(), student -&gt; computeGPA(student))); </code></span> </pre>
<span>以下产生一个<code>Map</code>映射学生的唯一标识符：</span>
<pre>  <span><code> Map&lt;String, Student&gt; studentIdToStudent students.stream().collect(toConcurrentMap(Student::getId, Functions.identity()); </code></span> </pre>
<p> <span>这是一个<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键映射功能的输出类型 
           </dd>
<dd>
<code>U</code> - 值映射函数的输出类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>keyMapper</code> - 产生密钥的映射函数 
           </dd>
<dd>
<code>valueMapper</code> - 产生值的映射函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             并发，无序 
            <code>Collector</code> ，其收集元件成 
            <code>ConcurrentMap</code> ，其键是应用密钥映射函数的输入元件，并且其值是施加值映射函数的输入元素的结果的结果 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-"><code>toMap(Function, Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a>
</dd>
</dl> </li>
</ul> <a name="toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toConcurrentMap</h4> <pre>public static &lt;T,K,U&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,U&gt;&gt; toConcurrentMap(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper,
                                                                        <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper,
                                                                        <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction)</pre>
<div class="block">
<span>返回一个并发的<code>Collector</code> ，它将元素累加到一个<code>ConcurrentMap</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。</span>
<p> <span>如果映射的密钥包含重复（根据<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a> ），则值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">API Note:</span>
</dt>
<dd>
<span>有多种方法来处理映射到同一个密钥的多个元素之间的冲突。</span>
<span>其他形式的<code>toConcurrentMap</code>只是使用无条件抛出的合并函数，但您可以轻松地编写更灵活的合并策略。</span>
<span>例如，如果您有一个<code>Person</code>的流，并且您要生成一个“电话簿”映射名称来寻址，但是有可能两个人具有相同的名称，您可以如下处理这些冲突，并产生一个<code>Map</code>映射名称到一个并置的地址列表：</span>
<pre>  <span><code> Map&lt;String, String&gt; phoneBook people.stream().collect(toConcurrentMap(Person::getName, Person::getAddress, (s, a) -&gt; s + ", " + a)); </code></span> </pre>
<p> <span>这是一个<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键映射功能的输出类型 
           </dd>
<dd>
<code>U</code> - 值映射函数的输出类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>keyMapper</code> - 产生密钥的映射函数 
           </dd>
<dd>
<code>valueMapper</code> - 产生值的映射函数 
           </dd>
<dd>
<code>mergeFunction</code> - 一个合并函数，用于解决与相同键相关联的值之间的冲突，提供给 
            <a href="../../../java/util/Map.html#merge-K-V-java.util.function.BiFunction-"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个并发的，无序的 
            <code>Collector</code> ，它将元素收集到一个 
            <code>ConcurrentMap</code> ，其关键是将键映射函数应用于输入元素，其值是将值映射函数应用于等于该键的所有输入元素并结合它们的结果使用合并功能 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-"><code>toConcurrentMap(Function, Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-"><code>toMap(Function, Function, BinaryOperator)</code></a>
</dd>
</dl> </li>
</ul> <a name="toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toConcurrentMap</h4> <pre>public static &lt;T,K,U,M extends <a href="../../../java/util/concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,U&gt;&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,M&gt; toConcurrentMap(<a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends K&gt; keyMapper,
                                                                                    <a href="../../../java/util/function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,? extends U&gt; valueMapper,
                                                                                    <a href="../../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt; mergeFunction,
                                                                                    <a href="../../../java/util/function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt; mapSupplier)</pre>
<div class="block">
<span>返回一个并发的<code>Collector</code> ，它将元素累加到一个<code>ConcurrentMap</code> ，其键和值是将所提供的映射函数应用于输入元素的结果。</span>
<p> <span>如果映射的密钥包含重复（根据<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a> ），则值映射函数将应用于每个相等元素，并使用提供的合并函数合并结果。</span> <span><code>ConcurrentMap</code>由提供的供应商功能创建。</span> </p>
<p> <span>这是一个<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dd>
<code>K</code> - 键映射功能的输出类型 
           </dd>
<dd>
<code>U</code> - 值映射函数的输出类型 
           </dd>
<dd>
<code>M</code> - 结果的类型 
            <code>ConcurrentMap</code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>keyMapper</code> - 产生密钥的映射函数 
           </dd>
<dd>
<code>valueMapper</code> - 产生值的映射函数 
           </dd>
<dd>
<code>mergeFunction</code> - 一个合并函数，用于解决与相同键相关联的值之间的冲突，提供给 
            <a href="../../../java/util/Map.html#merge-K-V-java.util.function.BiFunction-"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd>
<dd>
<code>mapSupplier</code> - 返回一个新的，空的 
            <code>Map</code>的函数，结果将被插入到该函数中 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个并发的，无序的 
            <code>Collector</code> ，它将元素收集到一个 
            <code>ConcurrentMap</code> ，其关键是将键映射函数应用于输入元素，其值是将值映射函数应用于等于键的所有输入元素并将其组合使用合并功能 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-"><code>toConcurrentMap(Function, Function)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a>
</dd>
</dl> </li>
</ul> <a name="summarizingInt-java.util.function.ToIntFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>summarizingInt</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/IntSummaryStatistics.html" title="class in java.util">IntSummaryStatistics</a>&gt; summarizingInt(<a href="../../../java/util/function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
            返回一个 
           <code>Collector</code> ， 
           <code>int</code>生成映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 应用于每个元素的映射函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>执行汇总统计减少 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#summarizingDouble-java.util.function.ToDoubleFunction-"><code>summarizingDouble(ToDoubleFunction)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#summarizingLong-java.util.function.ToLongFunction-"><code>summarizingLong(ToLongFunction)</code></a>
</dd>
</dl> </li>
</ul> <a name="summarizingLong-java.util.function.ToLongFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>summarizingLong</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/LongSummaryStatistics.html" title="class in java.util">LongSummaryStatistics</a>&gt; summarizingLong(<a href="../../../java/util/function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
            返回一个 
           <code>Collector</code> ， 
           <code>long</code>生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 应用于每个元素的映射函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>执行汇总统计减少 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#summarizingDouble-java.util.function.ToDoubleFunction-"><code>summarizingDouble(ToDoubleFunction)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#summarizingInt-java.util.function.ToIntFunction-"><code>summarizingInt(ToIntFunction)</code></a>
</dd>
</dl> </li>
</ul> <a name="summarizingDouble-java.util.function.ToDoubleFunction-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>summarizingDouble</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,?,<a href="../../../java/util/DoubleSummaryStatistics.html" title="class in java.util">DoubleSummaryStatistics</a>&gt; summarizingDouble(<a href="../../../java/util/function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt; mapper)</pre>
<div class="block">
            返回一个 
           <code>Collector</code> ， 
           <code>double</code>生产映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 输入元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mapper</code> - 应用于每个元素的映射函数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Collector</code>执行汇总统计减少 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/stream/Collectors.html#summarizingLong-java.util.function.ToLongFunction-"><code>summarizingLong(ToLongFunction)</code></a> ， 
            <a href="../../../java/util/stream/Collectors.html#summarizingInt-java.util.function.ToIntFunction-"><code>summarizingInt(ToIntFunction)</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>