<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util 
   </div>
<h2 class="title" title="Class Arrays">Class Arrays</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.Arrays</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">Arrays</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>该类包含用于操作数组的各种方法（如排序和搜索）。</span>
<span>该类还包含一个静态工厂，可以将数组视为列表。</span>
<p> <span>如果指定的数组引用为空，则该类中的方法都抛出一个<code>NullPointerException</code> ，除非另有说明。</span> </p>
<p> <span>该类中包含的方法的文档包括实现的简要<i>描述</i> 。</span> <span>这些描述应被视为<i>实施说明</i> ，而不是<i>说明书的一部分</i> 。</span> <span>只要规范本身得到遵守，实现者就可以随意替代其他算法。</span> <span>（例如，sort(Object[])使用的<code>sort(Object[])</code>不一定是MergeSort，但它必须是<i>稳定的</i> 。）</span> </p>
<p> <span>这个班是<a href="../../../technotes/guides/collections/index.html">Java Collections Framework</a>的成员。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.2 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#asList-T...-">asList</a></span>(T... a)</code>
<div class="block">
              返回由指定数组支持的固定大小的列表。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-byte:A-byte-">binarySearch</a></span>(byte[] a, byte key)</code>
<div class="block">
              使用二进制搜索算法搜索指定值的指定字节数组。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-byte:A-int-int-byte-">binarySearch</a></span>(byte[] a, int fromIndex, int toIndex, byte key)</code>
<div class="block">
              使用二进制搜索算法搜索指定值的指定字节数组的范围。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-char:A-char-">binarySearch</a></span>(char[] a, char key)</code>
<div class="block">
              使用二进制搜索算法搜索指定数组的指定值。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-char:A-int-int-char-">binarySearch</a></span>(char[] a, int fromIndex, int toIndex, char key)</code>
<div class="block">
              使用二分搜索算法搜索指定值的指定数组的范围。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-double:A-double-">binarySearch</a></span>(double[] a, double key)</code>
<div class="block">
              使用二进制搜索算法搜索指定值的指定数组的双精度值。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-double:A-int-int-double-">binarySearch</a></span>(double[] a, int fromIndex, int toIndex, double key)</code>
<div class="block">
              使用二分搜索算法搜索指定值的指定数组的双精度范围。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-float:A-float-">binarySearch</a></span>(float[] a, float key)</code>
<div class="block">
              使用二叉搜索算法搜索指定数组的浮点数。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-float:A-int-int-float-">binarySearch</a></span>(float[] a, int fromIndex, int toIndex, float key)</code>
<div class="block">
              使用二分搜索算法搜索指定数组的浮点数范围。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-int:A-int-">binarySearch</a></span>(int[] a, int key)</code>
<div class="block">
              使用二叉搜索算法搜索指定的int数组的指定值。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-int:A-int-int-int-">binarySearch</a></span>(int[] a, int fromIndex, int toIndex, int key)</code>
<div class="block">
              使用二叉搜索算法搜索指定值的指定数组的范围。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-long:A-int-int-long-">binarySearch</a></span>(long[] a, int fromIndex, int toIndex, long key)</code>
<div class="block">
              使用二分搜索算法搜索指定值的指定数组的范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-long:A-long-">binarySearch</a></span>(long[] a, long key)</code>
<div class="block">
              使用二进制搜索算法搜索指定数组的指定数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-java.lang.Object:A-int-int-java.lang.Object-">binarySearch</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a, int fromIndex, int toIndex, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> key)</code>
<div class="block">
              使用二进制搜索算法搜索指定对象的指定数组的范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-java.lang.Object:A-java.lang.Object-">binarySearch</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> key)</code>
<div class="block">
              使用二叉搜索算法搜索指定对象的指定数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-short:A-int-int-short-">binarySearch</a></span>(short[] a, int fromIndex, int toIndex, short key)</code>
<div class="block">
              使用二进制搜索算法搜索指定值的指定数组的短整型范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-short:A-short-">binarySearch</a></span>(short[] a, short key)</code>
<div class="block">
              使用二进制搜索算法搜索指定值的指定数组的指定值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static &lt;T&gt; int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-T:A-int-int-T-java.util.Comparator-">binarySearch</a></span>(T[] a, int fromIndex, int toIndex, T key, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</code>
<div class="block">
              使用二进制搜索算法搜索指定对象的指定数组的范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static &lt;T&gt; int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#binarySearch-T:A-T-java.util.Comparator-">binarySearch</a></span>(T[] a, T key, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</code>
<div class="block">
              使用二叉搜索算法搜索指定对象的指定数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static boolean[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-boolean:A-int-">copyOf</a></span>(boolean[] original, int newLength)</code>
<div class="block">
              使用 
             <tt>false</tt> （如有必要）复制指定的数组，截断或填充，以使副本具有指定的长度。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-byte:A-int-">copyOf</a></span>(byte[] original, int newLength)</code>
<div class="block">
              复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>static char[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-char:A-int-">copyOf</a></span>(char[] original, int newLength)</code>
<div class="block">
              复制指定的数组，截断或填充空字符（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-double:A-int-">copyOf</a></span>(double[] original, int newLength)</code>
<div class="block">
              复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>static float[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-float:A-int-">copyOf</a></span>(float[] original, int newLength)</code>
<div class="block">
              复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-int:A-int-">copyOf</a></span>(int[] original, int newLength)</code>
<div class="block">
              复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>static long[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-long:A-int-">copyOf</a></span>(long[] original, int newLength)</code>
<div class="block">
              复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>static short[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-short:A-int-">copyOf</a></span>(short[] original, int newLength)</code>
<div class="block">
              复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>static &lt;T&gt; T[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-T:A-int-">copyOf</a></span>(T[] original, int newLength)</code>
<div class="block">
              复制指定的数组，用空值截断或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>static &lt;T,U&gt; T[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOf-U:A-int-java.lang.Class-">copyOf</a></span>(U[] original, int newLength, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends T[]&gt; newType)</code>
<div class="block">
              复制指定的数组，用空值截断或填充（如有必要），以便复制具有指定的长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>static boolean[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-boolean:A-int-int-">copyOfRange</a></span>(boolean[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>static byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-byte:A-int-int-">copyOfRange</a></span>(byte[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>static char[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-char:A-int-int-">copyOfRange</a></span>(char[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-double:A-int-int-">copyOfRange</a></span>(double[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>static float[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-float:A-int-int-">copyOfRange</a></span>(float[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-int:A-int-int-">copyOfRange</a></span>(int[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code>static long[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-long:A-int-int-">copyOfRange</a></span>(long[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code>static short[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-short:A-int-int-">copyOfRange</a></span>(short[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code>static &lt;T&gt; T[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-T:A-int-int-">copyOfRange</a></span>(T[] original, int from, int to)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code>static &lt;T,U&gt; T[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#copyOfRange-U:A-int-int-java.lang.Class-">copyOfRange</a></span>(U[] original, int from, int to, <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends T[]&gt; newType)</code>
<div class="block">
              将指定数组的指定范围复制到新数组中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i39">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#deepEquals-java.lang.Object:A-java.lang.Object:A-">deepEquals</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a1, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a2)</code>
<div class="block">
              如果两个指定的数组彼此 
             <i>深度相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i40">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#deepHashCode-java.lang.Object:A-">deepHashCode</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</code>
<div class="block">
              根据指定数组的“深度内容”返回哈希码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i41">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#deepToString-java.lang.Object:A-">deepToString</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</code>
<div class="block">
              返回指定数组的“深度内容”的字符串表示形式。 
            </div> </td>
</tr>
<tr class="altColor" id="i42">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-boolean:A-boolean:A-">equals</a></span>(boolean[] a, boolean[] a2)</code>
<div class="block">
              如果两个指定的布尔数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i43">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-byte:A-byte:A-">equals</a></span>(byte[] a, byte[] a2)</code>
<div class="block">
              如果两个指定的字节数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i44">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-char:A-char:A-">equals</a></span>(char[] a, char[] a2)</code>
<div class="block">
              如果两个指定的字符数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i45">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-double:A-double:A-">equals</a></span>(double[] a, double[] a2)</code>
<div class="block">
              如果两个指定的双精度数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i46">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-float:A-float:A-">equals</a></span>(float[] a, float[] a2)</code>
<div class="block">
              如果两个指定的浮动数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i47">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-int:A-int:A-">equals</a></span>(int[] a, int[] a2)</code>
<div class="block">
              如果两个指定的int数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i48">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-long:A-long:A-">equals</a></span>(long[] a, long[] a2)</code>
<div class="block">
              如果两个指定的longs数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i49">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-java.lang.Object:A-java.lang.Object:A-">equals</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a2)</code>
<div class="block">
              如果两个指定的对象数组彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i50">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#equals-short:A-short:A-">equals</a></span>(short[] a, short[] a2)</code>
<div class="block">
              如果两个指定的短裤阵列彼此 
             <i>相等</i> ，则返回 
             <tt>true</tt> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i51">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-boolean:A-boolean-">fill</a></span>(boolean[] a, boolean val)</code>
<div class="block">
              将指定的布尔值分配给指定的布尔数组的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i52">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-boolean:A-int-int-boolean-">fill</a></span>(boolean[] a, int fromIndex, int toIndex, boolean val)</code>
<div class="block">
              将指定的布尔值分配给指定数组布尔值的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i53">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-byte:A-byte-">fill</a></span>(byte[] a, byte val)</code>
<div class="block">
              将指定的字节值分配给指定字节数组的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i54">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-byte:A-int-int-byte-">fill</a></span>(byte[] a, int fromIndex, int toIndex, byte val)</code>
<div class="block">
              将指定的字节值分配给指定字节数组的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i55">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-char:A-char-">fill</a></span>(char[] a, char val)</code>
<div class="block">
              将指定的char值分配给指定的char数组的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i56">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-char:A-int-int-char-">fill</a></span>(char[] a, int fromIndex, int toIndex, char val)</code>
<div class="block">
              将指定的char值分配给指定的char数组的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i57">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-double:A-double-">fill</a></span>(double[] a, double val)</code>
<div class="block">
              将指定的double值分配给指定的双精度数组的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i58">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-double:A-int-int-double-">fill</a></span>(double[] a, int fromIndex, int toIndex, double val)</code>
<div class="block">
              将指定的double值分配给指定的双精度数组范围的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i59">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-float:A-float-">fill</a></span>(float[] a, float val)</code>
<div class="block">
              将指定的float值分配给指定的浮点数组的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i60">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-float:A-int-int-float-">fill</a></span>(float[] a, int fromIndex, int toIndex, float val)</code>
<div class="block">
              将指定的浮点值分配给指定的浮点数组的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i61">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-int:A-int-">fill</a></span>(int[] a, int val)</code>
<div class="block">
              将指定的int值分配给指定的int数组的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i62">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-int:A-int-int-int-">fill</a></span>(int[] a, int fromIndex, int toIndex, int val)</code>
<div class="block">
              将指定的int值分配给指定的int数组的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i63">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-long:A-int-int-long-">fill</a></span>(long[] a, int fromIndex, int toIndex, long val)</code>
<div class="block">
              将指定的long值分配给指定的longs数组的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i64">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-long:A-long-">fill</a></span>(long[] a, long val)</code>
<div class="block">
              将指定的long值分配给指定的longs数组的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i65">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-java.lang.Object:A-int-int-java.lang.Object-">fill</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a, int fromIndex, int toIndex, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> val)</code>
<div class="block">
              将指定的对象引用分配给指定的对象数组的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i66">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-java.lang.Object:A-java.lang.Object-">fill</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> val)</code>
<div class="block">
              将指定的对象引用分配给指定的对象数组的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i67">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-short:A-int-int-short-">fill</a></span>(short[] a, int fromIndex, int toIndex, short val)</code>
<div class="block">
              将指定的短值分配给指定的短裤数组的指定范围的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i68">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#fill-short:A-short-">fill</a></span>(short[] a, short val)</code>
<div class="block">
              将指定的短值分配给指定的短裤数组的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i69">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-boolean:A-">hashCode</a></span>(boolean[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="altColor" id="i70">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-byte:A-">hashCode</a></span>(byte[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i71">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-char:A-">hashCode</a></span>(char[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="altColor" id="i72">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-double:A-">hashCode</a></span>(double[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i73">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-float:A-">hashCode</a></span>(float[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="altColor" id="i74">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-int:A-">hashCode</a></span>(int[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i75">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-long:A-">hashCode</a></span>(long[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="altColor" id="i76">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-java.lang.Object:A-">hashCode</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i77">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#hashCode-short:A-">hashCode</a></span>(short[] a)</code>
<div class="block">
              根据指定数组的内容返回哈希码。 
            </div> </td>
</tr>
<tr class="altColor" id="i78">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-double:A-java.util.function.DoubleBinaryOperator-">parallelPrefix</a></span>(double[] array, <a href="../../java/util/function/DoubleBinaryOperator.html" title="interface in java.util.function">DoubleBinaryOperator</a> op)</code>
<div class="block">
              使用提供的功能，并行地计算给定阵列的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i79">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-double:A-int-int-java.util.function.DoubleBinaryOperator-">parallelPrefix</a></span>(double[] array, int fromIndex, int toIndex, <a href="../../java/util/function/DoubleBinaryOperator.html" title="interface in java.util.function">DoubleBinaryOperator</a> op)</code>
<div class="block">
              对于数组的给定子范围执行 
             <a href="../../java/util/Arrays.html#parallelPrefix-double:A-java.util.function.DoubleBinaryOperator-"><code>parallelPrefix(double[], DoubleBinaryOperator)</code></a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i80">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-int:A-java.util.function.IntBinaryOperator-">parallelPrefix</a></span>(int[] array, <a href="../../java/util/function/IntBinaryOperator.html" title="interface in java.util.function">IntBinaryOperator</a> op)</code>
<div class="block">
              使用提供的功能，并行地计算给定阵列的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i81">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-int:A-int-int-java.util.function.IntBinaryOperator-">parallelPrefix</a></span>(int[] array, int fromIndex, int toIndex, <a href="../../java/util/function/IntBinaryOperator.html" title="interface in java.util.function">IntBinaryOperator</a> op)</code>
<div class="block">
              对于数组的给定子范围执行 
             <a href="../../java/util/Arrays.html#parallelPrefix-int:A-java.util.function.IntBinaryOperator-"><code>parallelPrefix(int[], IntBinaryOperator)</code></a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i82">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-long:A-int-int-java.util.function.LongBinaryOperator-">parallelPrefix</a></span>(long[] array, int fromIndex, int toIndex, <a href="../../java/util/function/LongBinaryOperator.html" title="interface in java.util.function">LongBinaryOperator</a> op)</code>
<div class="block">
              对于数组的给定子范围执行 
             <a href="../../java/util/Arrays.html#parallelPrefix-long:A-java.util.function.LongBinaryOperator-"><code>parallelPrefix(long[], LongBinaryOperator)</code></a> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i83">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-long:A-java.util.function.LongBinaryOperator-">parallelPrefix</a></span>(long[] array, <a href="../../java/util/function/LongBinaryOperator.html" title="interface in java.util.function">LongBinaryOperator</a> op)</code>
<div class="block">
              使用提供的功能，并行地计算给定阵列的每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i84">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-T:A-java.util.function.BinaryOperator-">parallelPrefix</a></span>(T[] array, <a href="../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</code>
<div class="block">
              使用提供的功能，并行地计算给定阵列的每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i85">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelPrefix-T:A-int-int-java.util.function.BinaryOperator-">parallelPrefix</a></span>(T[] array, int fromIndex, int toIndex, <a href="../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</code>
<div class="block">
              对于数组的给定子范围执行 
             <a href="../../java/util/Arrays.html#parallelPrefix-T:A-java.util.function.BinaryOperator-"><code>parallelPrefix(Object[], BinaryOperator)</code></a> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i86">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSetAll-double:A-java.util.function.IntToDoubleFunction-">parallelSetAll</a></span>(double[] array, <a href="../../java/util/function/IntToDoubleFunction.html" title="interface in java.util.function">IntToDoubleFunction</a> generator)</code>
<div class="block">
              使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i87">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSetAll-int:A-java.util.function.IntUnaryOperator-">parallelSetAll</a></span>(int[] array, <a href="../../java/util/function/IntUnaryOperator.html" title="interface in java.util.function">IntUnaryOperator</a> generator)</code>
<div class="block">
              使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i88">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSetAll-long:A-java.util.function.IntToLongFunction-">parallelSetAll</a></span>(long[] array, <a href="../../java/util/function/IntToLongFunction.html" title="interface in java.util.function">IntToLongFunction</a> generator)</code>
<div class="block">
              使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i89">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSetAll-T:A-java.util.function.IntFunction-">parallelSetAll</a></span>(T[] array, <a href="../../java/util/function/IntFunction.html" title="interface in java.util.function">IntFunction</a>&lt;? extends T&gt; generator)</code>
<div class="block">
              使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i90">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-byte:A-">parallelSort</a></span>(byte[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i91">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-byte:A-int-int-">parallelSort</a></span>(byte[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按照数字顺序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i92">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-char:A-">parallelSort</a></span>(char[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i93">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-char:A-int-int-">parallelSort</a></span>(char[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按照数字顺序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i94">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-double:A-">parallelSort</a></span>(double[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i95">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-double:A-int-int-">parallelSort</a></span>(double[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按照数字顺序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i96">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-float:A-">parallelSort</a></span>(float[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i97">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-float:A-int-int-">parallelSort</a></span>(float[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按照数字顺序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i98">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-int:A-">parallelSort</a></span>(int[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i99">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-int:A-int-int-">parallelSort</a></span>(int[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按照数字顺序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i100">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-long:A-">parallelSort</a></span>(long[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i101">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-long:A-int-int-">parallelSort</a></span>(long[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按照数字顺序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i102">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-short:A-">parallelSort</a></span>(short[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i103">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-short:A-int-int-">parallelSort</a></span>(short[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按照数字顺序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i104">
<td class="colFirst"><code>static &lt;T extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt;<br/>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-T:A-">parallelSort</a></span>(T[] a)</code>
<div class="block">
<span>对指定对象升序排列的阵列，根据<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>的元素。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i105">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-T:A-java.util.Comparator-">parallelSort</a></span>(T[] a, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; cmp)</code>
<div class="block">
              根据指定的比较器引发的顺序对指定的对象数组进行排序。 
            </div> </td>
</tr>
<tr class="altColor" id="i106">
<td class="colFirst"><code>static &lt;T extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt;<br/>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-T:A-int-int-">parallelSort</a></span>(T[] a, int fromIndex, int toIndex)</code>
<div class="block">
<span>对指定对象升序排列的数组的指定范围内，根据<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>的元素。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i107">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#parallelSort-T:A-int-int-java.util.Comparator-">parallelSort</a></span>(T[] a, int fromIndex, int toIndex, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; cmp)</code>
<div class="block">
              根据指定的比较器引发的顺序对指定的对象数组的指定范围进行排序。 
            </div> </td>
</tr>
<tr class="altColor" id="i108">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#setAll-double:A-java.util.function.IntToDoubleFunction-">setAll</a></span>(double[] array, <a href="../../java/util/function/IntToDoubleFunction.html" title="interface in java.util.function">IntToDoubleFunction</a> generator)</code>
<div class="block">
              使用提供的生成函数来计算每个元素，设置指定数组的所有元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i109">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#setAll-int:A-java.util.function.IntUnaryOperator-">setAll</a></span>(int[] array, <a href="../../java/util/function/IntUnaryOperator.html" title="interface in java.util.function">IntUnaryOperator</a> generator)</code>
<div class="block">
              使用提供的生成函数来计算每个元素，设置指定数组的所有元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i110">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#setAll-long:A-java.util.function.IntToLongFunction-">setAll</a></span>(long[] array, <a href="../../java/util/function/IntToLongFunction.html" title="interface in java.util.function">IntToLongFunction</a> generator)</code>
<div class="block">
              使用提供的生成函数来计算每个元素，设置指定数组的所有元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i111">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#setAll-T:A-java.util.function.IntFunction-">setAll</a></span>(T[] array, <a href="../../java/util/function/IntFunction.html" title="interface in java.util.function">IntFunction</a>&lt;? extends T&gt; generator)</code>
<div class="block">
              使用提供的生成函数来计算每个元素，设置指定数组的所有元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i112">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-byte:A-">sort</a></span>(byte[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i113">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-byte:A-int-int-">sort</a></span>(byte[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按升序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i114">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-char:A-">sort</a></span>(char[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i115">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-char:A-int-int-">sort</a></span>(char[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按升序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i116">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-double:A-">sort</a></span>(double[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i117">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-double:A-int-int-">sort</a></span>(double[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按升序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i118">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-float:A-">sort</a></span>(float[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i119">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-float:A-int-int-">sort</a></span>(float[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按升序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i120">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-int:A-">sort</a></span>(int[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i121">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-int:A-int-int-">sort</a></span>(int[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按升序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i122">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-long:A-">sort</a></span>(long[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i123">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-long:A-int-int-">sort</a></span>(long[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按升序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i124">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-java.lang.Object:A-">sort</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</code>
<div class="block">
<span>对指定对象升序排列的阵列，根据<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>的元素。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i125">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-java.lang.Object:A-int-int-">sort</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a, int fromIndex, int toIndex)</code>
<div class="block">
<span>对指定对象升序排列的数组的指定范围内，根据<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>的元素。</span>
</div> </td>
</tr>
<tr class="altColor" id="i126">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-short:A-">sort</a></span>(short[] a)</code>
<div class="block">
              按照数字顺序排列指定的数组。 
            </div> </td>
</tr>
<tr class="rowColor" id="i127">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-short:A-int-int-">sort</a></span>(short[] a, int fromIndex, int toIndex)</code>
<div class="block">
              按升序排列数组的指定范围。 
            </div> </td>
</tr>
<tr class="altColor" id="i128">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-T:A-java.util.Comparator-">sort</a></span>(T[] a, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</code>
<div class="block">
              根据指定的比较器引发的顺序对指定的对象数组进行排序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i129">
<td class="colFirst"><code>static &lt;T&gt; void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#sort-T:A-int-int-java.util.Comparator-">sort</a></span>(T[] a, int fromIndex, int toIndex, <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</code>
<div class="block">
              根据指定的比较器引发的顺序对指定的对象数组的指定范围进行排序。 
            </div> </td>
</tr>
<tr class="altColor" id="i130">
<td class="colFirst"><code>static <a href="../../java/util/Spliterator.OfDouble.html" title="interface in java.util">Spliterator.OfDouble</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-double:A-">spliterator</a></span>(double[] array)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfDouble.html" title="java.util中的接口"><code>Spliterator.OfDouble</code></a>覆盖所有指定数组。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i131">
<td class="colFirst"><code>static <a href="../../java/util/Spliterator.OfDouble.html" title="interface in java.util">Spliterator.OfDouble</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-double:A-int-int-">spliterator</a></span>(double[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfDouble.html" title="java.util中的接口"><code>Spliterator.OfDouble</code></a>覆盖指定数组的指定范围内。</span>
</div> </td>
</tr>
<tr class="altColor" id="i132">
<td class="colFirst"><code>static <a href="../../java/util/Spliterator.OfInt.html" title="interface in java.util">Spliterator.OfInt</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-int:A-">spliterator</a></span>(int[] array)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfInt.html" title="java.util中的接口"><code>Spliterator.OfInt</code></a>覆盖所有指定数组。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i133">
<td class="colFirst"><code>static <a href="../../java/util/Spliterator.OfInt.html" title="interface in java.util">Spliterator.OfInt</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-int:A-int-int-">spliterator</a></span>(int[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfInt.html" title="java.util中的接口"><code>Spliterator.OfInt</code></a>覆盖指定数组的指定范围内。</span>
</div> </td>
</tr>
<tr class="altColor" id="i134">
<td class="colFirst"><code>static <a href="../../java/util/Spliterator.OfLong.html" title="interface in java.util">Spliterator.OfLong</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-long:A-">spliterator</a></span>(long[] array)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfLong.html" title="java.util中的接口"><code>Spliterator.OfLong</code></a>覆盖所有指定数组。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i135">
<td class="colFirst"><code>static <a href="../../java/util/Spliterator.OfLong.html" title="interface in java.util">Spliterator.OfLong</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-long:A-int-int-">spliterator</a></span>(long[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfLong.html" title="java.util中的接口"><code>Spliterator.OfLong</code></a>覆盖指定数组的指定范围内。</span>
</div> </td>
</tr>
<tr class="altColor" id="i136">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-T:A-">spliterator</a></span>(T[] array)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.html" title="java.util中的接口"><code>Spliterator</code></a>覆盖所有指定数组。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i137">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#spliterator-T:A-int-int-">spliterator</a></span>(T[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.html" title="java.util中的接口"><code>Spliterator</code></a>覆盖指定数组的指定范围内。</span>
</div> </td>
</tr>
<tr class="altColor" id="i138">
<td class="colFirst"><code>static <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-double:A-">stream</a></span>(double[] array)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/DoubleStream.html" title="java.util.stream中的接口"><code>DoubleStream</code></a>与指定的数组作为源。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i139">
<td class="colFirst"><code>static <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-double:A-int-int-">stream</a></span>(double[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/DoubleStream.html" title="java.util.stream中的接口"><code>DoubleStream</code></a>与指定的数组作为源的指定范围。</span>
</div> </td>
</tr>
<tr class="altColor" id="i140">
<td class="colFirst"><code>static <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-int:A-">stream</a></span>(int[] array)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/IntStream.html" title="java.util.stream中的接口"><code>IntStream</code></a>与指定的数组作为源。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i141">
<td class="colFirst"><code>static <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-int:A-int-int-">stream</a></span>(int[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/IntStream.html" title="java.util.stream中的接口"><code>IntStream</code></a>与指定的数组作为源的指定范围。</span>
</div> </td>
</tr>
<tr class="altColor" id="i142">
<td class="colFirst"><code>static <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-long:A-">stream</a></span>(long[] array)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/LongStream.html" title="java.util.stream中的接口"><code>LongStream</code></a>与指定的数组作为源。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i143">
<td class="colFirst"><code>static <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-long:A-int-int-">stream</a></span>(long[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/LongStream.html" title="java.util.stream中的接口"><code>LongStream</code></a>与指定的数组作为源的指定范围。</span>
</div> </td>
</tr>
<tr class="altColor" id="i144">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-T:A-">stream</a></span>(T[] array)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/Stream.html" title="java.util.stream中的接口"><code>Stream</code></a>与指定的数组作为源。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i145">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#stream-T:A-int-int-">stream</a></span>(T[] array, int startInclusive, int endExclusive)</code>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/Stream.html" title="java.util.stream中的接口"><code>Stream</code></a>与指定的数组作为源的指定范围。</span>
</div> </td>
</tr>
<tr class="altColor" id="i146">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-boolean:A-">toString</a></span>(boolean[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i147">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-byte:A-">toString</a></span>(byte[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="altColor" id="i148">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-char:A-">toString</a></span>(char[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i149">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-double:A-">toString</a></span>(double[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="altColor" id="i150">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-float:A-">toString</a></span>(float[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i151">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-int:A-">toString</a></span>(int[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="altColor" id="i152">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-long:A-">toString</a></span>(long[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i153">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-java.lang.Object:A-">toString</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
<tr class="altColor" id="i154">
<td class="colFirst"><code>static <a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Arrays.html#toString-short:A-">toString</a></span>(short[] a)</code>
<div class="block">
              返回指定数组的内容的字符串表示形式。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="sort-int:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(int[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
</dl> </li>
</ul> <a name="sort-int:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(int[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>按升序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="sort-long:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(long[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
</dl> </li>
</ul> <a name="sort-long:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(long[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>按升序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果是 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="sort-short:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(short[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
</dl> </li>
</ul> <a name="sort-short:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(short[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>按升序排列数组的指定范围。</span>
<span>要排序的范围从索引延伸<code>fromIndex</code> ，包容，到索引<code>toIndex</code> ，排斥。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的阵列 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果是 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="sort-char:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(char[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
</dl> </li>
</ul> <a name="sort-char:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(char[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>按升序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果是 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="sort-byte:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(byte[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
</dl> </li>
</ul> <a name="sort-byte:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(byte[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>按升序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="sort-float:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(float[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span><code>&lt;</code>关系不提供所有浮动值的总订单： <code>-0.0f == 0.0f</code>是<code>true</code> ，而<code>Float.NaN</code>值比较不小于，大于或等于任何值，甚至本身。</span> <span>该方法使用方法<a href="../../java/lang/Float.html#compareTo-java.lang.Float-"><code>Float.compareTo(java.lang.Float)</code></a> ： <code>-0.0f</code>处理为小于值<code>0.0f</code>和<code>Float.NaN</code>的总顺序被认为大于任何其他值，并且所有<code>Float.NaN</code>值被视为相等。</span> </p>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
</dl> </li>
</ul> <a name="sort-float:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(float[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>按升序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span>所述<code>&lt;</code>关系不能在所有浮点值提供一个总次序： <code>-0.0f == 0.0f</code>是<code>true</code>和<code>Float.NaN</code>值进行比较既不小于，大于，也不等于任何值，甚至本身。</span> <span>该方法使用方法<a href="../../java/lang/Float.html#compareTo-java.lang.Float-"><code>Float.compareTo(java.lang.Float)</code></a> ： <code>-0.0f</code>处理的总订单被视为小于值<code>0.0f</code>和<code>Float.NaN</code>被认为大于任何其他值，并且所有<code>Float.NaN</code>值被认为是相等的。</span> </p>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="sort-double:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(double[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span>所述<code>&lt;</code>关系不能在所有的双精度值提供一个总次序： <code>-0.0d == 0.0d</code>是<code>true</code>和<code>Double.NaN</code>值进行比较既不小于，大于，也不等于任何值，甚至本身。</span> <span>该方法使用方法<a href="../../java/lang/Double.html#compareTo-java.lang.Double-"><code>Double.compareTo(java.lang.Double)</code></a> ： <code>-0.0d</code>处理的总顺序被视为小于值<code>0.0d</code>和<code>Double.NaN</code>被认为大于任何其他值，并且所有<code>Double.NaN</code>值被认为是相等的。</span> </p>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
</dl> </li>
</ul> <a name="sort-double:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(double[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>按升序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围为空。</span>
<p> <span><code>&lt;</code>关系不能提供所有双重值的总订单： <code>-0.0d == 0.0d</code>为<code>true</code> ，而<code>Double.NaN</code>值既不小于，大于也不等于任何值，甚至本身。</span> <span>此方法使用方法<a href="../../java/lang/Double.html#compareTo-java.lang.Double-"><code>Double.compareTo(java.lang.Double)</code></a> ： <code>-0.0d</code>处理的总订单被视为小于值<code>0.0d</code>和<code>Double.NaN</code>认为大于任何其他值，并且所有<code>Double.NaN</code>值被视为相等。</span> </p>
<p> <span>实施注意事项：排序算法是由Vladimir Yaroslavskiy，Jon Bentley和Joshua Bloch提供的双轴快速排序。</span> <span>该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，并且通常比传统（单轴）Quicksort实现更快。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要排序的最后一个元素的索引，排他 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="parallelSort-byte:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(byte[] a)</pre>
<div class="block">
            按照数字顺序排列指定的数组。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-byte:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-byte:A-"><code>Arrays.sort</code></a>方法排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-byte:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(byte[] a,
                                int fromIndex,
                                int toIndex)</pre>
<div class="block">
<span>按照数字顺序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-byte:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-byte:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-char:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(char[] a)</pre>
<div class="block">
            按照数字顺序排列指定的数组。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-char:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-char:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-char:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(char[] a,
                                int fromIndex,
                                int toIndex)</pre>
<div class="block">
<span>按照数字顺序排列数组的指定范围。</span>
<span>要排序的范围从索引延伸<code>fromIndex</code> ，包容，到索引<code>toIndex</code> ，排斥。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-char:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-char:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果是 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-short:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(short[] a)</pre>
<div class="block">
            按照数字顺序排列指定的数组。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-short:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-short:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-short:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(short[] a,
                                int fromIndex,
                                int toIndex)</pre>
<div class="block">
<span>按照数字顺序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code>扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-short:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-short:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-int:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(int[] a)</pre>
<div class="block">
            按照数字顺序排列指定的数组。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-int:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-int:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-int:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(int[] a,
                                int fromIndex,
                                int toIndex)</pre>
<div class="block">
<span>按照数字顺序排列数组的指定范围。</span>
<span>要排序的范围从索引延伸<code>fromIndex</code> ，包容，到索引<code>toIndex</code> ，排斥。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围为空。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-int:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-int:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-long:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(long[] a)</pre>
<div class="block">
            按照数字顺序排列指定的数组。 
          </div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-long:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-long:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-long:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(long[] a,
                                int fromIndex,
                                int toIndex)</pre>
<div class="block">
<span>按照数字顺序排列数组的指定范围。</span>
<span>要排序的范围从索引延伸<code>fromIndex</code> ，包容，到索引<code>toIndex</code> ，排斥。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-long:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-long:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果是 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-float:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(float[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span><code>&lt;</code>关系不提供所有浮动值的总订单： <code>-0.0f == 0.0f</code>是<code>true</code> ，而<code>Float.NaN</code>值比较不小于，大于，也不等于任何值，甚至本身。</span> <span>此方法使用方法<a href="../../java/lang/Float.html#compareTo-java.lang.Float-"><code>Float.compareTo(java.lang.Float)</code></a>施加的总顺序： <code>-0.0f</code>被视为小于值<code>0.0f</code>和<code>Float.NaN</code>被认为大于任何其他值，并且所有<code>Float.NaN</code>值被认为是相等的。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-float:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-float:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-float:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(float[] a,
                                int fromIndex,
                                int toIndex)</pre>
<div class="block">
<span>按照数字顺序排列数组的指定范围。</span>
<span>要排序的范围从索引延伸<code>fromIndex</code> ，包容，到索引<code>toIndex</code> ，排斥。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span>所述<code>&lt;</code>关系不能在所有浮点值提供一个总次序： <code>-0.0f == 0.0f</code>是<code>true</code>和<code>Float.NaN</code>值进行比较既不小于，大于，也不等于任何值，甚至本身。</span> <span>该方法使用<a href="../../java/lang/Float.html#compareTo-java.lang.Float-"><code>Float.compareTo(java.lang.Float)</code></a> ： <a href="../../java/lang/Float.html#compareTo-java.lang.Float-"><code>Float.compareTo(java.lang.Float)</code></a> ： <code>-0.0f</code>处理为小于值<code>0.0f</code>和<code>Float.NaN</code>的总顺序被认为大于任何其他值，并且所有<code>Float.NaN</code>值都被视为相等。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-float:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-float:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（ 
            <code>fromIndex</code> ）的索引 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-double:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(double[] a)</pre>
<div class="block">
<span>按照数字顺序排列指定的数组。</span>
<p> <span>所述<code>&lt;</code>关系不能在所有的双精度值提供一个总次序： <code>-0.0d == 0.0d</code>是<code>true</code>和<code>Double.NaN</code>值进行比较既不小于，大于，也不等于任何值，甚至本身。</span> <span>该方法使用方法<a href="../../java/lang/Double.html#compareTo-java.lang.Double-"><code>Double.compareTo(java.lang.Double)</code></a> ： <code>-0.0d</code>处理的总顺序被视为小于值<code>0.0d</code> ，并且<code>Double.NaN</code>被认为大于任何其他值，并且所有<code>Double.NaN</code>值被认为相等。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-double:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-double:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-double:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static void parallelSort(double[] a,
                                int fromIndex,
                                int toIndex)</pre>
<div class="block">
<span>按照数字顺序排列数组的指定范围。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>如果<code>fromIndex == toIndex</code> ，要排序的范围是空的。</span>
<p> <span><code>&lt;</code>关系不会提供所有双重值的总订单： <code>-0.0d == 0.0d</code>为<code>true</code> ，而<code>Double.NaN</code>值既不小于，大于也不等于任何值，甚至本身。</span> <span>该方法使用方法<a href="../../java/lang/Double.html#compareTo-java.lang.Double-"><code>Double.compareTo(java.lang.Double)</code></a> ： <code>-0.0d</code>处理的总顺序被视为小于值<code>0.0d</code> ，并且<code>Double.NaN</code>被认为大于任何其他值，并且所有<code>Double.NaN</code>值被认为是相等的。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-double:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-double:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个要排序的元素的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-java.lang.Comparable:A-">
<!-- --> </a><a name="parallelSort-T:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static &lt;T extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt; void parallelSort(T[] a)</pre>
<div class="block">
<span>对指定对象升序排列的阵列，根据<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>的元素。</span>
<span>数组中的所有元素必须实现<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>接口。</span>
<span>此外，数组中的所有元素都必须<i>相互可比较</i> （即， <code>e1.compareTo(e2)</code>不能为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要排序的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含不 
            <i>相互比较的元素</i> （例如，字符串和整数） 
           </dd>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - （可选）如果发现数组元素的自然排序违反了<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>合同</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-java.lang.Comparable:A-int-int-">
<!-- --> </a><a name="parallelSort-T:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static &lt;T extends <a href="../../java/lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;? super T&gt;&gt; void parallelSort(T[] a,
                                                                  int fromIndex,
                                                                  int toIndex)</pre>
<div class="block">
<span>对指定对象升序排列的数组的指定范围内，根据<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>的元素。</span>
<span>要排序的范围从索引<code>fromIndex</code>扩展到索引<code>toIndex</code> ，排他。</span>
<span>（如果<code>fromIndex==toIndex</code> ，要排序的范围为空。）此范围中的所有元素必须实现<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>接口。</span>
<span>此外，该范围内的所有元素必须<i>相互可比较</i> （即， <code>e1.compareTo(e2)</code>不得为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要排序的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要排序的最后一个元素（排他）的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果<code>fromIndex &gt; toIndex</code>或（可选）如果发现数组元素的自然排序违反了<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>合同</span>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含不 
            <i>相互比较的元素</i> （例如，字符串和整数）。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-java.lang.Object:A-java.util.Comparator-">
<!-- --> </a><a name="parallelSort-T:A-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static &lt;T&gt; void parallelSort(T[] a,
                                    <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; cmp)</pre>
<div class="block">
<span>根据指定的比较器引发的顺序对指定的对象数组进行排序。</span>
<span>数组中的所有元素必须通过指定的比较器<i>相互比较</i> （即<code>c.compare(e1, e2)</code>不能为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要一个不大于原始数组大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要排序的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<span><code>cmp</code> - 比较器来确定数组的顺序。</span>
<span>A <code>null</code>值表示应使用元素' <a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> '。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含使用指定的比较器不 
            <i>相互比较</i>的元素 
           </dd>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - （可选）如果比较方发现违反<a href="../../java/util/Comparator.html" title="java.util中的接口"><code>Comparator</code></a>合同</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSort-java.lang.Object:A-int-int-java.util.Comparator-">
<!-- --> </a><a name="parallelSort-T:A-int-int-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSort</h4> <pre>public static &lt;T&gt; void parallelSort(T[] a,
                                    int fromIndex,
                                    int toIndex,
                                    <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; cmp)</pre>
<div class="block">
<span>根据指定的比较器引发的顺序对指定的对象数组的指定范围进行排序。</span>
<span>要排序的范围从索引<code>fromIndex</code>扩展到索引<code>toIndex</code> ，排他。</span>
<span>（如果<code>fromIndex==toIndex</code> ，则排序范围为空。）范围内的所有元素都必须是指定比较<i>相互比较的</i> （即， <code>c.compare(e1, e2)</code>不得抛出<code>ClassCastException</code>任何元件<code>e1</code>和<code>e2</code>中的范围内）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
<span>排序算法是一个并行排序合并，将数组分解为子数组，这些子数组本身被排序然后合并。</span>
<span>当子阵列长度达到最小粒度时，使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法对子阵列进行排序。</span>
<span>如果指定数组的长度小于最小粒度，则使用适当的<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a>方法进行排序。</span>
<span>该算法需要不大于原始数组的指定范围的大小的工作空间。</span>
<span><a href="../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoin common pool</code></a>用于执行任何并行任务。</span>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要排序的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要排序的最后一个元素（排他）的索引 
           </dd>
<dd>
<span><code>cmp</code> - 比较器来确定数组的顺序。</span>
<span>A <code>null</code>值表示应使用元素' <a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> '。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果<code>fromIndex &gt; toIndex</code>或（可选）如果发现数组元素的自然排序违反了<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>合同</span>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含不 
            <i>相互比较的元素</i> （例如，字符串和整数）。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="sort-java.lang.Object:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</pre>
<div class="block">
<span>根据其元素的<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> ，按照升序排列指定的对象数组。</span>
<span>阵列中的所有元素必须实现<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>接口。</span>
<span>此外，数组中的所有元素必须<i>相互可比较</i> （即， <code>e1.compareTo(e2)</code>不能为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
<p> <span>实现注意事项：这个实现是一个稳定的，自适应的，迭代的mergeesort，当输入数组被部分排序时，需要比n lg（n）的比较少得多，同时在输入数组被随机排列时提供传统的mergeesort的性能。</span> <span>如果输入数组几乎被排序，则实现需要大致n个比较。</span> <span>临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n / 2对象引用。</span> </p>
<p> <span>该实现在其输入数组中具有上升和下降的同等优势，并且可以在同一输入数组的不同部分中利用升序和降序。</span> <span>它非常适合合并两个或多个排序的数组：简单地连接数组并排序生成的数组。</span> </p>
<p> <span>该实现根据Tim Peters的Python列表（ <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a> ）进行了<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">改编</a> 。</span> <span>它使用Peter McIlroy的“乐观排序和信息理论复杂性”中的技术，在第四届ACM-SIAM离散算法研讨会论文集，pp 467-474，1993年1月。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含不 
            <i>相互比较的元素</i> （例如，字符串和整数） 
           </dd>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - （可选）如果发现数组元素的自然排序违反了<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>合同</span>
</dd>
</dl> </li>
</ul> <a name="sort-java.lang.Object:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static void sort(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a,
                        int fromIndex,
                        int toIndex)</pre>
<div class="block">
<span>对指定对象升序排列的数组的指定范围内，根据<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>的元素。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>（如果<code>fromIndex==toIndex</code> ，要排序的范围为空。）此范围中的所有元素必须实现<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>接口。</span>
<span>此外，该范围内的所有元素必须<i>相互可比较</i> （即， <code>e1.compareTo(e2)</code>不能为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
<p> <span>实现注意事项：这个实现是一个稳定的，自适应的，迭代的mergeesort，当输入数组被部分排序时，需要比n lg（n）的比较少得多，同时在输入数组被随机排列时提供传统的mergeesort的性能。</span> <span>如果输入数组几乎被排序，则实现需要大致n个比较。</span> <span>临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n / 2对象引用。</span> </p>
<p> <span>该实现在其输入数组中具有上升和下降的同等优势，并且可以在同一输入数组的不同部分中利用升序和降序。</span> <span>它非常适合合并两个或多个排序的数组：简单地连接数组并排序生成的数组。</span> </p>
<p> <span>实施从Tim Peters的Python列表（ <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a> ）进行了<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">改编</a> 。</span> <span>它使用Peter McIlroy的“乐观排序和信息理论复杂性”中的技术，在第四届ACM-SIAM离散算法研讨会论文集，pp 467-474，1993年1月。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要排序的最后一个元素（排他）的索引 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果<code>fromIndex &gt; toIndex</code>或（可选）如果发现数组元素的自然排序违反了<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>合同</span>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含不 
            <i>相互比较的元素</i> （例如，字符串和整数）。 
           </dd>
</dl> </li>
</ul> <a name="sort-java.lang.Object:A-java.util.Comparator-">
<!-- --> </a><a name="sort-T:A-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static &lt;T&gt; void sort(T[] a,
                            <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</pre>
<div class="block">
<span>根据指定的比较器引发的顺序对指定的对象数组进行排序。</span>
<span>数组中的所有元素必须通过指定的比较器<i>相互比较</i> （即<code>c.compare(e1, e2)</code>不能为<code>ClassCastException</code>中的任何元素<code>e1</code>和<code>e2</code> ）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
<p> <span>实现注意事项：这个实现是一个稳定的，自适应的，迭代的mergeesort，当输入数组被部分排序时，需要比n lg（n）的比较少得多，同时在输入数组被随机排列时提供传统的mergeesort的性能。</span> <span>如果输入数组几乎被排序，则实现需要大致n个比较。</span> <span>临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n / 2对象引用。</span> </p>
<p> <span>该实现在其输入数组中具有上升和下降的同等优势，并且可以在同一输入数组的不同部分中利用升序和降序。</span> <span>它非常适合合并两个或多个排序的数组：简单地连接数组并排序生成的数组。</span> </p>
<p> <span>该实现是从Tim Peters的Python列表（ <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a> ）中进行的。</span> <span>它使用Peter McIlroy的“乐观排序和信息理论复杂性”中的技术，在第四届ACM-SIAM离散算法研讨会论文集，pp 467-474，1993年1月。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要排序的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<span><code>c</code> - 比较器确定阵列的顺序。</span>
<span>A <code>null</code>值表示应使用元素' <a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> '。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含使用指定比较器不 
            <i>相互比较</i>的元素 
           </dd>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - （可选）如果比较方发现违反<a href="../../java/util/Comparator.html" title="java.util中的接口"><code>Comparator</code></a>合同</span>
</dd>
</dl> </li>
</ul> <a name="sort-java.lang.Object:A-int-int-java.util.Comparator-">
<!-- --> </a><a name="sort-T:A-int-int-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>sort</h4> <pre>public static &lt;T&gt; void sort(T[] a,
                            int fromIndex,
                            int toIndex,
                            <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</pre>
<div class="block">
<span>根据指定的比较器引发的顺序对指定的对象数组的指定范围进行排序。</span>
<span>要排序的范围从索引<code>fromIndex</code> （包括）扩展到索引<code>toIndex</code> ，排他。</span>
<span>（如果<code>fromIndex==toIndex</code> ，则排序范围为空。）范围内的所有元素都必须是指定比较<i>相互比较的</i> （即， <code>c.compare(e1, e2)</code>不得抛出<code>ClassCastException</code>任何元件<code>e1</code>和<code>e2</code>中的范围内）。</span>
<p> <span>这种保证是<i>稳定的</i> ：等同的元素将不会被排序作为排序的结果。</span> </p>
<p> <span>实现注意事项：这个实现是一个稳定的，自适应的，迭代的mergeesort，当输入数组被部分排序时，需要比n lg（n）的比较少得多，同时在输入数组被随机排列时提供传统的mergeesort的性能。</span> <span>如果输入数组几乎被排序，则实现需要大致n个比较。</span> <span>临时存储要求从几乎排序的输入数组的小常数到随机排序的输入数组的n / 2对象引用。</span> </p>
<p> <span>该实现在其输入数组中具有上升和下降的同等优势，并且可以在同一输入数组的不同部分中利用升序和降序。</span> <span>它非常适合合并两个或多个排序的数组：简单地连接数组并排序生成的数组。</span> </p>
<p> <span>该实现根据Tim Peters的Python列表（ <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a> ）进行了<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">改编</a> 。</span> <span>它使用Peter McIlroy的“乐观排序和信息理论复杂性”中的技术，在第四届ACM-SIAM离散算法研讨会论文集，pp 467-474，1993年1月。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 要排序的对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要排序的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要排序的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要排序的最后一个元素（排他）的索引 
           </dd>
<dd>
<span><code>c</code> - 比较器来确定数组的顺序。</span>
<span>A <code>null</code>值表示应使用元素' <a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> '。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含使用指定的比较器不 
            <i>相互比较</i>的元素。 
           </dd>
<dd>
<span><code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果<code>fromIndex &gt; toIndex</code>或（可选）如果比较方发现违反<a href="../../java/util/Comparator.html" title="java.util中的接口"><code>Comparator</code></a>合同</span>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; a.length</code>
</dd>
</dl> </li>
</ul> <a name="parallelPrefix-java.lang.Object:A-java.util.function.BinaryOperator-">
<!-- --> </a><a name="parallelPrefix-T:A-java.util.function.BinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static &lt;T&gt; void parallelPrefix(T[] array,
                                      <a href="../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</pre>
<div class="block">
<span>使用提供的功能，并行地计算给定阵列的每个元素。</span>
<span>例如，如果数组最初保持<code>[2, 1, 0, 3]</code>并且操作执行添加，则返回时，数组将保持<code>[2, 3, 3, 6]</code> 。</span>
<span>并行前缀计算通常比大数组的顺序循环更有效。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 通过此方法就地修改的数组 
           </dd>
<dd>
<code>op</code> - 一种无副作用的关联函数来执行累积 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelPrefix-java.lang.Object:A-int-int-java.util.function.BinaryOperator-">
<!-- --> </a><a name="parallelPrefix-T:A-int-int-java.util.function.BinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static &lt;T&gt; void parallelPrefix(T[] array,
                                      int fromIndex,
                                      int toIndex,
                                      <a href="../../java/util/function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt; op)</pre>
<div class="block">
            对于数组的给定子范围执行 
           <a href="../../java/util/Arrays.html#parallelPrefix-T:A-java.util.function.BinaryOperator-"><code>parallelPrefix(Object[], BinaryOperator)</code></a> 。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 数组 
           </dd>
<dd>
<code>fromIndex</code> - 第一个元素的索引（含） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个元素的索引，独占 
           </dd>
<dd>
<code>op</code> - 执行累积的无副作用的关联函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; array.length</code>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelPrefix-long:A-java.util.function.LongBinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static void parallelPrefix(long[] array,
                                  <a href="../../java/util/function/LongBinaryOperator.html" title="interface in java.util.function">LongBinaryOperator</a> op)</pre>
<div class="block">
<span>使用提供的功能，并行地计算给定阵列的每个元素。</span>
<span>例如，如果阵列最初保持<code>[2, 1, 0, 3]</code>并且操作执行添加，则返回时，数组将保持<code>[2, 3, 3, 6]</code> 。</span>
<span>并行前缀计算通常比大数组的顺序循环更有效。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 通过此方法被原位修改的数组 
           </dd>
<dd>
<code>op</code> - 一种无副作用的关联函数来执行累积 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelPrefix-long:A-int-int-java.util.function.LongBinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static void parallelPrefix(long[] array,
                                  int fromIndex,
                                  int toIndex,
                                  <a href="../../java/util/function/LongBinaryOperator.html" title="interface in java.util.function">LongBinaryOperator</a> op)</pre>
<div class="block">
            对于数组的给定子范围执行 
           <a href="../../java/util/Arrays.html#parallelPrefix-long:A-java.util.function.LongBinaryOperator-"><code>parallelPrefix(long[], LongBinaryOperator)</code></a> 。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 数组 
           </dd>
<dd>
<code>fromIndex</code> - 第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个元素的索引，独占 
           </dd>
<dd>
<code>op</code> - 一种无副作用的关联函数来执行累积 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; array.length</code>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelPrefix-double:A-java.util.function.DoubleBinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static void parallelPrefix(double[] array,
                                  <a href="../../java/util/function/DoubleBinaryOperator.html" title="interface in java.util.function">DoubleBinaryOperator</a> op)</pre>
<div class="block">
<span>使用提供的功能，并行地计算给定阵列的每个元素。</span>
<span>例如，如果数组最初保持<code>[2.0, 1.0, 0.0, 3.0]</code>并且操作执行添加，则返回时，数组保持<code>[2.0, 3.0, 3.0, 6.0]</code> 。</span>
<span>并行前缀计算通常比大数组的顺序循环更有效。</span>
<p> <span>因为浮点运算可能不是严格关联的，所以返回的结果可能不一致，如果顺序执行操作将获得的值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 通过此方法就地修改的数组 
           </dd>
<dd>
<code>op</code> - 执行累积的无副作用的功能 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelPrefix-double:A-int-int-java.util.function.DoubleBinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static void parallelPrefix(double[] array,
                                  int fromIndex,
                                  int toIndex,
                                  <a href="../../java/util/function/DoubleBinaryOperator.html" title="interface in java.util.function">DoubleBinaryOperator</a> op)</pre>
<div class="block">
            对于数组的给定子范围执行 
           <a href="../../java/util/Arrays.html#parallelPrefix-double:A-java.util.function.DoubleBinaryOperator-"><code>parallelPrefix(double[], DoubleBinaryOperator)</code></a> 。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 数组 
           </dd>
<dd>
<code>fromIndex</code> - 第一个元素的索引（含） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个元素的索引，独占 
           </dd>
<dd>
<code>op</code> - 一种无副作用的关联函数来执行累积 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; array.length</code>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelPrefix-int:A-java.util.function.IntBinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static void parallelPrefix(int[] array,
                                  <a href="../../java/util/function/IntBinaryOperator.html" title="interface in java.util.function">IntBinaryOperator</a> op)</pre>
<div class="block">
<span>使用提供的功能，并行地计算给定阵列的每个元素。</span>
<span>例如，如果阵列最初保持<code>[2, 1, 0, 3]</code>并且操作执行添加，则返回时，数组将保持<code>[2, 3, 3, 6]</code> 。</span>
<span>并行前缀计算通常比大数组的顺序循环更有效。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 通过此方法就地修改的数组 
           </dd>
<dd>
<code>op</code> - 执行累积的无副作用的关联函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelPrefix-int:A-int-int-java.util.function.IntBinaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelPrefix</h4> <pre>public static void parallelPrefix(int[] array,
                                  int fromIndex,
                                  int toIndex,
                                  <a href="../../java/util/function/IntBinaryOperator.html" title="interface in java.util.function">IntBinaryOperator</a> op)</pre>
<div class="block">
            对于数组的给定子范围执行 
           <a href="../../java/util/Arrays.html#parallelPrefix-int:A-java.util.function.IntBinaryOperator-"><code>parallelPrefix(int[], IntBinaryOperator)</code></a> 。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 数组 
           </dd>
<dd>
<code>fromIndex</code> - 第一个元素的索引（包括） 
           </dd>
<dd>
<code>toIndex</code> - 最后一个元素的索引，独占 
           </dd>
<dd>
<code>op</code> - 一种无副作用的关联函数来执行累积 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0</code>或 
            <code>toIndex &gt; array.length</code>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的数组或函数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-long:A-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(long[] a,
                               long key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定数组的指定数组。</span>
<span>在进行此调用之前，数组必须按照<a href="../../java/util/Arrays.html#sort-long:A-"><code>sort(long[])</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-long:A-int-int-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(long[] a,
                               int fromIndex,
                               int toIndex,
                               long key)</pre>
<div class="block">
<span>使用二分搜索算法搜索指定值的指定数组的范围。</span>
<span>在进行此呼叫之前，范围必须按照<a href="../../java/util/Arrays.html#sort-long:A-int-int-"><code>sort(long[], int, int)</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-int:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(int[] a,
                               int key)</pre>
<div class="block">
<span>使用二叉搜索算法搜索指定的int数组的指定值。</span>
<span>在进行此调用之前，必须对数组进行排序（如<a href="../../java/util/Arrays.html#sort-int:A-"><code>sort(int[])</code></a>方法）。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-int:A-int-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(int[] a,
                               int fromIndex,
                               int toIndex,
                               int key)</pre>
<div class="block">
<span>使用二叉搜索算法搜索指定值的指定数组的范围。</span>
<span>在进行此呼叫之前，范围必须按照<a href="../../java/util/Arrays.html#sort-int:A-int-int-"><code>sort(int[], int, int)</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-short:A-short-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(short[] a,
                               short key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定值的指定数组的指定值。</span>
<span>在进行此调用之前，必须对数组进行排序（按照<a href="../../java/util/Arrays.html#sort-short:A-"><code>sort(short[])</code></a>方法）。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-short:A-int-int-short-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(short[] a,
                               int fromIndex,
                               int toIndex,
                               short key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定值的指定数组的短整型范围。</span>
<span>在进行此调用之前，范围必须按照<a href="../../java/util/Arrays.html#sort-short:A-int-int-"><code>sort(short[], int, int)</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-char:A-char-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(char[] a,
                               char key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定数组的指定值。</span>
<span>在进行此调用之前，必须对数组进行排序（如<a href="../../java/util/Arrays.html#sort-char:A-"><code>sort(char[])</code></a>方法）。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-char:A-int-int-char-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(char[] a,
                               int fromIndex,
                               int toIndex,
                               char key)</pre>
<div class="block">
<span>使用二分搜索算法搜索指定值的指定数组的范围。</span>
<span>在进行此呼叫之前，范围必须按照<a href="../../java/util/Arrays.html#sort-char:A-int-int-"><code>sort(char[], int, int)</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-byte:A-byte-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(byte[] a,
                               byte key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定值的指定字节数组。</span>
<span>在进行此调用之前，数组必须按照<a href="../../java/util/Arrays.html#sort-byte:A-"><code>sort(byte[])</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-byte:A-int-int-byte-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(byte[] a,
                               int fromIndex,
                               int toIndex,
                               byte key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定值的指定字节数组的范围。</span>
<span>在进行此呼叫之前，范围必须按照<a href="../../java/util/Arrays.html#sort-byte:A-int-int-"><code>sort(byte[], int, int)</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-double:A-double-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(double[] a,
                               double key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定值的指定数组的双精度值。</span>
<span>在进行此调用之前，必须对数组进行排序（按照<a href="../../java/util/Arrays.html#sort-double:A-"><code>sort(double[])</code></a>方法）。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
<span>该方法认为所有的NaN值都是相等的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-double:A-int-int-double-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(double[] a,
                               int fromIndex,
                               int toIndex,
                               double key)</pre>
<div class="block">
<span>使用二分搜索算法搜索指定值的指定数组的双精度范围。</span>
<span>在进行此呼叫之前，范围必须按照<a href="../../java/util/Arrays.html#sort-double:A-int-int-"><code>sort(double[], int, int)</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
<span>该方法认为所有的NaN值都是相等的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-float:A-float-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(float[] a,
                               float key)</pre>
<div class="block">
<span>使用二叉搜索算法搜索指定数组的浮点数。</span>
<span>在进行此调用之前，数组必须按照<a href="../../java/util/Arrays.html#sort-float:A-"><code>sort(float[])</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
<span>该方法认为所有的NaN值都是相等的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
</dl> </li>
</ul> <a name="binarySearch-float:A-int-int-float-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(float[] a,
                               int fromIndex,
                               int toIndex,
                               float key)</pre>
<div class="block">
<span>使用二分搜索算法搜索指定数组的浮点数范围。</span>
<span>在进行此呼叫之前，范围必须按照<a href="../../java/util/Arrays.html#sort-float:A-int-int-"><code>sort(float[], int, int)</code></a>方法进行排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含具有指定值的多个元素，则不能保证将找到哪个元素。</span>
<span>该方法认为所有的NaN值都是相等的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-java.lang.Object:A-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a,
                               <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> key)</pre>
<div class="block">
<span>使用二叉搜索算法搜索指定对象的指定数组。</span>
<span>所述阵列必须根据被按升序排列<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>元素（如由<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-"><code>sort(Object[])</code></a>方法）之前使该呼叫。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>（如果数组包含不相互比较的元素（例如字符串和整数），则<i>不能</i>根据其元素的自然排序进行排序，因此结果未定义。）如果数组包含等于指定对象的多个元素，不能保证会找到哪一个。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果搜索关键字与数组的元素无法比较。 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-java.lang.Object:A-int-int-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static int binarySearch(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a,
                               int fromIndex,
                               int toIndex,
                               <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> key)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定对象的指定数组的范围。</span>
<span>的范围必须根据被按升序排列<a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a>元素（如由<a href="../../java/util/Arrays.html#sort-java.lang.Object:A-int-int-"><code>sort(Object[], int, int)</code></a>方法）之前使该呼叫。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>（如果范围包含不相互比较的元素（例如字符串和整数），则<i>不能</i>根据其元素的自然排序进行排序，因此结果未定义。）如果范围包含等于指定对象的多个元素，不能保证会找到哪一个。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果搜索关键字与指定范围内的数组的元素不可比较。 
           </dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-java.lang.Object:A-java.lang.Object-java.util.Comparator-">
<!-- --> </a><a name="binarySearch-T:A-T-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static &lt;T&gt; int binarySearch(T[] a,
                                   T key,
                                   <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</pre>
<div class="block">
<span>使用二叉搜索算法搜索指定对象的指定数组。</span>
<span>在进行此调用之前，数组必须按照指定的比较器（如<a href="../../java/util/Arrays.html#sort-T:A-java.util.Comparator-"><code>sort(T[], Comparator)</code></a>方法）按升序排列。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果数组包含与指定对象相等的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dd>
<span><code>c</code> - 排列数组的比较器。</span>
<span>A <tt>null</tt>值表示应使用元素' <a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> '。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果阵列中的所有元素都小于指定键的第一元件比所述键时，或<tt>a.length</tt>的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果数组包含使用指定的比较器不 
            <i>相互比较</i>的元素，或者搜索关键字与使用该比较器的数组的元素不可比较。 
           </dd>
</dl> </li>
</ul> <a name="binarySearch-java.lang.Object:A-int-int-java.lang.Object-java.util.Comparator-">
<!-- --> </a><a name="binarySearch-T:A-int-int-T-java.util.Comparator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>binarySearch</h4> <pre>public static &lt;T&gt; int binarySearch(T[] a,
                                   int fromIndex,
                                   int toIndex,
                                   T key,
                                   <a href="../../java/util/Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt; c)</pre>
<div class="block">
<span>使用二进制搜索算法搜索指定对象的指定数组的范围。</span>
<span>在进行此呼叫之前，范围必须根据指定的比较器（如<a href="../../java/util/Arrays.html#sort-T:A-int-int-java.util.Comparator-"><code>sort(T[], int, int, Comparator)</code></a>方法）按升序排序。</span>
<span>如果没有排序，结果是未定义的。</span>
<span>如果范围包含等于指定对象的多个元素，则不能保证将找到哪个元素。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要搜索的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要搜索的第一个元素（含）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要搜索的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>key</code> - 要搜索的值 
           </dd>
<dd>
<span><code>c</code> - 排列数组的比较器。</span>
<span>A <tt>null</tt>值表示应使用元素' <a href="../../java/lang/Comparable.html" title="java.lang中的接口">natural ordering</a> '。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>搜索键的索引，如果它包含在指定范围内的数组中;</span>
<span>否则， <tt>(-(<i>insertion point</i>) - 1)</tt> 。</span>
<span>如果在范围内的所有元素都小于指定的键在比所述键时，或<tt>toIndex</tt>的范围中的第一个元素的索引： <i>插入点</i>被定义为将键插入到阵列的点。</span>
<span>请注意，这确保当且仅当找到该键时返回值将为&gt; = 0。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果范围包含使用指定的比较器不 
            <i>相互比较</i>的元素，或者搜索键与使用该比较器的范围内的元素不可比。 
           </dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>fromIndex &gt; toIndex</code>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="equals-long:A-long:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(long[] a,
                             long[] a2)</pre>
<div class="block">
<span>如果两个指定的longs数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则它们被<tt>认为</tt>是<tt>相等的</tt> 。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的其他数组的相等性 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
</dl> </li>
</ul> <a name="equals-int:A-int:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(int[] a,
                             int[] a2)</pre>
<div class="block">
<span>如果两个指定的int数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则它们被<tt>认为</tt>是<tt>相等的</tt> 。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的其他数组是否相等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
</dl> </li>
</ul> <a name="equals-short:A-short:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(short[] a,
                             short[] a2)</pre>
<div class="block">
<span>如果两个指定的短数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则两个数组引用被认为是<tt>相等的</tt> 。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的其他数组是否相等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
</dl> </li>
</ul> <a name="equals-char:A-char:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(char[] a,
                             char[] a2)</pre>
<div class="block">
<span>如果两个指定的字符数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则它们被<tt>认为</tt>是<tt>相等的</tt> 。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要进行相等测试的另一个数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
</dl> </li>
</ul> <a name="equals-byte:A-byte:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(byte[] a,
                             byte[] a2)</pre>
<div class="block">
<span>如果两个指定的字节数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则它们被<tt>认为</tt>是<tt>相等的</tt> 。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要进行相等测试的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的其他数组是否相等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
</dl> </li>
</ul> <a name="equals-boolean:A-boolean:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(boolean[] a,
                             boolean[] a2)</pre>
<div class="block">
<span>如果两个指定的布尔数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两者都是<tt>null</tt> ，则两个数组引用被认为是<tt>相等的</tt> 。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的其他数组是否相等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
</dl> </li>
</ul> <a name="equals-double:A-double:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(double[] a,
                             double[] a2)</pre>
<div class="block">
<span>如果两个指定的双精度数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则两个数组引用被认为是<tt>相等的</tt> 。</span>
<p> <span>如果以下情况，两个双打<tt>d1</tt>和<tt>d2</tt>被认为是相等的</span> </p>
<pre>  <span><tt>new Double(d1).equals(new Double(d2))</tt></span> </pre>
<span>（与<tt>==</tt>运算符不同，该方法认为<tt>NaN</tt>等于自身，0.0d不等于-0.0d））</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的另一个数组是否相等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Double.html#equals-java.lang.Object-"><code>Double.equals(Object)</code></a>
</dd>
</dl> </li>
</ul> <a name="equals-float:A-float:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(float[] a,
                             float[] a2)</pre>
<div class="block">
<span>如果两个指定的浮动数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则它们被<tt>认为</tt>是<tt>相等的</tt> 。</span>
<p> <span>如下所示，两个浮标<tt>f1</tt>和<tt>f2</tt>被认为是相等的：</span> </p>
<pre>  <span><tt>new Float(f1).equals(new Float(f2))</tt></span> </pre>
<span>（与<tt>==</tt>运算符不同，此方法认为<tt>NaN</tt>等于自身，0.0f不等于-0.0f））</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的其他数组是否相等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Float.html#equals-java.lang.Object-"><code>Float.equals(Object)</code></a>
</dd>
</dl> </li>
</ul> <a name="equals-java.lang.Object:A-java.lang.Object:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>equals</h4> <pre>public static boolean equals(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a,
                             <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a2)</pre>
<div class="block">
<span>如果两个指定的对象数组彼此<i>相等</i> ，则返回<tt>true</tt> 。</span>
<span>如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。</span>
<span>如果<tt>(e1==null ? e2==null : e1.equals(e2))，</tt>两个对象<tt>e1</tt>和<tt>e2</tt>被认为是<i>相等的</i> 。</span>
<span>换句话说，如果两个数组在相同的顺序中包含相同的元素，则它们是相等的。</span>
<span>另外，如果两个数组引用都是null，则两个数组引用被认为是<tt>相等的</tt> 。</span>
<p></p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要进行相等测试的另一个数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
</dl> </li>
</ul> <a name="fill-long:A-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(long[] a,
                        long val)</pre>
<div class="block">
            将指定的long值分配给指定的longs数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-long:A-int-int-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(long[] a,
                        int fromIndex,
                        int toIndex,
                        long val)</pre>
<div class="block">
<span>将指定的long值分配给指定的longs数组的指定范围的每个元素。</span>
<span>要填充的范围从索引<tt>fromIndex</tt> （包括）扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果是 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-int:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(int[] a,
                        int val)</pre>
<div class="block">
            将指定的int值分配给指定的int数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-int:A-int-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(int[] a,
                        int fromIndex,
                        int toIndex,
                        int val)</pre>
<div class="block">
<span>将指定的int值分配给指定的int数组的指定范围的每个元素。</span>
<span>要填充的范围从索引<tt>fromIndex</tt>扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排除）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-short:A-short-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(short[] a,
                        short val)</pre>
<div class="block">
            将指定的短值分配给指定的短裤数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-short:A-int-int-short-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(short[] a,
                        int fromIndex,
                        int toIndex,
                        short val)</pre>
<div class="block">
<span>将指定的短值分配给指定的短裤数组的指定范围的每个元素。</span>
<span>要填充的范围从索引<tt>fromIndex</tt> （包括）扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果是<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排除）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-char:A-char-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(char[] a,
                        char val)</pre>
<div class="block">
            将指定的char值分配给指定的char数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-char:A-int-int-char-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(char[] a,
                        int fromIndex,
                        int toIndex,
                        char val)</pre>
<div class="block">
<span>将指定的char值分配给指定的char数组的指定范围的每个元素。</span>
<span>要填补的范围从索引<tt>fromIndex</tt> （包括）扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-byte:A-byte-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(byte[] a,
                        byte val)</pre>
<div class="block">
            将指定的字节值分配给指定字节数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-byte:A-int-int-byte-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(byte[] a,
                        int fromIndex,
                        int toIndex,
                        byte val)</pre>
<div class="block">
<span>将指定的字节值分配给指定字节数组的指定范围的每个元素。</span>
<span>待填写的范围从索引<tt>fromIndex</tt> （包括）扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排除）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-boolean:A-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(boolean[] a,
                        boolean val)</pre>
<div class="block">
            将指定的布尔值分配给指定的布尔数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-boolean:A-int-int-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(boolean[] a,
                        int fromIndex,
                        int toIndex,
                        boolean val)</pre>
<div class="block">
<span>将指定的布尔值分配给指定数组布尔值的指定范围的每个元素。</span>
<span>要填补的范围从索引<tt>fromIndex</tt> （包括）扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果是<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（含）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排他）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-double:A-double-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(double[] a,
                        double val)</pre>
<div class="block">
            将指定的double值分配给指定的双精度数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-double:A-int-int-double-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(double[] a,
                        int fromIndex,
                        int toIndex,
                        double val)</pre>
<div class="block">
<span>将指定的double值分配给指定的双精度数组范围的每个元素。</span>
<span>要填充的范围从索引<tt>fromIndex</tt> （包括）扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排除）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-float:A-float-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(float[] a,
                        float val)</pre>
<div class="block">
            将指定的float值分配给指定的浮点数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
</dl> </li>
</ul> <a name="fill-float:A-int-int-float-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(float[] a,
                        int fromIndex,
                        int toIndex,
                        float val)</pre>
<div class="block">
<span>将指定的浮点值分配给指定的浮点数组的指定范围的每个元素。</span>
<span>要填充的范围从索引<tt>fromIndex</tt>扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果是<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排除）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
</dl> </li>
</ul> <a name="fill-java.lang.Object:A-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a,
                        <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> val)</pre>
<div class="block">
            将指定的对象引用分配给指定的对象数组的每个元素。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayStoreException.html" title="class in java.lang">ArrayStoreException</a></code> - 如果指定的值不是可以存储在指定数组中的运行时类型 
           </dd>
</dl> </li>
</ul> <a name="fill-java.lang.Object:A-int-int-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>fill</h4> <pre>public static void fill(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a,
                        int fromIndex,
                        int toIndex,
                        <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> val)</pre>
<div class="block">
<span>将指定的对象引用分配给指定的对象数组的指定范围的每个元素。</span>
<span>要填充的范围从索引<tt>fromIndex</tt> （包括）扩展到索引<tt>toIndex</tt> ，排他。</span>
<span>（如果<tt>fromIndex==toIndex</tt> ，要填充的范围是空的。）</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要填充的数组 
           </dd>
<dd>
<code>fromIndex</code> - 要用指定值填充的第一个元素（包括）的索引 
           </dd>
<dd>
<code>toIndex</code> - 要用指定值填充的最后一个元素（排除）的索引 
           </dd>
<dd>
<code>val</code> - 要存储在数组的所有元素中的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>fromIndex &gt; toIndex</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <tt>fromIndex &lt; 0</tt>或 
            <tt>toIndex &gt; a.length</tt>
</dd>
<dd>
<code><a href="../../java/lang/ArrayStoreException.html" title="class in java.lang">ArrayStoreException</a></code> - 如果指定的值不是可以存储在指定数组中的运行时类型 
           </dd>
</dl> </li>
</ul> <a name="copyOf-java.lang.Object:A-int-">
<!-- --> </a><a name="copyOf-T:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static &lt;T&gt; T[] copyOf(T[] original,
                             int newLength)</pre>
<div class="block">
<span>复制指定的数组，用空值截断或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>null</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
<span>结果数组与原始数组完全相同的类。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，截断或填充空值以获取指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-java.lang.Object:A-int-java.lang.Class-">
<!-- --> </a><a name="copyOf-U:A-int-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static &lt;T,U&gt; T[] copyOf(U[] original,
                               int newLength,
                               <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends T[]&gt; newType)</pre>
<div class="block">
<span>复制指定的数组，用空值截断或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>null</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
<span>最终的数组是<tt>newType</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>U</code> - 原始数组中对象的类 
           </dd>
<dd>
<code>T</code> - 返回数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dd>
<code>newType</code> - 要返回的副本的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，截断或填充空值以获取指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dd>
<code><a href="../../java/lang/ArrayStoreException.html" title="class in java.lang">ArrayStoreException</a></code> - 如果从 
            <tt>original</tt>复制的元素不是可以存储在类别 
            <tt>newType</tt>的数组中的运行时类型 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-byte:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static byte[] copyOf(byte[] original,
                            int newLength)</pre>
<div class="block">
<span>复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>(byte)0</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，被截断或用零填充以获得指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-short:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static short[] copyOf(short[] original,
                             int newLength)</pre>
<div class="block">
<span>复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>(short)0</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，被截断或用零填充以获得指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-int:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static int[] copyOf(int[] original,
                           int newLength)</pre>
<div class="block">
<span>复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>0</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，被截断或用零填充以获得指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-long:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static long[] copyOf(long[] original,
                            int newLength)</pre>
<div class="block">
<span>复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>0L</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，被截断或用零填充以获得指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-char:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static char[] copyOf(char[] original,
                            int newLength)</pre>
<div class="block">
<span>复制指定的数组，截断或填充空字符（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>'\\u000'</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，截断或填充空字符以获取指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>是否定的 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-float:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static float[] copyOf(float[] original,
                             int newLength)</pre>
<div class="block">
<span>复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>0f</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，被截断或用零填充以获得指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-double:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static double[] copyOf(double[] original,
                              int newLength)</pre>
<div class="block">
<span>复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>0d</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，被截断或用零填充以获得指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOf-boolean:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOf</h4> <pre>public static boolean[] copyOf(boolean[] original,
                               int newLength)</pre>
<div class="block">
<span>复制指定的数组，截断或填充<tt>false</tt> （如有必要），以使副本具有指定的长度。</span>
<span>对于原始数组和副本都有效的所有索引，两个数组将包含相同的值。</span>
<span>对于在副本中而不是原件有效的任何索引，副本将包含<tt>false</tt> 。</span>
<span>当且仅当指定长度大于原始数组的长度时，这些索引才会存在。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要复制的数组 
           </dd>
<dd>
<code>newLength</code> - 要返回的副本的长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             原始数组的副本，被截断或填充有假元素以获得指定的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NegativeArraySizeException.html" title="class in java.lang">NegativeArraySizeException</a></code> - 如果 
            <tt>newLength</tt>为负数 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-java.lang.Object:A-int-int-">
<!-- --> </a><a name="copyOfRange-T:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static &lt;T&gt; T[] copyOfRange(T[] original,
                                  int from,
                                  int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>必须大于或等于<tt>from</tt>的范围（ <tt>to</tt> ）的最终指数可能大于<tt>original.length</tt> ，在这种情况下， <tt>null</tt>被放置在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
<p> <span>结果数组与原始数组完全相同的类。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用空值截断或填充以获取所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-java.lang.Object:A-int-int-java.lang.Class-">
<!-- --> </a><a name="copyOfRange-U:A-int-int-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static &lt;T,U&gt; T[] copyOfRange(U[] original,
                                    int from,
                                    int to,
                                    <a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends T[]&gt; newType)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>必须大于或等于<tt>from</tt>的范围（ <tt>to</tt> ）的最终指数可能大于<tt>original.length</tt> ，在这种情况下， <tt>null</tt>被放置在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
<span>结果的数组是<tt>newType</tt>类。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>U</code> - 原始数组中对象的类 
           </dd>
<dd>
<code>T</code> - 返回数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dd>
<code>newType</code> - 要返回的副本的类 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用空值截断或填充以获取所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dd>
<code><a href="../../java/lang/ArrayStoreException.html" title="class in java.lang">ArrayStoreException</a></code> - 如果从 
            <tt>original</tt>复制的元素不是可以存储在类别 
            <tt>newType</tt>的数组中的运行时类型。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-byte:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static byte[] copyOfRange(byte[] original,
                                 int from,
                                 int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>必须大于或等于<tt>from</tt>的范围（ <tt>to</tt> ）的最终指数可能大于<tt>original.length</tt> ，在这种情况下<tt>(byte)0</tt>被放置在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用零截取或填充以获得所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-short:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static short[] copyOfRange(short[] original,
                                  int from,
                                  int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>范围（ <tt>to</tt> ）的最终索引（ <tt>to</tt> ）必须大于或等于<tt>from</tt> ，可能大于<tt>original.length</tt> ，在这种情况下， <tt>(short)0</tt>放在索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用零截取或填充以获得所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-int:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static int[] copyOfRange(int[] original,
                                int from,
                                int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>必须大于或等于<tt>from</tt>的范围（ <tt>to</tt> ）的最终指数可能大于<tt>original.length</tt> ，在这种情况下<tt>0</tt>被放置在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用零截取或填充以获得所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-long:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static long[] copyOfRange(long[] original,
                                 int from,
                                 int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>范围（ <tt>to</tt> ）的最终索引（ <tt>to</tt> ）必须大于或等于<tt>from</tt> ，可能大于<tt>original.length</tt> ，在这种情况下， <tt>0L</tt>被放置在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用零截取或填充以获得所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-char:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static char[] copyOfRange(char[] original,
                                 int from,
                                 int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非是<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>范围（ <tt>to</tt> ）的最终指数（ <tt>to</tt> ）必须大于或等于<tt>from</tt> ，可能大于<tt>original.length</tt> ，在这种情况下， <tt>'\\u000'</tt>放在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，被截断或填充有空字符以获取所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-float:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static float[] copyOfRange(float[] original,
                                  int from,
                                  int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>范围（ <tt>to</tt> ）的最终指数（ <tt>to</tt> ）必须大于或等于<tt>from</tt> ，可能大于<tt>original.length</tt> ，在这种情况下， <tt>0f</tt>放在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用零截取或填充以获得所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-double:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static double[] copyOfRange(double[] original,
                                   int from,
                                   int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非是<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>必须大于或等于<tt>from</tt>的范围（ <tt>to</tt> ）的最终索引可能大于<tt>original.length</tt> ，在这种情况下， <tt>0d</tt>被放置在其索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，用零截取或填充以获得所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="copyOfRange-boolean:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>copyOfRange</h4> <pre>public static boolean[] copyOfRange(boolean[] original,
                                    int from,
                                    int to)</pre>
<div class="block">
<span>将指定数组的指定范围复制到新数组中。</span>
<span>范围（ <tt>from</tt> ）的初始指数必须在零和<tt>original.length</tt>之间，包括在内。</span>
<span><tt>original[from]</tt>的值被放置在副本的初始元素中（除非<tt>from == original.length</tt>或<tt>from == to</tt> ）。</span>
<span>原始数组中后续元素的值将被放置在副本中的后续元素中。</span>
<span>范围（ <tt>to</tt> ）的最终指数（ <tt>to</tt> ）必须大于或等于<tt>from</tt> ，可能大于<tt>original.length</tt> ，在这种情况下， <tt>false</tt>被放置在索引大于或等于<tt>original.length - from</tt>的副本的所有元素中。</span>
<span>返回的数组的长度将为<tt>to - from</tt> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>original</code> - 要从中复制范围的数组 
           </dd>
<dd>
<code>from</code> - 要复制的范围的初始索引（包括） 
           </dd>
<dd>
<span><code>to</code> - 要复制的范围的最终索引，排他。</span>
<span>（该索引可能位于数组之外）</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个包含原始数组的指定范围的新数组，被截断或填充了假元素以获得所需的长度 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>from &lt; 0</code>或 
            <code>from &gt; original.length</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <tt>from &gt; to</tt>
</dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <tt>original</tt>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="asList-java.lang.Object:A-">
<!-- --> </a><a name="asList-T...-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asList</h4> <pre><a href="../../java/lang/SafeVarargs.html" title="annotation in java.lang">@SafeVarargs</a>
public static &lt;T&gt; <a href="../../java/util/List.html" title="interface in java.util">List</a>&lt;T&gt; asList(T... a)</pre>
<div class="block">
<span>返回由指定数组支持的固定大小的列表。</span>
<span>（将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与<code>Collection.toArray()</code>相<a href="../../java/util/Collection.html#toArray--">结合</a> 。</span>
<span>返回的列表是可序列化的，并实现<a href="../../java/util/RandomAccess.html" title="java.util中的接口"><code>RandomAccess</code></a> 。</span>
<p> <span>此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表：</span> </p>
<pre>  <span>List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly");</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组中对象的类 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 列表将被支持的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             指定数组的列表视图 
           </dd>
</dl> </li>
</ul> <a name="hashCode-long:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(long[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个<tt>long</tt>阵列<tt>a</tt>和<tt>b</tt>这样<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>通过此方法返回的值是将通过调用能够得到相同的值<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>上的方法<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>含有序列<a href="../../java/lang/Long.html" title="java.lang中的类"><code>Long</code>个</a>实例表示的<tt>a</tt>以相同顺序的元素。</span> <span>如果<tt>a</tt>是<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的散列码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-int:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(int[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个非空的<tt>int</tt>阵列<tt>a</tt>和<tt>b</tt>等<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>通过此方法返回的值是将通过调用能够得到相同的值<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>上的方法<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>含有序列<a href="../../java/lang/Integer.html" title="java.lang中的类"><code>Integer</code>个</a>实例表示的<tt>a</tt>以相同顺序的元素。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的散列码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-short:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(short[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个<tt>short</tt>阵列<tt>a</tt>和<tt>b</tt>这样的<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>通过此方法返回的值是将通过调用能够得到相同的值<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>上的方法<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>含有序列<a href="../../java/lang/Short.html" title="java.lang中的类"><code>Short</code>个</a>实例表示的<tt>a</tt>以相同顺序的元素。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的哈希码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-char:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(char[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个<tt>char</tt>阵列<tt>a</tt>和<tt>b</tt>等<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>通过此方法返回的值是将通过调用能够得到相同的值<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>上的方法<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>含有序列<a href="../../java/lang/Character.html" title="java.lang中的类"><code>Character</code>个</a>实例表示的<tt>a</tt>以相同顺序的元素。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的哈希码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-byte:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(byte[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个<tt>byte</tt>阵列<tt>a</tt>和<tt>b</tt>等<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>通过此方法返回的值是将通过调用能够得到相同的值<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>上的方法<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>含有序列<a href="../../java/lang/Byte.html" title="java.lang中的类"><code>Byte</code>个</a>实例表示的<tt>a</tt>以相同顺序的元素。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的哈希码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-boolean:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(boolean[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个<tt>boolean</tt>阵列<tt>a</tt>和<tt>b</tt>这样<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>此方法返回的值与通过在同一顺序中<a href="../../java/lang/Boolean.html" title="java.lang中的类">包含</a> <code>Boolean</code>表达a元素的<tt>88446024714736的</tt>一个<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>调用<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>方法获得的值相同。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的散列码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-float:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(float[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个<tt>float</tt>阵列<tt>a</tt>和<tt>b</tt>等<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>通过此方法返回的值是将通过调用能够得到相同的值<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>上的方法<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>含有序列<a href="../../java/lang/Float.html" title="java.lang中的类"><code>Float</code>个</a>实例表示的<tt>a</tt>以相同顺序的元素。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的散列码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-double:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(double[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>对于任何两个<tt>double</tt> <tt>a</tt>阵列和<tt>b，</tt>使得<tt>Arrays.equals(a, b)，</tt>它也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span>
<p> <span>通过此方法返回的值是将通过调用能够得到相同的值<a href="../../java/util/List.html#hashCode--"><code><tt>hashCode</tt></code></a>上的方法<a href="../../java/util/List.html" title="java.util中的接口"><code>List</code></a>含有序列<a href="../../java/lang/Double.html" title="java.lang中的类"><code>Double</code>个</a>实例表示的<tt>a</tt>以相同顺序的元素。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的哈希值的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的哈希码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="hashCode-java.lang.Object:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hashCode</h4> <pre>public static int hashCode(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</pre>
<div class="block">
<span>根据指定数组的内容返回哈希码。</span>
<span>如果数组包含其他数组作为元素，则哈希码基于它们的身份而不是其内容。</span>
<span>因此，可以直接或间接通过一个或多个数组级别将数组本身作为元素调用此方法。</span>
<p> <span>对于任何两个阵列<tt>a</tt>和<tt>b</tt>等<tt>Arrays.equals(a, b)</tt> ，也是<tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>的情况。</span> </p>
<p> <span>通过此方法返回的值等于将由<tt>Arrays.asList(a).hashCode()</tt>被返回，除非<tt>a</tt> <tt>null</tt>是，在这种情况下是<tt>0</tt>返回的值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要计算的基于内容的哈希码的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于内容的散列码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Arrays.html#deepHashCode-java.lang.Object:A-"><code>deepHashCode(Object[])</code></a>
</dd>
</dl> </li>
</ul> <a name="deepHashCode-java.lang.Object:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>deepHashCode</h4> <pre>public static int deepHashCode(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</pre>
<div class="block">
<span>根据指定数组的“深度内容”返回哈希码。</span>
<span>如果数组包含其他数组作为元素，那么哈希码就是基于它们的内容，等等，无穷无尽。</span>
<span>因此，通过一个或多个级别的数组直接或间接地将自身作为元素的数组调用此方法是不可接受的。</span>
<span>这种调用的行为是未定义的。</span>
<p> <span>对于任何两个阵列<tt>a</tt>和<tt>b</tt>等<tt>Arrays.deepEquals(a, b)</tt> ，也是<tt>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</tt>的情况。</span> </p>
<p> <span>通过此方法返回的值的计算是类似于由返回的值的<a href="../../java/util/List.html#hashCode--"><code>List.hashCode()</code></a>包含相同的元素如<tt>a</tt>以相同的顺序在列表上，有一点不同：如果一个元素的<tt>a</tt> <tt>e</tt>本身是一个阵列，其散列代码不是通过调用<tt>e.hashCode()</tt>计算的，而是通过调用Arrays.hashCode(e)的<tt>适当重载（</tt>如果<tt>e</tt>是原始类型的数组），或者通过<tt>递归</tt>调用Arrays.deepHashCode(e)，如果<tt>e</tt>是引用类型的数组。</span> <span>如果<tt>a</tt>为<tt>null</tt> ，则此方法返回0。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 其基于深度内容的哈希码计算的阵列 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个基于深度内容的哈希码为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Arrays.html#hashCode-java.lang.Object:A-"><code>hashCode(Object[])</code></a>
</dd>
</dl> </li>
</ul> <a name="deepEquals-java.lang.Object:A-java.lang.Object:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>deepEquals</h4> <pre>public static boolean deepEquals(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a1,
                                 <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a2)</pre>
<div class="block">
<span>如果两个指定的数组彼此<i>深度相等</i> ，则返回<tt>true</tt> 。</span>
<span>与<a href="../../java/util/Arrays.html#equals-java.lang.Object:A-java.lang.Object:A-"><code>equals(Object[],Object[])</code></a>方法不同，该方法适用于任意深度的嵌套数组。</span>
<p> <span>如果两者都是<tt>null</tt> ，或者如果它们是指包含相同数量的元素的数组，并且两个数组中所有对应的元素对都相等，则两个数组引用被认为是相当相等的。</span> </p>
<p> <span>如果以下任一条件<tt>成立</tt> ，两个可能的<tt>null</tt>元素<tt>e1</tt>和<tt>e2</tt>都是相当的：</span> </p>
<ul>
<li> <span><tt>e1</tt>和<tt>e2</tt>都是对象引用类型的数组，而<tt>Arrays.deepEquals(e1, e2) would return true</tt></span> </li>
<li> <span><tt>e1</tt>和<tt>e2</tt>是相同基元类型的数组，Arrays.equals(e1, e2)的<tt>适当重载</tt>将返回true。</span> </li>
<li> <span><tt>e1 == e2</tt></span> </li>
<li> <span><tt>e1.equals(e2)</tt>将返回true。</span> </li>
</ul>
<span>请注意，此定义允许任何深度的<tt>null</tt>元素。</span>
<p> <span>如果任一指定的数组通过一个或多个数组级别直接或间接包含自身作为元素，则此方法的行为是未定义的。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a1</code> - 要测试相等的一个数组 
           </dd>
<dd>
<code>a2</code> - 要测试的其他数组是否相等 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<tt>true</tt>如果两个数组相等 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Arrays.html#equals-java.lang.Object:A-java.lang.Object:A-"><code>equals(Object[],Object[])</code></a> ， 
            <a href="../../java/util/Objects.html#deepEquals-java.lang.Object-java.lang.Object-"><code>Objects.deepEquals(Object, Object)</code></a>
</dd>
</dl> </li>
</ul> <a name="toString-long:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(long[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt> （逗号后跟一个空格）分隔开。</span>
<span>元素被转换为字符串由<tt>String.valueOf(long)。</tt></span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-int:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(int[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt>分隔（逗号后跟一个空格）。</span>
<span>元素被转换为字符串由<tt>String.valueOf(int)。</tt></span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回其字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-short:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(short[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt> （逗号后跟一个空格）分隔开。</span>
<span>元素被转换为字符串由<tt>String.valueOf(short)。</tt></span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示法 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-char:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(char[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt> （逗号后跟一个空格）分隔开。</span>
<span>元素将转换为字符串，如<tt>String.valueOf(char)</tt> 。</span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-byte:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(byte[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt>分隔（逗号后跟一个空格）。</span>
<span>元素被转换为字符串由<tt>String.valueOf(byte)。</tt></span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回其字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-boolean:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(boolean[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt>分隔（逗号后跟一个空格）。</span>
<span>元素将转换为字符串，如<tt>String.valueOf(boolean)</tt> 。</span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示形式为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-float:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(float[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt> （逗号后跟一个空格）分隔开。</span>
<span>元素被转换为字符串由<tt>String.valueOf(float)。</tt></span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示形式为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-double:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(double[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span>
<span>相邻的元素由字符<tt>", "</tt>分隔（逗号后跟一个空格）。</span>
<span>元素转换为字符串，如<tt>String.valueOf(double)</tt> 。</span>
<span>返回<tt>"null"</tt>如果<tt>a</tt>是<tt>null。</tt></span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="toString-java.lang.Object:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> toString(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</pre>
<div class="block">
<span>返回指定数组的内容的字符串表示形式。</span>
<span>如果数组包含其它数组作为元件，它们被转换为字符串<a href="../../java/lang/Object.html#toString--"><code>Object.toString()</code></a>从<tt>Object</tt>继承的方法，其描述了他们的<i>身份</i> ，而不是其内容。</span>
<p> <span>通过此方法返回的值等于将由<tt>Arrays.asList(a).toString()</tt>被返回，除非<tt>a</tt> <tt>null</tt>是，在这种情况下是<tt>"null"</tt>返回的值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示形式为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Arrays.html#deepToString-java.lang.Object:A-"><code>deepToString(Object[])</code></a>
</dd>
</dl> </li>
</ul> <a name="deepToString-java.lang.Object:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>deepToString</h4> <pre>public static <a href="../../java/lang/String.html" title="class in java.lang">String</a> deepToString(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a>[] a)</pre>
<div class="block">
<span>返回指定数组的“深度内容”的字符串表示形式。</span>
<span>如果数组包含其他数组作为元素，则字符串表示包含其内容等等。</span>
<span>此方法用于将多维数组转换为字符串。</span>
<p> <span>字符串表示由数组元素的列表组成，括在方括号（ <tt>"[]"</tt> ）中。</span> <span>相邻的元素由字符<tt>", "</tt> （逗号后跟一个空格）分隔开。</span> <span>元件由<tt>String.valueOf(Object)</tt>转换为字符串，除非它们本身阵列。</span> </p>
<p> <span>如果一个元素<tt>e</tt>是一个基本类型的阵列，它通过调用的<tt>Arrays.toString(e)</tt>适当重载转换为字符串作为。</span> <span>如果元素<tt>e</tt>是引用类型的数组，则通过递归调用此方法将其转换为字符串。</span> </p>
<p> <span>为了避免无限递归，如果指定的数组包含自身作为元素，或者通过一个或多个数组级别包含对其自身的间接引用，则将自引用转换为字符串<tt>"[...]"</tt> 。</span> <span>例如，仅包含对其自身的引用的数组将被呈现为<tt>"[[...]]"</tt> 。</span> </p>
<p> <span>如果指定数组是<tt>null</tt>此方法返回<tt>"null"。</tt></span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>a</code> - 要返回的字符串表示形式的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个字符串表示形式为 
            <tt>a</tt>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Arrays.html#toString-java.lang.Object:A-"><code>toString(Object[])</code></a>
</dd>
</dl> </li>
</ul> <a name="setAll-java.lang.Object:A-java.util.function.IntFunction-">
<!-- --> </a><a name="setAll-T:A-java.util.function.IntFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setAll</h4> <pre>public static &lt;T&gt; void setAll(T[] array,
                              <a href="../../java/util/function/IntFunction.html" title="interface in java.util.function">IntFunction</a>&lt;? extends T&gt; generator)</pre>
<div class="block">
<span>使用提供的生成函数来计算每个元素，设置指定数组的所有元素。</span>
<p> <span>如果生成器函数引发异常，则将其转发给调用者，并将数组置于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置所需值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSetAll-java.lang.Object:A-java.util.function.IntFunction-">
<!-- --> </a><a name="parallelSetAll-T:A-java.util.function.IntFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSetAll</h4> <pre>public static &lt;T&gt; void parallelSetAll(T[] array,
                                      <a href="../../java/util/function/IntFunction.html" title="interface in java.util.function">IntFunction</a>&lt;? extends T&gt; generator)</pre>
<div class="block">
<span>使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。</span>
<p> <span>如果发电机功能抛出异常，一个未经检查的异常是从抛出<code>parallelSetAll</code>和阵列保持处于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置所需值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="setAll-int:A-java.util.function.IntUnaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setAll</h4> <pre>public static void setAll(int[] array,
                          <a href="../../java/util/function/IntUnaryOperator.html" title="interface in java.util.function">IntUnaryOperator</a> generator)</pre>
<div class="block">
<span>使用提供的生成函数来计算每个元素，设置指定数组的所有元素。</span>
<p> <span>如果生成器函数引发异常，则将其转发给调用者，并将数组置于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置所需值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSetAll-int:A-java.util.function.IntUnaryOperator-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSetAll</h4> <pre>public static void parallelSetAll(int[] array,
                                  <a href="../../java/util/function/IntUnaryOperator.html" title="interface in java.util.function">IntUnaryOperator</a> generator)</pre>
<div class="block">
<span>使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。</span>
<p> <span>如果生成器函数引发异常，则会从<code>parallelSetAll</code>抛出未检查的异常，并将数组置于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置所需值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="setAll-long:A-java.util.function.IntToLongFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setAll</h4> <pre>public static void setAll(long[] array,
                          <a href="../../java/util/function/IntToLongFunction.html" title="interface in java.util.function">IntToLongFunction</a> generator)</pre>
<div class="block">
<span>使用提供的生成函数来计算每个元素，设置指定数组的所有元素。</span>
<p> <span>如果生成器函数引发异常，则将其转发给调用者，并将数组置于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置所需值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSetAll-long:A-java.util.function.IntToLongFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSetAll</h4> <pre>public static void parallelSetAll(long[] array,
                                  <a href="../../java/util/function/IntToLongFunction.html" title="interface in java.util.function">IntToLongFunction</a> generator)</pre>
<div class="block">
<span>使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。</span>
<p> <span>如果生成器函数引发异常，则会从<code>parallelSetAll</code>抛出未检查的异常，并将数组置于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置所需值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="setAll-double:A-java.util.function.IntToDoubleFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setAll</h4> <pre>public static void setAll(double[] array,
                          <a href="../../java/util/function/IntToDoubleFunction.html" title="interface in java.util.function">IntToDoubleFunction</a> generator)</pre>
<div class="block">
<span>使用提供的生成函数来计算每个元素，设置指定数组的所有元素。</span>
<p> <span>如果生成器函数引发异常，则将其转发给调用者，并将数组置于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置所需值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="parallelSetAll-double:A-java.util.function.IntToDoubleFunction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>parallelSetAll</h4> <pre>public static void parallelSetAll(double[] array,
                                  <a href="../../java/util/function/IntToDoubleFunction.html" title="interface in java.util.function">IntToDoubleFunction</a> generator)</pre>
<div class="block">
<span>使用提供的生成函数来并行设置指定数组的所有元素来计算每个元素。</span>
<p> <span>如果生成器函数引发异常，则会从<code>parallelSetAll</code>抛出未检查的异常，并且数组处于不确定状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 要初始化的数组 
           </dd>
<dd>
<code>generator</code> - 接受索引并产生该位置的期望值的函数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果生成器为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-java.lang.Object:A-">
<!-- --> </a><a name="spliterator-T:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;T&gt; spliterator(T[] array)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.html" title="java.util中的接口"><code>Spliterator</code></a>覆盖所有指定数组。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             数组元素的分割器 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-java.lang.Object:A-int-int-">
<!-- --> </a><a name="spliterator-T:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static &lt;T&gt; <a href="../../java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;T&gt; spliterator(T[] array,
                                             int startInclusive,
                                             int endExclusive)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.html" title="java.util中的接口"><code>Spliterator</code></a>覆盖指定数组的指定范围内。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引紧随上一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             数组元素的分割器 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于数组大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-int:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static <a href="../../java/util/Spliterator.OfInt.html" title="interface in java.util">Spliterator.OfInt</a> spliterator(int[] array)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfInt.html" title="java.util中的接口"><code>Spliterator.OfInt</code></a>覆盖所有指定数组。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用期间 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             数组元素的分割器 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-int:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static <a href="../../java/util/Spliterator.OfInt.html" title="interface in java.util">Spliterator.OfInt</a> spliterator(int[] array,
                                            int startInclusive,
                                            int endExclusive)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfInt.html" title="java.util中的接口"><code>Spliterator.OfInt</code></a>覆盖指定数组的指定范围内。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引立即通过最后一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             数组元素的分割器 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于数组大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-long:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static <a href="../../java/util/Spliterator.OfLong.html" title="interface in java.util">Spliterator.OfLong</a> spliterator(long[] array)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfLong.html" title="java.util中的接口"><code>Spliterator.OfLong</code></a>覆盖所有指定数组。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             阵列元素的拼接器 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-long:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static <a href="../../java/util/Spliterator.OfLong.html" title="interface in java.util">Spliterator.OfLong</a> spliterator(long[] array,
                                             int startInclusive,
                                             int endExclusive)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfLong.html" title="java.util中的接口"><code>Spliterator.OfLong</code></a>覆盖指定数组的指定范围内。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用期间 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引立即通过最后一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             数组元素的分割器 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于阵列大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-double:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static <a href="../../java/util/Spliterator.OfDouble.html" title="interface in java.util">Spliterator.OfDouble</a> spliterator(double[] array)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfDouble.html" title="java.util中的接口"><code>Spliterator.OfDouble</code></a>覆盖所有指定数组。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             数组元素的分割器 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="spliterator-double:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>spliterator</h4> <pre>public static <a href="../../java/util/Spliterator.OfDouble.html" title="interface in java.util">Spliterator.OfDouble</a> spliterator(double[] array,
                                               int startInclusive,
                                               int endExclusive)</pre>
<div class="block">
<span>返回<a href="../../java/util/Spliterator.OfDouble.html" title="java.util中的接口"><code>Spliterator.OfDouble</code></a>覆盖指定数组的指定范围内。</span>
<p> <span>该报告spliterator <a href="../../java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a> ， <a href="../../java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a> ， <a href="../../java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>和<a href="../../java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用期间 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引立即通过最后一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             数组元素的分割器 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于数组大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-java.lang.Object:A-">
<!-- --> </a><a name="stream-T:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stream</h4> <pre>public static &lt;T&gt; <a href="../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;T&gt; stream(T[] array)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/Stream.html" title="java.util.stream中的接口"><code>Stream</code></a>与指定的数组作为源。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Stream</code>的阵列 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-java.lang.Object:A-int-int-">
<!-- --> </a><a name="stream-T:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stream</h4> <pre>public static &lt;T&gt; <a href="../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;T&gt; stream(T[] array,
                                   int startInclusive,
                                   int endExclusive)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/Stream.html" title="java.util.stream中的接口"><code>Stream</code></a>与指定的数组作为源的指定范围。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 数组元素的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引立即通过最后一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>Stream</code>的数组范围 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于数组大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-int:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stream</h4> <pre>public static <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a> stream(int[] array)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/IntStream.html" title="java.util.stream中的接口"><code>IntStream</code></a>与指定的数组作为源。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>IntStream</code>的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-int:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stream</h4> <pre>public static <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a> stream(int[] array,
                               int startInclusive,
                               int endExclusive)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/IntStream.html" title="java.util.stream中的接口"><code>IntStream</code></a>与指定的数组作为源的指定范围。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用期间 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引立即通过最后一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>IntStream</code>的阵列范围 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于数组大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-long:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stream</h4> <pre>public static <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a> stream(long[] array)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/LongStream.html" title="java.util.stream中的接口"><code>LongStream</code></a>与指定的数组作为源。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用期间 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>LongStream</code>的阵列 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-long:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stream</h4> <pre>public static <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a> stream(long[] array,
                                int startInclusive,
                                int endExclusive)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/LongStream.html" title="java.util.stream中的接口"><code>LongStream</code></a>与指定的数组作为源的指定范围。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用期间 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引立即通过最后一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>LongStream</code>的数组范围 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于数组大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-double:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>stream</h4> <pre>public static <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a> stream(double[] array)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/DoubleStream.html" title="java.util.stream中的接口"><code>DoubleStream</code></a>与指定的数组作为源。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>DoubleStream</code>的数组 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="stream-double:A-int-int-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>stream</h4> <pre>public static <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a> stream(double[] array,
                                  int startInclusive,
                                  int endExclusive)</pre>
<div class="block">
<span>返回顺序<a href="../../java/util/stream/DoubleStream.html" title="java.util.stream中的接口"><code>DoubleStream</code></a>与指定的数组作为源的指定范围。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>array</code> - 假定在使用过程中 
            <code>array</code>的数组 
           </dd>
<dd>
<code>startInclusive</code> - 第一个涵盖的索引 
           </dd>
<dd>
<code>endExclusive</code> - 索引立即通过最后一个索引覆盖 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>DoubleStream</code>的阵列范围 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - 如果 
            <code>startInclusive</code>为负数，则 
            <code>endExclusive</code>小于 
            <code>startInclusive</code> ，或 
            <code>endExclusive</code>大于数组大小 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>