<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util 
   </div>
<h2 class="title" title="Class Random">Class Random</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.Random</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../java/io/Serializable.html" title="java.io中的接口">Serializable</a></span>
</dd>
</dl>
<dl>
<dt>
        已知直接子类：
       </dt>
<dd>
<span><a href="../../java/security/SecureRandom.html" title="java.security中的类">SecureRandom</a> ， <a href="../../java/util/concurrent/ThreadLocalRandom.html" title="java.util.concurrent中的类">ThreadLocalRandom</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">Random</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../java/io/Serializable.html" title="interface in java.io">Serializable</a></pre>
<div class="block">
<span>该类的实例用于生成伪随机数的流。</span>
<span>该类使用48位种子，其使用线性同余公式进行修改。</span>
<span>（见Donald Knuth， <i>“计算机编程艺术”，第2卷</i> ，第3.2.1节）</span>
<p> <span>如果使用相同的种子创建两个Random <code>Random</code> ，并且对每个实例进行相同的方法调用序列，则它们将生成并返回相同的数字序列。</span> <span>为了保证此属性，为Random类<code>Random</code> 。</span> <span>为了Java代码的绝对可移植性，Java实现必须使用这里所示的所有算法为<code>Random</code>类。</span> <span>然而，Random类的子类<code>Random</code>使用其他算法，只要它们遵守所有方法的一般合同。</span> </p>
<p> <span>Random类实现的<code>Random</code>使用<code>protected</code>实用程序方法，每次调用可以提供多达32个伪随机生成位。</span> </p>
<p> <span>许多应用程序会发现方法<a href="../../java/lang/Math.html#random--"><code>Math.random()</code></a>使用<a href="../../java/lang/Math.html#random--">起来</a>更简单。</span> </p>
<p> <span>java.util.Random的<code>java.util.Random</code>是线程安全的。</span> <span>但是，跨线程的同时使用<code>java.util.Random</code>实例可能会遇到争用，从而导致性能下降。</span> <span>在多线程设计中考虑使用<a href="../../java/util/concurrent/ThreadLocalRandom.html" title="java.util.concurrent中的类"><code>ThreadLocalRandom</code></a> 。</span> </p>
<p> <span>java.util.Random的<code>java.util.Random</code>不是加密安全的。</span> <span>考虑使用<a href="../../java/security/SecureRandom.html" title="java.security中的类"><code>SecureRandom</code></a>获取一个加密安全的伪随机数生成器，供安全敏感应用程序使用。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.0 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../serialized-form.html#java.util.Random">Serialized Form</a>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/util/Random.html#Random--">Random</a></span>()</code>
<div class="block">
              创建一个新的随机数生成器。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/util/Random.html#Random-long-">Random</a></span>(long seed)</code>
<div class="block">
              使用单个 
             <code>long</code>种子创建一个新的随机数生成器。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#doubles--">doubles</a></span>()</code>
<div class="block">
              返回一个有效的无限流的伪随机 
             <code>double</code>值，每个值在零（包括）和一（独占）之间。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#doubles-double-double-">doubles</a></span>(double randomNumberOrigin, double randomNumberBound)</code>
<div class="block">
              返回一个有效的无限流伪 
             <code>double</code>值 
             <code>double</code> ，每个值都符合给定的起始（包括）和绑定（排他）。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#doubles-long-">doubles</a></span>(long streamSize)</code>
<div class="block">
              返回一个流，产生给定的 
             <code>streamSize</code>伪 
             <code>double</code>数值 
             <code>double</code> ，每个值在零（包括）和一（独占）之间。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code><a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#doubles-long-double-double-">doubles</a></span>(long streamSize, double randomNumberOrigin, double randomNumberBound)</code>
<div class="block">
              返回一个流，产生给定的 
             <code>streamSize</code>伪 
             <code>double</code>数值 
             <code>double</code> ，每个值符合给定的起始（包括）和绑定（排他）。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#ints--">ints</a></span>()</code>
<div class="block">
              返回一个有效的无限流的伪 
             <code>int</code>值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#ints-int-int-">ints</a></span>(int randomNumberOrigin, int randomNumberBound)</code>
<div class="block">
              返回一个有效的无限流伪 
             <code>int</code>值 
             <code>int</code> ，每个值都符合给定的起始（包括）和绑定（排他）。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#ints-long-">ints</a></span>(long streamSize)</code>
<div class="block">
              返回一个流，产生给定的 
             <code>streamSize</code>数 
             <code>int</code>值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#ints-long-int-int-">ints</a></span>(long streamSize, int randomNumberOrigin, int randomNumberBound)</code>
<div class="block">
              返回一个流，产生给定的 
             <code>streamSize</code>数 
             <code>int</code>值，每个符合给定的起始（包括）和绑定（排他）。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#longs--">longs</a></span>()</code>
<div class="block">
              返回一个有效的无限流的伪 
             <code>long</code>值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#longs-long-">longs</a></span>(long streamSize)</code>
<div class="block">
              返回一个流，产生给定的 
             <code>streamSize</code>数 
             <code>long</code>值。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code><a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#longs-long-long-">longs</a></span>(long randomNumberOrigin, long randomNumberBound)</code>
<div class="block">
              返回一个有效的无限流伪 
             <code>long</code>值 
             <code>long</code> ，每个符合给定的起始（包括）和绑定（排他）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#longs-long-long-long-">longs</a></span>(long streamSize, long randomNumberOrigin, long randomNumberBound)</code>
<div class="block">
              返回一个流，产生给定的 
             <code>streamSize</code>数 
             <code>long</code> ，每个符合给定的起始（包括）和绑定（排他）。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#next-int-">next</a></span>(int bits)</code>
<div class="block">
              生成下一个伪随机数。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextBoolean--">nextBoolean</a></span>()</code>
<div class="block">
              返回下一个伪随机数，从这个随机数发生器的序列中均匀分布 
             <code>boolean</code>值。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextBytes-byte:A-">nextBytes</a></span>(byte[] bytes)</code>
<div class="block">
              生成随机字节并将它们放入用户提供的字节数组中。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextDouble--">nextDouble</a></span>()</code>
<div class="block">
              返回下一个伪随机数，从这个随机数发生器的序列中 
             <code>0.0</code>和 
             <code>1.0</code>之间的 
             <code>double</code>值 
             <code>0.0</code>分布。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextFloat--">nextFloat</a></span>()</code>
<div class="block">
              返回下一个伪随机数，从这个随机数发生器的序列中 
             <code>0.0</code>和 
             <code>1.0</code>之间的 
             <code>float</code>值 
             <code>0.0</code>分布。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextGaussian--">nextGaussian</a></span>()</code>
<div class="block">
              从该随机数发生器的序列返回下一个伪随机数，高斯（“正”）分布 
             <code>double</code>值，平均值为 
             <code>0.0</code> ，标准差为 
             <code>1.0</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextInt--">nextInt</a></span>()</code>
<div class="block">
              返回下一个伪随机数，从这个随机数发生器的序列中均匀分布 
             <code>int</code>值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextInt-int-">nextInt</a></span>(int bound)</code>
<div class="block">
              返回伪随机的，均匀分布 
             <code>int</code>值介于0（含）和指定值（不包括），从该随机数生成器的序列绘制。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#nextLong--">nextLong</a></span>()</code>
<div class="block">
              返回下一个伪，均匀分布 
             <code>long</code>从这个随机数生成器的序列值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Random.html#setSeed-long-">setSeed</a></span>(long seed)</code>
<div class="block">
              使用单个 
             <code>long</code>种子设置该随机数生成器的种子。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="Random--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Random</h4> <pre>public Random()</pre>
<div class="block">
<span>创建一个新的随机数生成器。</span>
<span>该构造函数将随机数生成器的种子设置为非常可能与该构造函数的任何其他调用不同的值。</span>
</div> </li>
</ul> <a name="Random-long-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>Random</h4> <pre>public Random(long seed)</pre>
<div class="block">
<span>使用单个<code>long</code>种子创建新的随机数生成器。</span>
<span>种子是通过方法<a href="../../java/util/Random.html#next-int-"><code>next(int)</code>维护</a>的伪随机数发生器的内部状态的初始值。</span>
<p> <span>调用<code>new Random(seed)</code>相当于：</span> </p>
<pre>  <span><code> Random rnd = new Random(); rnd.setSeed(seed);</code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>seed</code> - 初始种子 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/util/Random.html#setSeed-long-"><code>setSeed(long)</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="setSeed-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setSeed</h4> <pre>public void setSeed(long seed)</pre>
<div class="block">
<span>使用单个<code>long</code>种子设置此随机数生成器的种子。</span>
<span><code>setSeed</code>的一般合同是它改变这个随机数生成器对象的状态，使其处于完全相同的状态，就好像刚刚使用参数<code>seed</code>作为种子创建的那样。</span>
<span>该方法<code>setSeed</code>由类实现<code>Random</code>通过原子地更新所述种子</span>
<pre>  <span><code> (seed ^ 0x5DEECE66DL) &amp; ((1L &lt;&lt; 48) - 1)</code></span> </pre>
<span>并清除<code>haveNextNextGaussian</code>使用的标志<a href="../../java/util/Random.html#nextGaussian--"><code>nextGaussian()</code></a> 。</span>
<p> <span>实施<code>setSeed</code>由类<code>Random</code>碰巧只使用48给定的种子的比特。</span> <span>然而，一般来说，重写方法可以使用<code>long</code>参数的所有64位作为种子值。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>seed</code> - 初始种子 
           </dd>
</dl> </li>
</ul> <a name="next-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>next</h4> <pre>protected int next(int bits)</pre>
<div class="block">
<span>生成下一个伪随机数。</span>
<span>子类应该覆盖这一点，因为它被所有其他方法所使用。</span>
<p> <span><code>next</code>的一般合同是它返回一个<code>int</code>值，如果参数<code>bits</code>在<code>1</code>和<code>32</code> （含）之间，那么返回值的许多低位将是（大约）独立选择的比特值，其中每个（约）同样可能是<code>0</code>或<code>1</code> 。</span> <span>方法<code>next</code>由类<code>Random</code>通过将种子进行原子更新来实现</span> </p>
<pre>  <span><code> (seed * 0x5DEECE66DL + 0xBL) &amp; ((1L &lt;&lt; 48) - 1)</code></span> </pre>
<span>并返回</span>
<pre>  <span><code> (int)(seed &gt;&gt;&gt; (48 - bits))</code>.</span> </pre>
<span>这是由DH Lehmer定义的线性同余伪随机数生成器，由Donald E. Knuth在<i>“计算机编程艺术</i> ”第3卷： <i>Seminumerical Algorithms</i> ，第3.2.1节中描述。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>bits</code> - 随机位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             来自该随机数发生器序列的下一个伪随机值 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.1 
           </dd>
</dl> </li>
</ul> <a name="nextBytes-byte:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextBytes</h4> <pre>public void nextBytes(byte[] bytes)</pre>
<div class="block">
<span>生成随机字节并将它们放入用户提供的字节数组中。</span>
<span>产生的随机字节数等于字节数组的长度。</span>
<p> <span>方法<code>nextBytes</code>由类别<code>Random</code> ，如同通过：</span> </p>
<pre>  <span><code> public void nextBytes(byte[] bytes) { for (int i = 0; i &lt; bytes.length; ) for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4); n-- &gt; 0; rnd &gt;&gt;= 8) bytes[i++] = (byte)rnd; }</code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>bytes</code> - 用随机字节填充的字节数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果字节数组为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.1 
           </dd>
</dl> </li>
</ul> <a name="nextInt--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextInt</h4> <pre>public int nextInt()</pre>
<div class="block">
<span>返回下一个伪随机数，从这个随机数生成器的序列中均匀分布<code>int</code>值。</span>
<span><code>nextInt</code>的一般合同是一个<code>int</code>值被伪随机生成并返回。</span>
<span>所有2 <sup>32</sup>可能的<code>int</code>值以（大约）相等的概率产生。</span>
<p> <span>方法<code>nextInt</code>由Random类<code>Random</code> ，好像通过如下：</span> </p>
<pre>  <span><code> public int nextInt() { return next(32); }</code></span> </pre>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个伪随机数，从这个随机数发生器的序列中均匀分布 
            <code>int</code>值 
           </dd>
</dl> </li>
</ul> <a name="nextInt-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextInt</h4> <pre>public int nextInt(int bound)</pre>
<div class="block">
<span>返回伪随机的，均匀分布<code>int</code>值介于0（含）和指定值（不包括），从该随机数生成器的序列绘制。</span>
<span><code>nextInt</code>的一般合同是指定范围内的<code>int</code>值被伪随机生成并返回。</span>
<span>所有<code>bound</code>可能的<code>int</code>值以（近似）等概率产生。</span>
<span>方法<code>nextInt(int bound)</code>由类别<code>Random</code> ，如：</span>
<pre>  <span><code> public int nextInt(int bound) { if (bound &lt;= 0) throw new IllegalArgumentException("bound must be positive"); if ((bound &amp; -bound) == bound) // i.e., bound is a power of 2 return (int)((bound * (long)next(31)) &gt;&gt; 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) &lt; 0); return val; }</code></span> </pre>
<p> <span>仅在下面的方法仅仅是独立选择的位的无偏差源时才使用“近似”对冲。</span> <span>如果它是随机选择位的完美来源，则所示的<code>int</code>将从所述范围中选择<code>int</code>值，具有完美的均匀性。</span> </p>
<p> <span>该算法有点棘手。</span> <span>它拒绝会导致分配不均的价值（由于2 ^ 31不能被n整除）。</span> <span>值被拒绝的概率取决于n。</span> <span>最坏的情况是n = 2 ^ 30 + 1，拒绝概率为1/2，循环终止前的预期迭代次数为2。</span> </p>
<p> <span>该算法处理n特别是2的幂的情况：它从底层伪随机数发生器返回正确数量的高阶位。</span> <span>在没有特殊处理的情况下，将返回正确数量的<i>低位</i> 。</span> <span>已知线性同余伪随机数发生器（例如由该类实现的）产生器在其低阶位的值序列中具有短周期。</span> <span>因此，如果n是2的小功率，这种特殊情况大大增加了对该方法的连续调用返回的值的序列的长度。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>bound</code> - 上限（独占）。</span>
<span>必须是积极的。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个伪随机数，从这个随机数发生器的序列中均匀 
            <code>int</code>到零（包括）和 
            <code>bound</code> （排他）之间的值int 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果绑定 
            <code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="nextLong--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextLong</h4> <pre>public long nextLong()</pre>
<div class="block">
<span>返回下一个伪随机数，从这个随机数发生器的序列中均匀分布<code>long</code>值。</span>
<span><code>nextLong</code>的一般合同是一个<code>long</code>值被伪随机生成并返回。</span>
<p> <span>方法<code>nextLong</code>由类别<code>Random</code> ，如：</span> </p>
<pre>  <span><code> public long nextLong() { return ((long)next(32) &lt;&lt; 32) + next(32); }</code></span> </pre>
<span>因为<code>Random</code>类使用只有48位的种子，所以该算法将不会返回所有可能的<code>long</code>值。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个伪随机数，从这个随机数发生器的序列中均匀分布 
            <code>long</code>值 
           </dd>
</dl> </li>
</ul> <a name="nextBoolean--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextBoolean</h4> <pre>public boolean nextBoolean()</pre>
<div class="block">
<span>返回下一个伪随机数，从这个随机数发生器的序列中均匀分布<code>boolean</code>值。</span>
<span><code>nextBoolean</code>的一般合同是一个<code>boolean</code>值被伪随机生成并返回。</span>
<span>价值<code>true</code>和<code>false</code>以（大概）相等的概率产生。</span>
<p> <span>方法<code>nextBoolean</code>由类别<code>Random</code> ，如：</span> </p>
<pre>  <span><code> public boolean nextBoolean() { return next(1) != 0; }</code></span> </pre>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个伪随机数，从这个随机数发生器的序列中均匀分布 
            <code>boolean</code>值 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="nextFloat--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextFloat</h4> <pre>public float nextFloat()</pre>
<div class="block">
<span>返回下一个伪，均匀分布<code>float</code>之间的值<code>0.0</code>和<code>1.0</code>从这个随机数生成器的序列。</span>
<p> <span><code>nextFloat</code>的一般合同是一个<code>float</code>值，从<code>0.0f</code> （含）到<code>1.0f</code> （独占）一起选择（大致）均匀，被伪随机生成并返回。</span> <span>以（大致）等概率产生形式<i>m×</i> 2 <sup>-24的</sup>全部2 <sup>24个</sup>可能的<code>float</code>值，其中<i>m</i>是小于2 <sup>24</sup>的正整数。</span> </p>
<p> <span>方法<code>nextFloat</code>由Random类<code>Random</code> ，如同通过：</span> </p>
<pre>  <span><code> public float nextFloat() { return next(24) / ((float)(1 &lt;&lt; 24)); }</code></span> </pre>
<p> <span>仅在下面的方法仅仅是独立选择的位的无偏差源时才使用“近似”对冲。</span> <span>如果它是随机选择位的完美来源，则所示的<code>float</code>将从所述范围中选择<code>float</code>值，具有完美的均匀性。</span> </p>
<p> <span>[在Java的早期版本中，结果错误地计算为：</span> </p>
<pre>  <span><code> return next(30) / ((float)(1 &lt;&lt; 30));</code></span> </pre>
<span>这可能似乎是等同的，如果不是更好，但实际上它引入了一个轻微的不均匀性，因为浮点数的四舍五入的偏差：有意义的低位比较有可能是0这将是1.]</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个伪随机数，从这个随机数发生器的序列中均匀分布 
            <code>float</code>值 
            <code>0.0</code>和 
            <code>1.0</code>之间 
           </dd>
</dl> </li>
</ul> <a name="nextDouble--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextDouble</h4> <pre>public double nextDouble()</pre>
<div class="block">
<span>返回下一个伪随机数，从该随机数发生器的序列中<code>0.0</code>和<code>1.0</code>之间的<code>double</code>值。</span>
<p> <span><code>nextDouble</code>的一般合同是从<code>0.0d</code> （含）到<code>1.0d</code> （排他）范围内选择（近似均匀）的一个<code>double</code>值被伪随机生成并返回。</span> </p>
<p> <span>方法<code>nextDouble</code>由类别<code>Random</code> ，如：</span> </p>
<pre>  <span><code> public double nextDouble() { return (((long)next(26) &lt;&lt; 27) + next(27)) / (double)(1L &lt;&lt; 53); }</code></span> </pre>
<p> <span>因为<code>next</code>方法只是大致上独立选择的位的无偏差源，所以在<code>next</code>的描述中使用了“大约”对冲。</span> <span>如果它是随机选择的位的完美来源，则所示的<code>double</code>将从所述范围中选择<code>double</code>值，具有完美的均匀性。</span> </p>
<p> <span>[在Java的早期版本中，结果错误地计算为：</span> </p>
<pre>  <span><code> return (((long)next(27) &lt;&lt; 27) + next(27)) / (double)(1L &lt;&lt; 54);</code></span> </pre>
<span>这可能似乎是等同的，如果不是更好，但事实上它引入了一个大的不均匀性，因为浮点数的四舍五入有偏差：有效位的低位是0的可能性是三倍比那会是1！</span>
<span>这种不均匀性在实践中可能无关紧要，但我们力求完美。]</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个伪随机数，从这个随机数发生器的序列中 
            <code>0.0</code>和 
            <code>1.0</code>之间的 
            <code>double</code>值 
            <code>0.0</code>分布 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../java/lang/Math.html#random--"><code>Math.random()</code></a>
</dd>
</dl> </li>
</ul> <a name="nextGaussian--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>nextGaussian</h4> <pre>public double nextGaussian()</pre>
<div class="block">
<span>从该随机数发生器的序列返回下一个伪随机数，高斯（“正”）分布的<code>double</code>值，平均值为<code>0.0</code> ，标准差为<code>1.0</code> 。</span>
<p> <span><code>nextGaussian</code>的一般合同是从（大约）平均值<code>0.0</code>和标准偏差<code>1.0</code>的常规正态分布中选出一个<code>double</code>值，被伪随机生成并返回。</span> </p>
<p> <span>方法<code>nextGaussian</code>由类<code>Random</code> ，好像通过以下的线程安全版本：</span> </p>
<pre>  <span><code> private double nextNextGaussian; private boolean haveNextNextGaussian = false; public double nextGaussian() { if (haveNextNextGaussian) { haveNextNextGaussian = false; return nextNextGaussian; } else { double v1, v2, s; do { v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0 v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0 s = v1 * v1 + v2 * v2; } while (s &gt;= 1 || s == 0); double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s); nextNextGaussian = v2 * multiplier; haveNextNextGaussian = true; return v1 * multiplier; } }</code></span> </pre>
<span>这使用GEP Box，ME Muller和G. Marsaglia的<i>极性方法</i> ，如Donald E. Knuth在<i>“计算机编程艺术</i> ”第3卷： <i>半数学算法</i> ，第3.4.1节，C节，算法P中所述。请注意它生成两个独立的值，只需一次呼叫<code>StrictMath.log</code> ，一次呼叫到<code>StrictMath.sqrt</code> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个伪随机数，高斯（“正常”）分布 
            <code>double</code>值，平均值为 
            <code>0.0</code> ，标准差 
            <code>1.0</code>为该随机数发生器序列 
           </dd>
</dl> </li>
</ul> <a name="ints-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ints</h4> <pre>public <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a> ints(long streamSize)</pre>
<div class="block">
<span>返回一个流，产生给定的<code>streamSize</code>数量的伪<code>int</code>数<code>int</code>值。</span>
<p> <span>伪随机<code>int</code>值被生成，就像调用方法<a href="../../java/util/Random.html#nextInt--"><code>nextInt()</code></a>的结果<a href="../../java/util/Random.html#nextInt--">一样</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>streamSize</code> - 要生成的值的数量 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一串 
            <code>int</code>值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>streamSize</code>小于零 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="ints--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ints</h4> <pre>public <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a> ints()</pre>
<div class="block">
<span>返回一个有效的无限流的伪<code>int</code>值。</span>
<p> <span>伪随机<code>int</code>值被生成，就像调用方法<a href="../../java/util/Random.html#nextInt--"><code>nextInt()</code></a>的结果<a href="../../java/util/Random.html#nextInt--">一样</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法实现等同于 
            <code>ints(Long.MAX_VALUE)</code> 。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一串 
            <code>int</code>值 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="ints-long-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ints</h4> <pre>public <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a> ints(long streamSize,
                      int randomNumberOrigin,
                      int randomNumberBound)</pre>
<div class="block">
<span>返回一个流，产生给定的<code>streamSize</code>伪<code>int</code>数值<code>int</code> ，每个值符合给定的起始（包括）和绑定（排他）。</span>
<p> <span>伪随机<code>int</code>值被生成，就像它是使用原始和绑定调用以下方法的结果一样：</span> </p>
<pre>  <span><code> int nextInt(int origin, int bound) { int n = bound - origin; if (n &gt; 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r &lt; origin || r &gt;= bound); return r; } }</code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>streamSize</code> - 要生成的值的数量 
           </dd>
<dd>
<code>randomNumberOrigin</code> - 每个随机值的起始（含） 
           </dd>
<dd>
<code>randomNumberBound</code> - 每个随机值的绑定（排他） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个伪 
            <code>int</code>的流量 
            <code>int</code> ，每个都有给定的来源（包括）和绑定（排他） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>streamSize</code>小于零，或 
            <code>randomNumberOrigin</code>大于等于 
            <code>randomNumberBound</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="ints-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ints</h4> <pre>public <a href="../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a> ints(int randomNumberOrigin,
                      int randomNumberBound)</pre>
<div class="block">
<span>返回一个有效的无限流的伪随机<code>int</code>值，每个符合给定的起始（包括）和绑定（排他）。</span>
<p> <span>伪随机<code>int</code>值被生成，就像它是使用原点和边界调用以下方法的结果一样：</span> </p>
<pre>  <span><code> int nextInt(int origin, int bound) { int n = bound - origin; if (n &gt; 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r &lt; origin || r &gt;= bound); return r; } }</code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法被实现为等同于 
            <code>ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)</code> 。 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>randomNumberOrigin</code> - 每个随机值的起点（含） 
           </dd>
<dd>
<code>randomNumberBound</code> - 每个随机值的绑定（排他） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个伪 
            <code>int</code>流（int），每个都有给定的来源（包括）和绑定（排他） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>randomNumberOrigin</code>大于或等于 
            <code>randomNumberBound</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="longs-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>longs</h4> <pre>public <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a> longs(long streamSize)</pre>
<div class="block">
<span>返回一个流，产生给定的<code>streamSize</code>数<code>long</code>数值。</span>
<p> <span>伪随机<code>long</code>值被生成，就像调用方法<a href="../../java/util/Random.html#nextLong--"><code>nextLong()</code></a>的结果<a href="../../java/util/Random.html#nextLong--">一样</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>streamSize</code> - 要生成的值的数量 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一串 
            <code>long</code>值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>streamSize</code>小于零 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="longs--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>longs</h4> <pre>public <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a> longs()</pre>
<div class="block">
<span>返回一个有效的无限流的伪<code>long</code>值。</span>
<p> <span>伪随机<code>long</code>值被生成，就像调用方法<a href="../../java/util/Random.html#nextLong--"><code>nextLong()</code></a>的结果<a href="../../java/util/Random.html#nextLong--">一样</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法实现等于 
            <code>longs(Long.MAX_VALUE)</code> 。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一串 
            <code>long</code>值 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="longs-long-long-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>longs</h4> <pre>public <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a> longs(long streamSize,
                        long randomNumberOrigin,
                        long randomNumberBound)</pre>
<div class="block">
<span>返回一个流，产生给定的<code>streamSize</code>数<code>long</code> ，每个符合给定的起始（包括）和绑定（排他）。</span>
<p> <span>伪随机<code>long</code>值被生成，就像它是使用原点和边界调用以下方法的结果一样：</span> </p>
<pre>  <span><code> long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n &amp; m) == 0L) // power of two r = (r &amp; m) + origin; else if (n &gt; 0L) { // reject over-represented candidates for (long u = r &gt;&gt;&gt; 1; // ensure nonnegative u + m - (r = u % n) &lt; 0L; // rejection check u = nextLong() &gt;&gt;&gt; 1) // retry ; r += origin; } else { // range not representable as long while (r &lt; origin || r &gt;= bound) r = nextLong(); } return r; }</code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>streamSize</code> - 要生成的值的数量 
           </dd>
<dd>
<code>randomNumberOrigin</code> - 每个随机值的起点（含） 
           </dd>
<dd>
<code>randomNumberBound</code> - 每个随机值的绑定（排他） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个伪 
            <code>long</code>流long，每个都有给定的来源（包括）和绑定（排他） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>streamSize</code>小于零，或 
            <code>randomNumberOrigin</code>大于或等于 
            <code>randomNumberBound</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="longs-long-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>longs</h4> <pre>public <a href="../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a> longs(long randomNumberOrigin,
                        long randomNumberBound)</pre>
<div class="block">
<span>返回一个有效的无限流伪<code>long</code>值<code>long</code> ，每个值都符合给定的起始（包括）和绑定（排他）。</span>
<p> <span>伪随机<code>long</code>值被生成，就像是使用原点和边界调用以下方法的结果一样：</span> </p>
<pre>  <span><code> long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n &amp; m) == 0L) // power of two r = (r &amp; m) + origin; else if (n &gt; 0L) { // reject over-represented candidates for (long u = r &gt;&gt;&gt; 1; // ensure nonnegative u + m - (r = u % n) &lt; 0L; // rejection check u = nextLong() &gt;&gt;&gt; 1) // retry ; r += origin; } else { // range not representable as long while (r &lt; origin || r &gt;= bound) r = nextLong(); } return r; }</code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法实现等同于 
            <code>longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)</code> 。 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>randomNumberOrigin</code> - 每个随机值的起点（含） 
           </dd>
<dd>
<code>randomNumberBound</code> - 每个随机值的绑定（排他） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个伪 
            <code>long</code>流（long），每个都有给定的来源（包括）和绑定（排他） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>randomNumberOrigin</code>大于或等于 
            <code>randomNumberBound</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="doubles-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>doubles</h4> <pre>public <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a> doubles(long streamSize)</pre>
<div class="block">
<span>返回一个流，产生给定的<code>streamSize</code>数<code>double</code>值，每个值在零（包括）和一（独占）之间。</span>
<p> <span>伪随机<code>double</code>值被生成，就像调用方法<a href="../../java/util/Random.html#nextDouble--"><code>nextDouble()</code></a>的结果<a href="../../java/util/Random.html#nextDouble--">一样</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>streamSize</code> - 要生成的值的数量 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>double</code>值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>streamSize</code>小于零 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="doubles--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>doubles</h4> <pre>public <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a> doubles()</pre>
<div class="block">
<span>返回一个有效地无限制的伪随机流<code>double</code>值，每个值在零（包括）和一（独占）之间。</span>
<p> <span>伪随机<code>double</code>值被生成，就像调用方法<a href="../../java/util/Random.html#nextDouble--"><code>nextDouble()</code></a>的结果<a href="../../java/util/Random.html#nextDouble--">一样</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法实现等同于 
            <code>doubles(Long.MAX_VALUE)</code> 。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一串 
            <code>double</code>值 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="doubles-long-double-double-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>doubles</h4> <pre>public <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a> doubles(long streamSize,
                            double randomNumberOrigin,
                            double randomNumberBound)</pre>
<div class="block">
<span>返回一个流，产生给定的<code>streamSize</code>伪<code>double</code>数值<code>double</code> ，每个值符合给定的起始（包括）和绑定（排他）。</span>
<p> <span>伪随机<code>double</code>值被生成，就好像它是使用原点和边界调用以下方法的结果一样：</span> </p>
<pre>  <span><code> double nextDouble(double origin, double bound) { double r = nextDouble(); r = r * (bound - origin) + origin; if (r &gt;= bound) // correct for rounding r = Math.nextDown(bound); return r; }</code></span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>streamSize</code> - 要生成的值的数量 
           </dd>
<dd>
<code>randomNumberOrigin</code> - 每个随机值的起始（含） 
           </dd>
<dd>
<code>randomNumberBound</code> - 每个随机值的绑定（排他） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个伪 
            <code>double</code>流（double），每个都有给定的来源（包括）和绑定（排他） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>streamSize</code>小于零 
           </dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>randomNumberOrigin</code>大于等于 
            <code>randomNumberBound</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="doubles-double-double-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>doubles</h4> <pre>public <a href="../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a> doubles(double randomNumberOrigin,
                            double randomNumberBound)</pre>
<div class="block">
<span>返回一个有效的无限流伪<code>double</code>值<code>double</code> ，每个值都符合给定的起始（包括）和绑定（排除）。</span>
<p> <span>伪随机<code>double</code>值被生成，就像它是使用原点和边界调用以下方法的结果一样：</span> </p>
<pre>  <span><code> double nextDouble(double origin, double bound) { double r = nextDouble(); r = r * (bound - origin) + origin; if (r &gt;= bound) // correct for rounding r = Math.nextDown(bound); return r; }</code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">Implementation Note:</span>
</dt>
<dd>
             该方法实现等于 
            <code>doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)</code> 。 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>randomNumberOrigin</code> - 每个随机值的起始（含） 
           </dd>
<dd>
<code>randomNumberBound</code> - 每个随机值的绑定（排他） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个伪 
            <code>double</code>流double，每个都有给定的起源（包括）和绑定（独占） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>randomNumberOrigin</code>大于或等于 
            <code>randomNumberBound</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>