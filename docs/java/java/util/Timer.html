<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util 
   </div>
<h2 class="title" title="Class Timer">Class Timer</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.Timer</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">Timer</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>线程调度任务以供将来在后台线程中执行的功能。</span>
<span>任务可以安排一次执行，或定期重复执行。</span>
<p> <span>对应于每个<tt>Timer</tt>对象是单个后台线程，用于依次执行所有定时器的所有任务。</span> <span>计时器任务应该快速完成。</span> <span>如果一个定时器任务需要花费很多时间来完成，它会“计时”计时器的任务执行线程。</span> <span>这可能会延迟随后的任务的执行，这些任务在（和）如果违规任务最后完成时，可能会“束起来”并快速执行。</span> </p>
<p> <span>在最后一次对<tt>Timer</tt>对象的引用后<i>，</i>所有未完成的任务已完成执行，定时器的任务执行线程正常终止（并被收集到垃圾回收）。</span> <span>但是，这可能需要任意长时间的发生。</span> <span>默认情况下，任务执行线程不作为<i>守护程序线程</i>运行，因此它能够使应用程序终止。</span> <span>如果主叫方想要快速终止定时器的任务执行线程，则调用者应该调用定时器的<tt>cancel</tt>方法。</span> </p>
<p> <span>如果定时器的任务执行线程意外终止，例如，因为它调用了<tt>stop</tt>方法，那么在计时器上安排任务的任何进一步的尝试将会产生一个<tt>IllegalStateException</tt> ，就像定时器的<tt>cancel</tt>方法被调用一样。</span> </p>
<p> <span>这个类是线程安全的：多个线程可以共享一个单独的<tt>Timer</tt>对象，而不需要外部同步。</span> </p>
<p> <span>此类<i>不</i>提供实时保证：使用<tt>Object.wait(long)</tt>方法是调度任务。</span> </p>
<p> <span>Java 5.0引入了<code>java.util.concurrent</code>软件包，其中一个<code>java.util.concurrent</code>程序是<a href="../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent中的类"><code>ScheduledThreadPoolExecutor</code></a> ，它是用于以给定速率或延迟重复执行任务的线程池。</span> <span>这实际上是对一个更灵活的替代<code>Timer</code> / <code>TimerTask</code>组合，因为它允许多个服务线程，接受各种时间单位，并且不需要子类<code>TimerTask</code> （只实现<code>Runnable</code> ）。</span> <span>使用一个线程配置<code>ScheduledThreadPoolExecutor</code>使其等同于<code>Timer</code> 。</span> </p>
<p> <span>实现注意事项：这个类可以扩展到大量并发计划任务（千应该没有问题）。</span> <span>在内部，它使用二进制堆表示其任务队列，因此计划任务的成本为O（log n），其中n为并发计划任务的数量。</span> </p>
<p> <span>实现注意事项：所有构造函数启动计时器线程。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.3 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/util/TimerTask.html" title="java.util中的类"><code>TimerTask</code></a> ， <a href="../../java/lang/Object.html#wait-long-"><code>Object.wait(long)</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#Timer--">Timer</a></span>()</code>
<div class="block">
              创建一个新的计时器。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#Timer-boolean-">Timer</a></span>(boolean isDaemon)</code>
<div class="block">
              创建一个新的定时器，其相关线程可以指定为 
             <a href="../../java/lang/Thread.html#setDaemon-boolean-">run as a daemon</a> 。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#Timer-java.lang.String-">Timer</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              创建一个新的定时器，其相关线程具有指定的名称。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#Timer-java.lang.String-boolean-">Timer</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name, boolean isDaemon)</code>
<div class="block">
              创建一个新的定时器，其相关线程具有指定的名称，可以指定为 
             <a href="../../java/lang/Thread.html#setDaemon-boolean-">run as a daemon</a> 。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#cancel--">cancel</a></span>()</code>
<div class="block">
              终止此计时器，丢弃任何当前计划的任务。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#purge--">purge</a></span>()</code>
<div class="block">
              从该计时器的任务队列中删除所有取消的任务。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#schedule-java.util.TimerTask-java.util.Date-">schedule</a></span>(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task, <a href="../../java/util/Date.html" title="class in java.util">Date</a> time)</code>
<div class="block">
              在指定的时间安排指定的任务执行。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#schedule-java.util.TimerTask-java.util.Date-long-">schedule</a></span>(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task, <a href="../../java/util/Date.html" title="class in java.util">Date</a> firstTime, long period)</code>
<div class="block">
              从指定 
             <i>的时间开始</i> ，对指定的任务执行重复的 
             <i>固定延迟执行</i> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#schedule-java.util.TimerTask-long-">schedule</a></span>(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task, long delay)</code>
<div class="block">
              在指定的延迟之后安排指定的任务执行。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#schedule-java.util.TimerTask-long-long-">schedule</a></span>(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task, long delay, long period)</code>
<div class="block">
              在指定 
             <i>的延迟之后开始</i> ，重新执行 
             <i>固定延迟</i>执行的指定任务。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#scheduleAtFixedRate-java.util.TimerTask-java.util.Date-long-">scheduleAtFixedRate</a></span>(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task, <a href="../../java/util/Date.html" title="class in java.util">Date</a> firstTime, long period)</code>
<div class="block">
              从指定的时间 
             <i>开始</i> ，对指定的任务执行重复的 
             <i>固定速率执行</i> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/util/Timer.html#scheduleAtFixedRate-java.util.TimerTask-long-long-">scheduleAtFixedRate</a></span>(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task, long delay, long period)</code>
<div class="block">
              在指定的延迟之后 
             <i>开始</i> ，重新执行 
             <i>固定速率</i>的指定任务。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="Timer--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Timer</h4> <pre>public Timer()</pre>
<div class="block">
<span>创建一个新的计时器。</span>
<span>相关联的线程<i>不是</i> <a href="../../java/lang/Thread.html#setDaemon-boolean-">run as a daemon</a> 。</span>
</div> </li>
</ul> <a name="Timer-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Timer</h4> <pre>public Timer(boolean isDaemon)</pre>
<div class="block">
<span>创建一个新的定时器，其相关线程可以指定为<a href="../../java/lang/Thread.html#setDaemon-boolean-">run as a daemon</a> 。</span>
<span>如果定时器将用于调度重复的“维护活动”，只要应用程序正在运行，但是不应该延长应用程序的使用寿命，则会调用守护线程。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>isDaemon</code> - 如果关联的线程应该作为守护进程运行，则为true。 
           </dd>
</dl> </li>
</ul> <a name="Timer-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>Timer</h4> <pre>public Timer(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name)</pre>
<div class="block">
<span>创建一个新的定时器，其相关线程具有指定的名称。</span>
<span>相关的线程<i>不是</i> <a href="../../java/lang/Thread.html#setDaemon-boolean-">run as a daemon</a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 相关线程的名称 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>name</code>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="Timer-java.lang.String-boolean-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>Timer</h4> <pre>public Timer(<a href="../../java/lang/String.html" title="class in java.lang">String</a> name,
             boolean isDaemon)</pre>
<div class="block">
            创建一个新的定时器，其相关线程具有指定的名称，可以指定为 
           <a href="../../java/lang/Thread.html#setDaemon-boolean-">run as a daemon</a> 。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 相关线程的名称 
           </dd>
<dd>
<code>isDaemon</code> - 如果关联的线程应该作为守护程序运行，则为true 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>name</code>为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="schedule-java.util.TimerTask-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>schedule</h4> <pre>public void schedule(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task,
                     long delay)</pre>
<div class="block">
            在指定的延迟之后安排指定的任务执行。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要安排的任务。 
           </dd>
<dd>
<code>delay</code> - 执行任务之前以 
            <code>delay</code>为单位的延迟。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>delay</tt>为负数，或 
            <tt>delay + System.currentTimeMillis()</tt>为负数。 
           </dd>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果任务已经被调度或取消，定时器被取消或定时器线程被终止。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>task</code>为空 
           </dd>
</dl> </li>
</ul> <a name="schedule-java.util.TimerTask-java.util.Date-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>schedule</h4> <pre>public void schedule(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task,
                     <a href="../../java/util/Date.html" title="class in java.util">Date</a> time)</pre>
<div class="block">
<span>在指定的时间安排指定的任务执行。</span>
<span>如果时间过去了，这个任务就被安排立即执行。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要安排的任务。 
           </dd>
<dd>
<code>time</code> - 执行任务的时间。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>time.getTime()</tt>为负数。 
           </dd>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果任务已经被调度或取消，定时器被取消或定时器线程被终止。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>task</code>或 
            <code>time</code>为空 
           </dd>
</dl> </li>
</ul> <a name="schedule-java.util.TimerTask-long-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>schedule</h4> <pre>public void schedule(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task,
                     long delay,
                     long period)</pre>
<div class="block">
<span>在指定<i>的延迟之后开始</i> ，重新执行<i>固定延迟</i>执行的指定任务。</span>
<span>后续执行按照规定的时间间隔间隔进行。</span>
<p> <span>在固定延迟执行中，每个执行都相对于上一次执行的实际执行时间进行调度。</span> <span>如果由于任何原因（如垃圾收集或其他背景活动）延迟执行，则后续执行也将被延迟。</span> <span>从长远来看，执行频率通常比指定的周期（假定系统时钟基本<tt>Object.wait(long)</tt>是准确）的倒数略低。</span> </p>
<p> <span>固定延迟执行适用于需要“平滑”的重复活动。</span> <span>换句话说，适合在短期内保持频率准确的活动比从长远来看更为重要的活动。</span> <span>这包括大多数动画任务，例如定期闪烁光标。</span> <span>它还包括其中响应于人类输入执行常规活动的任务，例如只要按住键被自动重复一个字符。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要安排的任务。 
           </dd>
<dd>
<code>delay</code> - 执行任务之前以 
            <code>delay</code>为单位的延迟。 
           </dd>
<dd>
<code>period</code> - 连续执行任务之间的时间（以毫秒为单位）。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>delay &lt; 0</code>或 
            <code>delay + System.currentTimeMillis() &lt; 0</code>或 
            <code>period &lt;= 0</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果任务已经被调度或取消，定时器被取消或定时器线程被终止。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>task</code>为空 
           </dd>
</dl> </li>
</ul> <a name="schedule-java.util.TimerTask-java.util.Date-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>schedule</h4> <pre>public void schedule(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task,
                     <a href="../../java/util/Date.html" title="class in java.util">Date</a> firstTime,
                     long period)</pre>
<div class="block">
<span>从指定<i>的时间开始</i> ，对指定的任务执行重复的<i>固定延迟执行</i> 。</span>
<span>后续执行大约定期进行，间隔指定期间。</span>
<p> <span>在固定延迟执行中，每个执行都相对于上一次执行的实际执行时间进行调度。</span> <span>如果由于任何原因（如垃圾收集或其他背景活动）延迟执行，则后续执行也将被延迟。</span> <span>从长远来看，执行频率通常比指定的周期（假定系统时钟基本<tt>Object.wait(long)</tt>是准确）的倒数略低。</span> <span>作为上述的结果，如果计划的第一次是过去的，则计划立即执行。</span> </p>
<p> <span>固定延迟执行适用于需要“平滑”的重复活动。</span> <span>换句话说，适合在短期内保持频率准确的活动比从长远来看更为重要的活动。</span> <span>这包括大多数动画任务，例如定期闪烁光标。</span> <span>它还包括其中响应于人类输入执行常规活动的任务，例如只要按住键被自动重复一个字符。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要安排的任务。 
           </dd>
<dd>
<code>firstTime</code> - 第一次执行任务。 
           </dd>
<dd>
<code>period</code> - 连续执行任务之间的时间（以毫秒为单位）。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>firstTime.getTime() &lt; 0</code>或 
            <code>period &lt;= 0</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果任务已经被调度或取消，定时器被取消或定时器线程被终止。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>task</code>或 
            <code>firstTime</code>为空 
           </dd>
</dl> </li>
</ul> <a name="scheduleAtFixedRate-java.util.TimerTask-long-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>scheduleAtFixedRate</h4> <pre>public void scheduleAtFixedRate(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task,
                                long delay,
                                long period)</pre>
<div class="block">
<span>在指定的延迟之后<i>开始</i> ，重新执行<i>固定速率</i>的指定任务。</span>
<span>后续执行大约定期进行，间隔指定期间。</span>
<p> <span>在固定速率执行中，相对于初始执行的预定执行时间调度每个执行。</span> <span>如果由于任何原因（例如垃圾收集或其他背景活动）延迟执行，则两次或多次执行将快速连续发生以“追赶”。</span> <span>从长远来看，执行的频率将是完全可逆的规定期间（假设系统时钟基本<tt>Object.wait(long)</tt>是准确）的。</span> </p>
<p> <span>固定速率执行适用于对<i>绝对</i>时间敏感的重复活动，例如每小时敲响一次钟声，或在特定时间每天运行定期维护。</span> <span>对于执行固定次数的执行的总时间很重要的循环活动也是适用的，例如每秒钟打10秒钟的倒数计时器。</span> <span>最后，固定速率执行适用于调度必须相对于彼此保持同步的多个重复定时器任务。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要安排的任务。 
           </dd>
<dd>
<code>delay</code> - 执行任务之前以 
            <code>delay</code>为单位的延迟。 
           </dd>
<dd>
<code>period</code> - 连续执行任务之间的毫秒数。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>delay &lt; 0</code>或 
            <code>delay + System.currentTimeMillis() &lt; 0</code>或 
            <code>period &lt;= 0</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果任务已经被调度或取消，定时器被取消或定时器线程被终止。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>task</code>为空 
           </dd>
</dl> </li>
</ul> <a name="scheduleAtFixedRate-java.util.TimerTask-java.util.Date-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>scheduleAtFixedRate</h4> <pre>public void scheduleAtFixedRate(<a href="../../java/util/TimerTask.html" title="class in java.util">TimerTask</a> task,
                                <a href="../../java/util/Date.html" title="class in java.util">Date</a> firstTime,
                                long period)</pre>
<div class="block">
<span>从指定的时间<i>开始</i> ，对指定的任务执行重复的<i>固定速率执行</i> 。</span>
<span>后续执行大约定期进行，间隔指定期间。</span>
<p> <span>在固定速率执行中，相对于初始执行的预定执行时间调度每个执行。</span> <span>如果由于任何原因（例如垃圾收集或其他背景活动）延迟执行，则两次或多次执行将快速连续发生以“追赶”。</span> <span>从长远来看，执行的频率将是完全可逆的规定期间（假设系统时钟基本<tt>Object.wait(long)</tt>是准确）的。</span> <span>由于上述原因，如果计划的第一次是过去，那么任何“错过”的处决将被安排在立即的“追赶”执行之中。</span> </p>
<p> <span>固定速率执行适用于对<i>绝对</i>时间敏感的重复活动，例如每小时敲响一次钟声，或在特定时间每天运行定期维护。</span> <span>对于执行固定次数的执行的总时间很重要的循环活动也是适用的，例如每秒钟打10秒钟的倒数计时器。</span> <span>最后，固定速率执行适用于调度必须相对于彼此保持同步的多个重复定时器任务。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要安排的任务。 
           </dd>
<dd>
<code>firstTime</code> - 第一次执行任务。 
           </dd>
<dd>
<code>period</code> - 连续执行任务之间的时间（以毫秒为单位）。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>firstTime.getTime() &lt; 0</code>或 
            <code>period &lt;= 0</code>
</dd>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果任务已经被调度或取消，定时器被取消或定时器线程被终止。 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>task</code>或 
            <code>firstTime</code>为null 
           </dd>
</dl> </li>
</ul> <a name="cancel--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>cancel</h4> <pre>public void cancel()</pre>
<div class="block">
<span>终止此计时器，丢弃任何当前计划的任务。</span>
<span>不干扰当前执行的任务（如果存在）。</span>
<span>一旦计时器被终止，它的执行线程就会顺利地终止，并且不会再安排任务了。</span>
<p> <span>请注意，在此定时器调用的定时器任务的运行方法内调用此方法绝对保证正在进行的任务执行是该定时器将执行的最后一个任务执行。</span> </p>
<p> <span>这个方法可以重复调用;</span> <span>第二个和以后的呼叫没有任何效果。</span> </p>
</div> </li>
</ul> <a name="purge--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>purge</h4> <pre>public int purge()</pre>
<div class="block">
<span>从该计时器的任务队列中删除所有取消的任务。</span>
<span><i>调用此方法对定时器的行为没有影响</i> ，但是消除了对队列中已取消任务的引用。</span>
<span>如果没有对这些任务的外部引用，它们就有资格进行垃圾收集。</span>
<p> <span>大多数程序将无需调用此方法。</span> <span>它被设计用于少量应用程序使用，可以取消大量的任务。</span> <span>调用此方法可以占用空间：方法的运行时间可能与n + c log n成正比，其中n是队列中任务的数量，c是已取消任务的数量。</span> </p>
<p> <span>请注意，可以在此定时器上调度的任务内调用此方法。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             从队列中删除的任务数。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>