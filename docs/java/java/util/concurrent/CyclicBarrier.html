<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util.concurrent 
   </div>
<h2 class="title" title="Class CyclicBarrier">Class CyclicBarrier</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.concurrent.CyclicBarrier</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">CyclicBarrier</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>允许一组线程全部等待彼此达到共同屏障点的同步辅助。</span>
<span>循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。</span>
<span>屏障被称为<em>循环</em> ，因为它可以在等待的线程被释放之后重新使用。</span>
<p> <span>A <code>CyclicBarrier</code>支持一个可选的<a href="../../../java/lang/Runnable.html" title="java.lang中的接口"><code>Runnable</code></a>命令，每个屏障点运行一次，在派对中的最后一个线程到达之后，但在任何线程释放之前。</span> <span>在任何一方继续进行之前，此<em>屏障操作</em>对更新共享状态很有用。</span> </p>
<p> <span><b>示例用法：</b>以下是在并行分解设计中使用障碍的示例：</span> </p>
<pre>  <span><code> class Solver { final int N; final float[][] data; final CyclicBarrier barrier; class Worker implements Runnable { int myRow; Worker(int row) { myRow = row; } public void run() { while (!done()) { processRow(myRow); try { barrier.await(); } catch (InterruptedException ex) { return; } catch (BrokenBarrierException ex) { return; } } } } public Solver(float[][] matrix) { data = matrix; N = matrix.length; Runnable barrierAction = new Runnable() { public void run() { mergeRows(...); }}; barrier = new CyclicBarrier(N, barrierAction); List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(N); for (int i = 0; i &lt; N; i++) { Thread thread = new Thread(new Worker(i)); threads.add(thread); thread.start(); } // wait until done for (Thread thread : threads) thread.join(); } }</code></span> </pre>
<span>这里，每个工作线程处理矩阵的一行，然后等待屏障，直到所有行都被处理。</span>
<span>当处理所有行时，执行提供的<a href="../../../java/lang/Runnable.html" title="java.lang中的接口"><code>Runnable</code></a>屏障操作并合并行。</span>
<span>如果合并确定已经找到解决方案，那么<code>done()</code>将返回<code>true</code> ，并且每个工作人员将终止。</span>
<p> <span>如果屏障操作不依赖于执行方暂停的各方，那么该方可以在释放任何线程时执行该操作。</span> <span>为了方便这一点，每次调用<a href="../../../java/util/concurrent/CyclicBarrier.html#await--"><code>await()</code></a>返回该线程在屏障上的到达索引。</span> <span>然后，您可以选择哪个线程应该执行屏障操作，例如：</span> </p>
<pre>  <span><code> if (barrier.await() == 0) { // log the completion of this iteration }</code></span> </pre>
<p> <span><code>CyclicBarrier</code>对失败的同步尝试使用all-or-none断裂模型：如果线程由于中断，故障或超时而过早离开障碍点，那么在该障碍点等待的所有其他线程也将通过<a href="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent中的类"><code>BrokenBarrierException</code></a> （或<a href="../../../java/lang/InterruptedException.html" title="java.lang中的类"><code>InterruptedException</code>）异常离开</a>如果他们也在同一时间被打断）。</span> </p>
<p> <span>内存一致性效果：线程中调用的行动之前， <code>await()</code> <a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>行动是屏障操作的一部分，进而<i>发生，之前</i>的动作之后，从相应的成功返回<code>await()</code>其他线程。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.5 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent中的类"><code>CountDownLatch</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#CyclicBarrier-int-">CyclicBarrier</a></span>(int parties)</code>
<div class="block">
              创建一个新的 
             <code>CyclicBarrier</code> ，当给定数量的线程（线程）等待它时，它将跳闸，并且当屏障跳闸时不执行预定义的动作。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#CyclicBarrier-int-java.lang.Runnable-">CyclicBarrier</a></span>(int parties, <a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> barrierAction)</code>
<div class="block">
              创建一个新的 
             <code>CyclicBarrier</code> ，当给定数量的线程（线程）等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#await--">await</a></span>()</code>
<div class="block">
              等待所有 
             <a href="../../../java/util/concurrent/CyclicBarrier.html#getParties--">parties</a>已经在这个障碍上调用了 
             <code>await</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#await-long-java.util.concurrent.TimeUnit-">await</a></span>(long timeout, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              等待所有 
             <a href="../../../java/util/concurrent/CyclicBarrier.html#getParties--">parties</a>已经在此屏障上调用 
             <code>await</code> ，或指定的等待时间过去。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#getNumberWaiting--">getNumberWaiting</a></span>()</code>
<div class="block">
              返回目前正在等待障碍的各方的数量。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#getParties--">getParties</a></span>()</code>
<div class="block">
              返回旅行这个障碍所需的聚会数量。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#isBroken--">isBroken</a></span>()</code>
<div class="block">
              查询这个障碍是否处于破碎状态。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CyclicBarrier.html#reset--">reset</a></span>()</code>
<div class="block">
              将屏障重置为初始状态。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="CyclicBarrier-int-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>CyclicBarrier</h4> <pre>public CyclicBarrier(int parties,
                     <a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> barrierAction)</pre>
<div class="block">
            创建一个新的 
           <code>CyclicBarrier</code> ，当给定数量的线程（线程）正在等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>parties</code> - 屏障跳闸前必须调用 
            <a href="../../../java/util/concurrent/CyclicBarrier.html#await--"><code>await()</code></a>的线程数 
           </dd>
<dd>
<code>barrierAction</code> - 当屏障跳闸时执行的命令，或 
            <code>null</code>如果没有动作 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>parties</code>小于1 
           </dd>
</dl> </li>
</ul> <a name="CyclicBarrier-int-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>CyclicBarrier</h4> <pre>public CyclicBarrier(int parties)</pre>
<div class="block">
            创建一个新的 
           <code>CyclicBarrier</code> ，当给定数量的线程（线程）正在等待时，它将跳闸，并且当屏障跳闸时不执行预定义的动作。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>parties</code> - 屏障跳闸前必须调用 
            <a href="../../../java/util/concurrent/CyclicBarrier.html#await--"><code>await()</code></a>的线程数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>parties</code>小于1 
           </dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getParties--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getParties</h4> <pre>public int getParties()</pre>
<div class="block">
            返回旅行这个障碍所需的聚会数量。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             要求脱离这个障碍的双方的数量 
           </dd>
</dl> </li>
</ul> <a name="await--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>await</h4> <pre>public int await()
          throws <a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a>,
                 <a href="../../../java/util/concurrent/BrokenBarrierException.html" title="class in java.util.concurrent">BrokenBarrierException</a></pre>
<div class="block">
<span>等待所有<a href="../../../java/util/concurrent/CyclicBarrier.html#getParties--">parties</a>已经在这个障碍上调用了<code>await</code> 。</span>
<p> <span>如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：</span> </p>
<ul>
<li> <span>最后一个线程到达;</span> <span>要么</span> </li>
<li> <span>一些其他线程当前线程为<a href="../../../java/lang/Thread.html#interrupt--">interrupts</a> ;</span> <span>要么</span> </li>
<li> <span>一些其他线程<a href="../../../java/lang/Thread.html#interrupt--">interrupts</a>其他等待线程之一;</span> <span>要么</span> </li>
<li> <span>一些其他线程在等待屏障时超时;</span> <span>要么</span> </li>
<li> <span>其他一些线程在这个屏障上调用<a href="../../../java/util/concurrent/CyclicBarrier.html#reset--"><code>reset()</code></a> 。</span> </li>
</ul>
<p> <span>如果当前线程：</span> </p>
<ul>
<li> <span>在进入该方法时设置了中断状态;</span> <span>要么</span> </li>
<li> <span>是等待<a href="../../../java/lang/Thread.html#interrupt--">interrupted</a></span> </li>
</ul>
<span>然后<a href="../../../java/lang/InterruptedException.html" title="java.lang中的类"><code>InterruptedException</code></a>被关上，当前线程的中断状态被清除。</span>
<p> <span>如果屏蔽是<a href="../../../java/util/concurrent/CyclicBarrier.html#reset--"><code>reset()</code></a> ，而任何线程正在等待，或者当<code>await</code>被调用时屏障<a href="../../../java/util/concurrent/CyclicBarrier.html#isBroken--">is broken</a> ，或者任何线程等待，则抛出<a href="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent中的类"><code>BrokenBarrierException</code></a> 。</span> </p>
<p> <span>如果任何线程在等待的时候是<a href="../../../java/lang/Thread.html#interrupt--">interrupted</a> ，那么所有其他等待的线程将会<a href="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent中的类">丢失<code>BrokenBarrierException</code></a> ，并且屏障被置于断开的状态。</span> </p>
<p> <span>如果当前线程是要到达的最后一个线程，并且在构造函数中提供非空障碍操作，则当前线程在允许其他线程继续之前运行该动作。</span> <span>如果在屏障动作期间发生异常，则该异常将在当前线程中传播，并且屏障置于断开状态。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前线程的到达索引，其中索引 
            <code>getParties() - 1</code>表示第一个到达，零表示最后到达 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果当前线程在等待时中断 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/BrokenBarrierException.html" title="class in java.util.concurrent">BrokenBarrierException</a></code> - 如果当前线程正在等待，或者屏蔽被重置，或者当 
            <code>await</code>时屏障被破坏，或者屏蔽动作（如果存在）由于异常而失败，则 
            <em>另一个</em>线程被中断或超时 
           </dd>
</dl> </li>
</ul> <a name="await-long-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>await</h4> <pre>public int await(long timeout,
                 <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)
          throws <a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a>,
                 <a href="../../../java/util/concurrent/BrokenBarrierException.html" title="class in java.util.concurrent">BrokenBarrierException</a>,
                 <a href="../../../java/util/concurrent/TimeoutException.html" title="class in java.util.concurrent">TimeoutException</a></pre>
<div class="block">
<span>等待所有<a href="../../../java/util/concurrent/CyclicBarrier.html#getParties--">parties</a>已经在此屏障上调用<code>await</code> ，或指定的等待时间过去。</span>
<p> <span>如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：</span> </p>
<ul>
<li> <span>最后一个线程到达;</span> <span>要么</span> </li>
<li> <span>超过指定的超时</span> <span>要么</span> </li>
<li> <span>一些其他线程当前线程<a href="../../../java/lang/Thread.html#interrupt--">interrupts</a> ;</span> <span>要么</span> </li>
<li> <span>其他一些线程<a href="../../../java/lang/Thread.html#interrupt--">interrupts</a>其他等待线程;</span> <span>要么</span> </li>
<li> <span>一些其他线程在等待屏障时超时;</span> <span>要么</span> </li>
<li> <span>其他一些线程在这个障碍上调用<a href="../../../java/util/concurrent/CyclicBarrier.html#reset--"><code>reset()</code></a> 。</span> </li>
</ul>
<p> <span>如果当前线程：</span> </p>
<ul>
<li> <span>在进入该方法时设置了中断状态;</span> <span>要么</span> </li>
<li> <span>是等待<a href="../../../java/lang/Thread.html#interrupt--">interrupted</a></span> </li>
</ul>
<span>然后<a href="../../../java/lang/InterruptedException.html" title="java.lang中的类"><code>InterruptedException</code></a>被关上，当前线程的中断状态被清除。</span>
<p> <span>如果指定的等待时间过去，则抛出<a href="../../../java/util/concurrent/TimeoutException.html" title="java.util.concurrent中的类"><code>TimeoutException</code></a> 。</span> <span>如果时间小于或等于零，该方法根本不会等待。</span> </p>
<p> <span>如果障碍是<a href="../../../java/util/concurrent/CyclicBarrier.html#reset--"><code>reset()</code></a> ，而任何线程处于等待状态，或者如果屏障<a href="../../../java/util/concurrent/CyclicBarrier.html#isBroken--">is broken</a>时<code>await</code>被调用，或在任何线程处于等待状态，然后<a href="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent中的类"><code>BrokenBarrierException</code></a>被抛出。</span> </p>
<p> <span>如果任何线程在等待的时候是<a href="../../../java/lang/Thread.html#interrupt--">interrupted</a> ，那么所有其他等待的线程将会抛出<a href="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent中的类"><code>BrokenBarrierException</code></a> ，并且屏障被置于断开的状态。</span> </p>
<p> <span>如果当前线程是要到达的最后一个线程，并且在构造函数中提供非空障碍操作，则当前线程在允许其他线程继续之前运行该动作。</span> <span>如果在屏障动作期间发生异常，则该异常将在当前线程中传播，并且屏障置于断开状态。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>timeout</code> - 等待屏障的时间 
           </dd>
<dd>
<code>unit</code> - 超时参数的时间单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前线程的到达索引，其中索引 
            <code>getParties() - 1</code>表示第一个到达，零表示最后一个到达 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果当前线程在等待时中断 
           </dd>
<dd>
<span><code><a href="../../../java/util/concurrent/TimeoutException.html" title="class in java.util.concurrent">TimeoutException</a></code> - 如果超过指定的超时。</span>
<span>在这种情况下，障碍将被破坏。</span>
</dd>
<dd>
<code><a href="../../../java/util/concurrent/BrokenBarrierException.html" title="class in java.util.concurrent">BrokenBarrierException</a></code> - 如果当前线程正在等待或 
            <em>另一个</em>线程被重置，或者 
            <code>await</code>被调用时屏障被打破，或者屏蔽动作（如果存在）由于异常而失败，则线程被中断或超时 
           </dd>
</dl> </li>
</ul> <a name="isBroken--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isBroken</h4> <pre>public boolean isBroken()</pre>
<div class="block">
            查询这个障碍是否处于破碎状态。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果一个或多个参与方因施工或最后一次重置而导致中断或超时，或由于异常而导致屏障动作失败，则从此出现障碍;</span>
<span><code>false</code>否则。</span>
</dd>
</dl> </li>
</ul> <a name="reset--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reset</h4> <pre>public void reset()</pre>
<div class="block">
<span>将屏障重置为初始状态。</span>
<span>如果任何一方正在等待屏障，他们将返回<a href="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent中的类"><code>BrokenBarrierException</code></a> 。</span>
<span>注意，由于其他原因，发生断线<em>后</em>的复位可能会复杂化;</span>
<span>线程需要以其他方式重新同步，并选择一个执行重置。</span>
<span>可能更好地为后续使用创建新的屏障。</span>
</div> </li>
</ul> <a name="getNumberWaiting--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>getNumberWaiting</h4> <pre>public int getNumberWaiting()</pre>
<div class="block">
<span>返回目前正在等待障碍的各方的数量。</span>
<span>此方法主要用于调试和断言。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             目前受阻于各方的数量 
            <a href="../../../java/util/concurrent/CyclicBarrier.html#await--"><code>await()</code></a>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>