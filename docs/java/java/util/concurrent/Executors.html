<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util.concurrent 
   </div>
<h2 class="title" title="Class Executors">Class Executors</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.concurrent.Executors</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">Executors</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>工厂和工具方法<a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口"><code>Executor</code></a> ， <a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a> ， <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口"><code>ScheduledExecutorService</code></a> ， <a href="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent中的接口"><code>ThreadFactory</code></a>和<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>在此包中定义的类。</span>
<span>该类支持以下几种方法：</span>
<ul>
<li> <span>创建并返回一个<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>设置的常用的配置设置的方法。</span> </li>
<li> <span>创建并返回一个<a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口"><code>ScheduledExecutorService</code>的</a>方法， <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口">其中</a>设置了常用的配置设置。</span> </li>
<li> <span>创建并返回“包装”ExecutorService的方法，通过使实现特定的方法无法访问来禁用重新配置。</span> </li>
<li> <span>创建并返回将新创建的线程设置为已知状态的<a href="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent中的接口"><code>ThreadFactory</code>的</a>方法。</span> </li>
<li> <span>创建并返回一个方法<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>出的其他闭包形式，这样他们就可以在需要的执行方法使用<code>Callable</code> 。</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.5 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#callable-java.security.PrivilegedAction-">callable</a></span>(<a href="../../../java/security/PrivilegedAction.html" title="interface in java.security">PrivilegedAction</a>&lt;?&gt; action)</code>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，它运行给定的特权动作并返回其结果。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#callable-java.security.PrivilegedExceptionAction-">callable</a></span>(<a href="../../../java/security/PrivilegedExceptionAction.html" title="interface in java.security">PrivilegedExceptionAction</a>&lt;?&gt; action)</code>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，该对象在被调用时运行给定的特权异常操作并返回其结果。</span>
</div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#callable-java.lang.Runnable-">callable</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</code>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，它运行给定的任务并返回<code>null</code> 。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#callable-java.lang.Runnable-T-">callable</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task, T result)</code>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，它运行给定的任务并返回给定的结果。</span>
</div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#defaultThreadFactory--">defaultThreadFactory</a></span>()</code>
<div class="block">
              返回用于创建新线程的默认线程工厂。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newCachedThreadPool--">newCachedThreadPool</a></span>()</code>
<div class="block">
              创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newCachedThreadPool-java.util.concurrent.ThreadFactory-">newCachedThreadPool</a></span>(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</code>
<div class="block">
              创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程，并在需要时使用提供的ThreadFactory创建新线程。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newFixedThreadPool-int-">newFixedThreadPool</a></span>(int nThreads)</code>
<div class="block">
              创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newFixedThreadPool-int-java.util.concurrent.ThreadFactory-">newFixedThreadPool</a></span>(int nThreads, <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</code>
<div class="block">
              创建一个线程池，重用固定数量的线程，从共享无界队列中运行，使用提供的ThreadFactory在需要时创建新线程。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newScheduledThreadPool-int-">newScheduledThreadPool</a></span>(int corePoolSize)</code>
<div class="block">
              创建一个线程池，可以调度命令在给定的延迟之后运行，或定期执行。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newScheduledThreadPool-int-java.util.concurrent.ThreadFactory-">newScheduledThreadPool</a></span>(int corePoolSize, <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</code>
<div class="block">
              创建一个线程池，可以调度命令在给定的延迟之后运行，或定期执行。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newSingleThreadExecutor--">newSingleThreadExecutor</a></span>()</code>
<div class="block">
              创建一个使用从无界队列运行的单个工作线程的执行程序。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newSingleThreadExecutor-java.util.concurrent.ThreadFactory-">newSingleThreadExecutor</a></span>(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</code>
<div class="block">
              创建一个使用单个工作线程运行无界队列的执行程序，并在需要时使用提供的ThreadFactory创建一个新线程。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newSingleThreadScheduledExecutor--">newSingleThreadScheduledExecutor</a></span>()</code>
<div class="block">
              创建一个单线程执行器，可以调度命令在给定的延迟之后运行，或定期执行。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newSingleThreadScheduledExecutor-java.util.concurrent.ThreadFactory-">newSingleThreadScheduledExecutor</a></span>(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</code>
<div class="block">
              创建一个单线程执行器，可以调度命令在给定的延迟之后运行，或定期执行。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newWorkStealingPool--">newWorkStealingPool</a></span>()</code>
<div class="block">
              创建使用所有 
             <a href="../../../java/lang/Runtime.html#availableProcessors--"><code>available processors</code></a>作为其目标并行级别的工作窃取线程池。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#newWorkStealingPool-int-">newWorkStealingPool</a></span>(int parallelism)</code>
<div class="block">
              创建一个维护足够的线程以支持给定的并行级别的线程池，并且可以使用多个队列来减少争用。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#privilegedCallable-java.util.concurrent.Callable-">privilegedCallable</a></span>(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; callable)</code>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，将在当前访问控制上下文中执行给定的<code>callable</code> 。</span>
</div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static &lt;T&gt; <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#privilegedCallableUsingCurrentClassLoader-java.util.concurrent.Callable-">privilegedCallableUsingCurrentClassLoader</a></span>(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; callable)</code>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，将在当前访问控制上下文中执行给定的<code>callable</code> ，当前上下文类加载器作为上下文类加载器。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#privilegedThreadFactory--">privilegedThreadFactory</a></span>()</code>
<div class="block">
              返回一个用于创建与当前线程具有相同权限的新线程的线程工厂。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#unconfigurableExecutorService-java.util.concurrent.ExecutorService-">unconfigurableExecutorService</a></span>(<a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> executor)</code>
<div class="block">
<span>返回一个将所有定义的<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>方法<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口">委托</a>给给定执行程序的对象，但不能以其他方式使用转换方式访问。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/Executors.html#unconfigurableScheduledExecutorService-java.util.concurrent.ScheduledExecutorService-">unconfigurableScheduledExecutorService</a></span>(<a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a> executor)</code>
<div class="block">
<span>返回一个将所有定义的<a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口"><code>ScheduledExecutorService</code></a>方法<a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口">委托</a>给给定执行程序的对象，但不能以其他方式使用转换方式访问。</span>
</div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="newFixedThreadPool-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newFixedThreadPool</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newFixedThreadPool(int nThreads)</pre>
<div class="block">
<span>创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。</span>
<span>在任何时候，最多<code>nThreads</code>线程将处于主动处理任务。</span>
<span>如果所有线程处于活动状态时都会提交其他任务，则它们将等待队列中直到线程可用。</span>
<span>如果任何线程由于在关闭之前的执行期间发生故障而终止，则如果需要执行后续任务，则新线程将占用它。</span>
<span>池中的线程将存在，直到它明确地为<a href="../../../java/util/concurrent/ExecutorService.html#shutdown--"><code>shutdown</code></a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>nThreads</code> - 池中的线程数 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的线程池 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>nThreads &lt;= 0</code>
</dd>
</dl> </li>
</ul> <a name="newWorkStealingPool-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newWorkStealingPool</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newWorkStealingPool(int parallelism)</pre>
<div class="block">
<span>创建一个维护足够的线程以支持给定的并行级别的线程池，并且可以使用多个队列来减少争用。</span>
<span>并行级别对应于主动参与或可以从事任务处理的最大线程数。</span>
<span>线程的实际数量可以动态增长和收缩。</span>
<span>工作窃取池不保证执行提交的任务的顺序。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>parallelism</code> - 目标平行度水平 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的线程池 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>parallelism &lt;= 0</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="newWorkStealingPool--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newWorkStealingPool</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newWorkStealingPool()</pre>
<div class="block">
            使用所有 
           <a href="../../../java/lang/Runtime.html#availableProcessors--"><code>available processors</code></a>作为其目标并行级别创建一个工作窃取线程池。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的线程池 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/util/concurrent/Executors.html#newWorkStealingPool-int-"><code>newWorkStealingPool(int)</code></a>
</dd>
</dl> </li>
</ul> <a name="newFixedThreadPool-int-java.util.concurrent.ThreadFactory-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newFixedThreadPool</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newFixedThreadPool(int nThreads,
                                                 <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</pre>
<div class="block">
<span>创建一个线程池，重用固定数量的线程，从共享无界队列中运行，使用提供的ThreadFactory在需要时创建新线程。</span>
<span>在任何时候，最多<code>nThreads</code>个线程将处于主动处理任务。</span>
<span>如果所有线程处于活动状态时都会提交其他任务，则它们将等待队列中直到线程可用。</span>
<span>如果任何线程由于在关闭之前的执行期间发生故障而终止，则如果需要执行后续任务，则新线程将占用它。</span>
<span>池中的线程将存在，直到它明确地为<a href="../../../java/util/concurrent/ExecutorService.html#shutdown--"><code>shutdown</code></a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>nThreads</code> - 池中的线程数 
           </dd>
<dd>
<code>threadFactory</code> - 工厂在创建新线程时使用 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的线程池 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果threadFactory为null 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>nThreads &lt;= 0</code>
</dd>
</dl> </li>
</ul> <a name="newSingleThreadExecutor--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newSingleThreadExecutor</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newSingleThreadExecutor()</pre>
<div class="block">
<span>创建一个使用从无界队列运行的单个工作线程的执行程序。</span>
<span>（请注意，如果这个单个线程由于在关闭之前的执行过程中发生故障而终止，则如果需要执行后续任务，则新的线程将占用它。）任务保证顺序执行，并且不超过一个任务将被激活在任何给定的时间。</span>
<span>与其他等效的newFixedThreadPool(1) <code>newFixedThreadPool(1)</code> ，返回的执行器保证不被重新配置以使用额外的线程。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的单线程执行器 
           </dd>
</dl> </li>
</ul> <a name="newSingleThreadExecutor-java.util.concurrent.ThreadFactory-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newSingleThreadExecutor</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newSingleThreadExecutor(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</pre>
<div class="block">
<span>创建一个使用单个工作线程运行无界队列的执行程序，并在需要时使用提供的ThreadFactory创建一个新线程。</span>
<span>与其他等效的newFixedThreadPool(1, threadFactory) <code>newFixedThreadPool(1, threadFactory)</code> ，返回的执行器保证不被重新配置以使用额外的线程。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>threadFactory</code> - 工厂在创建新线程时使用 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的单线程执行器 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果threadFactory为null 
           </dd>
</dl> </li>
</ul> <a name="newCachedThreadPool--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newCachedThreadPool</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newCachedThreadPool()</pre>
<div class="block">
<span>创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程。</span>
<span>这些池通常会提高执行许多短暂异步任务的程序的性能。</span>
<span>调用<code>execute</code>将重用以前构造的线程（如果可用）。</span>
<span>如果没有可用的线程，将创建一个新的线程并将其添加到该池中。</span>
<span>未使用六十秒的线程将被终止并从缓存中删除。</span>
<span>因此，长时间保持闲置的池将不会消耗任何资源。</span>
<span>请注意，可以使用<a href="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor</code></a>构造函数创建具有相似属性但不同详细信息的池（例如，超时参数）。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的线程池 
           </dd>
</dl> </li>
</ul> <a name="newCachedThreadPool-java.util.concurrent.ThreadFactory-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newCachedThreadPool</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> newCachedThreadPool(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</pre>
<div class="block">
            创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程，并在需要时使用提供的ThreadFactory创建新线程。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>threadFactory</code> - 创建新线程时使用的工厂 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的线程池 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果threadFactory为null 
           </dd>
</dl> </li>
</ul> <a name="newSingleThreadScheduledExecutor--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newSingleThreadScheduledExecutor</h4> <pre>public static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a> newSingleThreadScheduledExecutor()</pre>
<div class="block">
<span>创建一个单线程执行器，可以调度命令在给定的延迟之后运行，或定期执行。</span>
<span>（请注意，如果这个单个线程由于在关闭之前的执行过程中发生故障而终止，则如果需要执行后续任务，则新的线程将占用它。）任务保证顺序执行，并且不超过一个任务将被激活在任何给定的时间。</span>
<span>与其他等效的newScheduledThreadPool(1) <code>newScheduledThreadPool(1)</code> ，返回的执行器保证不被重新配置以使用额外的线程。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的预定执行者 
           </dd>
</dl> </li>
</ul> <a name="newSingleThreadScheduledExecutor-java.util.concurrent.ThreadFactory-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newSingleThreadScheduledExecutor</h4> <pre>public static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a> newSingleThreadScheduledExecutor(<a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</pre>
<div class="block">
<span>创建一个单线程执行器，可以调度命令在给定的延迟之后运行，或定期执行。</span>
<span>（请注意，如果这个单个线程由于在关闭之前的执行过程中发生故障而终止，则如果需要执行后续任务，则新的线程将占用它。）任务保证顺序执行，并且不超过一个任务将被激活在任何给定的时间。</span>
<span>与其他等效的newScheduledThreadPool(1, threadFactory) <code>newScheduledThreadPool(1, threadFactory)</code> ，返回的执行器保证不被重新配置以使用额外的线程。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>threadFactory</code> - 创建新线程时使用的工厂 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新创建的预定执行者 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果threadFactory为null 
           </dd>
</dl> </li>
</ul> <a name="newScheduledThreadPool-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newScheduledThreadPool</h4> <pre>public static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</pre>
<div class="block">
            创建一个线程池，可以调度命令在给定的延迟之后运行，或定期执行。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>corePoolSize</code> - 要保留在池中的线程数，即使它们处于空闲状态 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新创建的线程池 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>corePoolSize &lt; 0</code>
</dd>
</dl> </li>
</ul> <a name="newScheduledThreadPool-int-java.util.concurrent.ThreadFactory-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newScheduledThreadPool</h4> <pre>public static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize,
                                                              <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> threadFactory)</pre>
<div class="block">
            创建一个线程池，可以调度命令在给定的延迟之后运行，或定期执行。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>corePoolSize</code> - 要保留在池中的线程数，即使它们处于空闲状态 
           </dd>
<dd>
<code>threadFactory</code> - 执行程序创建新线程时使用的工厂 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个新创建的线程池 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果是 
            <code>corePoolSize &lt; 0</code>
</dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果threadFactory为null 
           </dd>
</dl> </li>
</ul> <a name="unconfigurableExecutorService-java.util.concurrent.ExecutorService-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unconfigurableExecutorService</h4> <pre>public static <a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> unconfigurableExecutorService(<a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a> executor)</pre>
<div class="block">
<span>返回一个将所有定义的<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>方法<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口">委托</a>给给定执行程序的对象，但不会使用任何其他可能使用转换访问的方法。</span>
<span>这提供了一种安全地“冻结”配置并且不允许调整给定的具体实现的方法。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>executor</code> - 底层实现 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>ExecutorService</code>例子 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果执行器为空 
           </dd>
</dl> </li>
</ul> <a name="unconfigurableScheduledExecutorService-java.util.concurrent.ScheduledExecutorService-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unconfigurableScheduledExecutorService</h4> <pre>public static <a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a> unconfigurableScheduledExecutorService(<a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="interface in java.util.concurrent">ScheduledExecutorService</a> executor)</pre>
<div class="block">
<span>返回一个将所有定义的<a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口"><code>ScheduledExecutorService</code></a>方法<a href="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent中的接口">委托</a>给给定执行程序的对象，但不能以其他方式使用转换方式访问。</span>
<span>这提供了一种安全地“冻结”配置并且不允许调整给定的具体实现的方法。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>executor</code> - 底层实现 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>ScheduledExecutorService</code>实例 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果执行者为空 
           </dd>
</dl> </li>
</ul> <a name="defaultThreadFactory--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>defaultThreadFactory</h4> <pre>public static <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> defaultThreadFactory()</pre>
<div class="block">
<span>返回用于创建新线程的默认线程工厂。</span>
<span>该工厂在同一个<a href="../../../java/lang/ThreadGroup.html" title="java.lang中的类"><code>ThreadGroup</code>中</a>创建了Executor使用的所有新线程。</span>
<span>如果有一个<a href="../../../java/lang/SecurityManager.html" title="java.lang中的类"><code>SecurityManager</code></a> ，它使用组<a href="../../../java/lang/System.html#getSecurityManager--"><code>System.getSecurityManager()</code></a> ，否则该组的线程调用这个<code>defaultThreadFactory</code>方法。</span>
<span>每个新线程被创建为非守护线程，优先级设置为<code>Thread.NORM_PRIORITY</code>中的较小者，线程组中允许的最大优先级。</span>
<span>新线程具有可通过访问名字<a href="../../../java/lang/Thread.html#getName--"><code>Thread.getName()</code></a> <em>池-N-thread-M的</em> ，其中<em>N</em>是此工厂的序列号<em>，M</em>是此工厂所创建线程的序列号。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线工厂 
           </dd>
</dl> </li>
</ul> <a name="privilegedThreadFactory--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>privilegedThreadFactory</h4> <pre>public static <a href="../../../java/util/concurrent/ThreadFactory.html" title="interface in java.util.concurrent">ThreadFactory</a> privilegedThreadFactory()</pre>
<div class="block">
<span>返回一个用于创建与当前线程具有相同权限的新线程的线程工厂。</span>
<span>该工厂创建与<a href="../../../java/util/concurrent/Executors.html#defaultThreadFactory--"><code>defaultThreadFactory()</code></a>相同设置的<a href="../../../java/util/concurrent/Executors.html#defaultThreadFactory--">线程</a> ，另外将新线程的AccessControlContext和contextClassLoader设置为与调用此<code>privilegedThreadFactory</code>方法的线程相同。</span>
<span>可以在<a href="../../../java/security/AccessController.html#doPrivileged-java.security.PrivilegedAction-"><code>AccessController.doPrivileged</code></a>操作中创建一个新的<code>privilegedThreadFactory</code> ，设置当前线程的访问控制上下文，以创建具有该操作中所选权限设置的线程。</span>
<p> <span>请注意，虽然在这些线程中运行的任务将具有与当前线程相同的访问控制和类加载器设置，但它们不需要具有相同的<a href="../../../java/lang/ThreadLocal.html" title="java.lang中的类"><code>ThreadLocal</code></a>或<a href="../../../java/lang/InheritableThreadLocal.html" title="java.lang中的类"><code>InheritableThreadLocal</code></a>值。</span> <span>如果需要，可以在使用<a href="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute-java.lang.Thread-java.lang.Runnable-"><code>ThreadPoolExecutor.beforeExecute(Thread, Runnable)</code></a>的<a href="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent中的类"><code>ThreadPoolExecutor</code></a>子类中运行任何任务之前设置或重置线程本地的特定值。</span> <span>此外，如果需要初始化工作线程以与其他指定的线程具有相同的InheritableThreadLocal设置，则可以创建一个自定义ThreadFactory，该线程等待和服务请求创建将继承其值的其他请求。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线工厂 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/security/AccessControlException.html" title="class in java.security">AccessControlException</a></code> - 如果当前访问控制上下文没有获取和设置上下文类加载器的权限 
           </dd>
</dl> </li>
</ul> <a name="callable-java.lang.Runnable-java.lang.Object-">
<!-- --> </a><a name="callable-java.lang.Runnable-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>callable</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; callable(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task,
                                       T result)</pre>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，它运行给定的任务并返回给定的结果。</span>
<span>施加需要方法时这可能是有用<code>Callable</code>到其他无结果的动作。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要运行的任务 
           </dd>
<dd>
<code>result</code> - 结果返回 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可调用对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
</dl> </li>
</ul> <a name="callable-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>callable</h4> <pre>public static <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&gt; callable(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</pre>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，它运行给定的任务并返回<code>null</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 要运行的任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可调用对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
</dl> </li>
</ul> <a name="callable-java.security.PrivilegedAction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>callable</h4> <pre>public static <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&gt; callable(<a href="../../../java/security/PrivilegedAction.html" title="interface in java.security">PrivilegedAction</a>&lt;?&gt; action)</pre>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，它运行给定的特权动作并返回其结果。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>action</code> - 运行的特权操作 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可调用对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果动作为空 
           </dd>
</dl> </li>
</ul> <a name="callable-java.security.PrivilegedExceptionAction-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>callable</h4> <pre>public static <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&gt; callable(<a href="../../../java/security/PrivilegedExceptionAction.html" title="interface in java.security">PrivilegedExceptionAction</a>&lt;?&gt; action)</pre>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，该对象在被调用时运行给定的特权异常操作并返回其结果。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>action</code> - 运行的特权异常操作 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可调用对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果动作为空 
           </dd>
</dl> </li>
</ul> <a name="privilegedCallable-java.util.concurrent.Callable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>privilegedCallable</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; privilegedCallable(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; callable)</pre>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，将在当前访问控制上下文中执行给定的<code>callable</code> 。</span>
<span>通常在<a href="../../../java/security/AccessController.html#doPrivileged-java.security.PrivilegedAction-"><code>AccessController.doPrivileged</code></a>操作中调用此方法来创建可调用的函数，如果可能的话，该方法将在该操作中保留的所选权限设置下执行;</span>
<span>或者如果不可能，抛出一个关联的<a href="../../../java/security/AccessControlException.html" title="java.security中的类"><code>AccessControlException</code></a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 可调用结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>callable</code> - 基础任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可调用对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果可以调用null 
           </dd>
</dl> </li>
</ul> <a name="privilegedCallableUsingCurrentClassLoader-java.util.concurrent.Callable-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>privilegedCallableUsingCurrentClassLoader</h4> <pre>public static &lt;T&gt; <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; privilegedCallableUsingCurrentClassLoader(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; callable)</pre>
<div class="block">
<span>返回一个<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>对象，当被调用时，将在当前访问控制上下文中执行给定的<code>callable</code> ，当前的上下文类加载器作为上下文类加载器。</span>
<span>通常在<a href="../../../java/security/AccessController.html#doPrivileged-java.security.PrivilegedAction-"><code>AccessController.doPrivileged</code></a>操作中调用此方法来创建可调用的<a href="../../../java/security/AccessController.html#doPrivileged-java.security.PrivilegedAction-">应用</a>程序，如果可能，在执行该操作的所选权限设置下执行;</span>
<span>或者如果不可能，抛出一个关联的<a href="../../../java/security/AccessControlException.html" title="java.security中的类"><code>AccessControlException</code></a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 可调用结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>callable</code> - 基础任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可调用对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果可以调用null 
           </dd>
<dd>
<code><a href="../../../java/security/AccessControlException.html" title="class in java.security">AccessControlException</a></code> - 如果当前访问控制上下文没有设置和获取上下文类加载器的权限 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>