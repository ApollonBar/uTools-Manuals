<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util.concurrent 
   </div>
<h2 class="title" title="Class ForkJoinPool">Class ForkJoinPool</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">java.util.concurrent.AbstractExecutorService</a></li>
<li>
<ul class="inheritance">
<li>java.util.concurrent.ForkJoinPool</li>
</ul> </li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../../java/util/concurrent/Executor.html" title="java.util.concurrent中的接口">Executor</a> ， <a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口">ExecutorService</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">ForkJoinPool</span>
extends <a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></pre>
<div class="block">
<span>一个<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>运行<a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a> s。</span>
<span>A <code>ForkJoinPool</code>提供非<code>ForkJoinTask</code>客户<code>ForkJoinPool</code>的入场点，以及管理和监控操作。</span>
<p> <span>一个<code>ForkJoinPool</code>与其他种类的不同<a href="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent中的接口"><code>ExecutorService</code></a>主要凭借<em>用人偷盗</em>的：所有的线程池中试图找到并执行其他活动任务提交到池和/或创建（最终阻塞等待工作，如果不存在）的任务。</span> <span>当大多数任务产生其他子任务（大多数<code>ForkJoinTask</code> ）以及许多小任务从外部客户端提交到池时，这可以实现高效的处理。</span> <span>尤其是在构造函数设置<em>asyncMode</em>为真时， <code>ForkJoinPool</code> S还可能适合于与事件式的任务中使用那些从未加入。</span> </p>
<p> <span>静态<a href="../../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>commonPool()</code></a>可用，适用于大多数应用。</span> <span>公共池被任何未显式提交到指定池的ForkJoinTask使用。</span> <span>使用公共池通常会减少资源使用（其线程在不使用期间缓慢回收，并在后续使用时恢复）。</span> </p>
<p> <span>对于需要单独的或定制的池中的应用程序，一个<code>ForkJoinPool</code>可与给定的目标并行级来构造;</span> <span>默认情况下，等于可用处理器的数量。</span> <span>池尝试通过动态添加，挂起或恢复内部工作线程来维护足够的活动（或可用）线程，即使某些任务停止等待加入其他线程。</span> <span>但是，面对阻塞的I / O或其他非托管同步，不能保证这样的调整。</span> <span>嵌套的<a href="../../../java/util/concurrent/ForkJoinPool.ManagedBlocker.html" title="java.util.concurrent中的接口"><code>ForkJoinPool.ManagedBlocker</code></a>接口可以扩展所容纳的同步类型。</span> </p>
<p> <span>除了执行和生命周期控制方法之外，该类还提供了用于帮助开发，调优和监视fork / join应用程序的状态检查方法（例如<a href="../../../java/util/concurrent/ForkJoinPool.html#getStealCount--"><code>getStealCount()</code></a> ）。</span> <span>此外，方法<a href="../../../java/util/concurrent/ForkJoinPool.html#toString--"><code>toString()</code></a>以方便的形式返回池状态的指示以进行非正式监视。</span> </p>
<p> <span>与其他ExecutorServices的情况一样，下表总结了三个主要任务执行方法。</span> <span>这些设计主要由尚未在当前池中进行fork / join计算的客户端使用。</span> <span>这些方法的主要形式接受的实例<code>ForkJoinTask</code> ，但重载形式也允许的纯混合执行<code>Runnable</code> -或<code>Callable</code> -基础的活动为好。</span> <span>但是，通常情况下，在池中已经执行的任务会使用表中列出的计算内表单，除非使用不通常连接的异步事件式任务，否则在方法选择方面几乎没有区别。</span> </p>
<span> Summary of task execution methods      <b>Call from non-fork/join clients</b> <b>Call from within fork/join computations</b> <b>Arrange async execution</b> <a href="../../../java/util/concurrent/ForkJoinPool.html#execute-java.util.concurrent.ForkJoinTask-"><code>execute(ForkJoinTask)</code></a> <a href="../../../java/util/concurrent/ForkJoinTask.html#fork--"><code>ForkJoinTask.fork()</code></a> <b>Await and obtain result</b> <a href="../../../java/util/concurrent/ForkJoinPool.html#invoke-java.util.concurrent.ForkJoinTask-"><code>invoke(ForkJoinTask)</code></a> <a href="../../../java/util/concurrent/ForkJoinTask.html#invoke--"><code>ForkJoinTask.invoke()</code></a> <b>Arrange exec and obtain Future</b> <a href="../../../java/util/concurrent/ForkJoinPool.html#submit-java.util.concurrent.ForkJoinTask-"><code>submit(ForkJoinTask)</code></a> <a href="../../../java/util/concurrent/ForkJoinTask.html#fork--"><code>ForkJoinTask.fork()</code></a> (ForkJoinTasks <em>are</em> Futures)  </span>
<table border="" cellpadding="3" cellspacing="1">
</table>
<p> <span>公共池默认使用默认参数构建，但这些可以通过设置三个<a href="../../../java/lang/System.html#getProperty-java.lang.String-">system properties来控制</a> ：</span> </p>
<ul>
<li> <span><code>java.util.concurrent.ForkJoinPool.common.parallelism</code> - 并行级别，非负整数</span> </li>
<li> <span><code>java.util.concurrent.ForkJoinPool.common.threadFactory</code> - 类名<a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="java.util.concurrent中的接口"><code>ForkJoinPool.ForkJoinWorkerThreadFactory</code></a></span> </li>
<li> <span><code>java.util.concurrent.ForkJoinPool.common.exceptionHandler</code> - 一个<a href="../../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang中的接口"><code>Thread.UncaughtExceptionHandler</code></a>的类名</span> </li>
</ul>
<span>如果一个<a href="../../../java/lang/SecurityManager.html" title="java.lang中的类"><code>SecurityManager</code></a>存在且没有指定工厂，则默认池使用一个工厂提供的线程不启用<a href="../../../java/security/Permissions.html" title="java.security中的类"><code>Permissions</code></a> 。</span>
<span>系统类加载器用于加载这些类。</span>
<span>建立这些设置有任何错误，使用默认参数。</span>
<span>通过将parallelism属性设置为零，和/或使用可能返回<code>null</code>的工厂，可以禁用或限制公共池中的线程的使用。</span>
<span>但是这样做可能导致未连接的任务永远不会被执行。</span>
<p> <span><b>实现注意事项</b> ：此实现将运行的最大线程数限制为32767.尝试创建大于最大数目的池导致<code>IllegalArgumentException</code> 。</span> </p>
<p> <span>此实现仅在池关闭或内部资源耗尽时拒绝提交的任务（即抛出<a href="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent中的类"><code>RejectedExecutionException</code></a> ）。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.7 
       </dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a></span></code>
<div class="block">
<span>工厂创建新的<a href="../../../java/util/concurrent/ForkJoinWorkerThread.html" title="java.util.concurrent中的类"><code>ForkJoinWorkerThread</code></a> s。</span>
</div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.ManagedBlocker.html" title="interface in java.util.concurrent">ForkJoinPool.ManagedBlocker</a></span></code>
<div class="block">
<span>用于扩展管理并行性的接口，用于在<a href="../../../java/util/concurrent/ForkJoinPool.html" title="java.util.concurrent中的类"><code>ForkJoinPool</code>中</a>运行的任务。</span>
</div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#defaultForkJoinWorkerThreadFactory">defaultForkJoinWorkerThreadFactory</a></span></code>
<div class="block">
              创建一个新的ForkJoinWorkerThread。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#ForkJoinPool--">ForkJoinPool</a></span>()</code>
<div class="block">
              创建 
             <code>ForkJoinPool</code>度等于 
             <a href="../../../java/lang/Runtime.html#availableProcessors--"><code>Runtime.availableProcessors()</code></a> ，使用 
             <a href="../../../java/util/concurrent/ForkJoinPool.html#defaultForkJoinWorkerThreadFactory">default thread factory</a> ，没有UncaughtExceptionHandler和非同步LIFO处理模式。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#ForkJoinPool-int-">ForkJoinPool</a></span>(int parallelism)</code>
<div class="block">
              创建一个 
             <code>ForkJoinPool</code>具有指示的并行级别， 
             <a href="../../../java/util/concurrent/ForkJoinPool.html#defaultForkJoinWorkerThreadFactory">default thread factory</a> ，没有UncaughtExceptionHandler和非同步LIFO处理模式。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#ForkJoinPool-int-java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory-java.lang.Thread.UncaughtExceptionHandler-boolean-">ForkJoinPool</a></span>(int parallelism, <a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a> factory, <a href="../../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> handler, boolean asyncMode)</code>
<div class="block">
              创建一个 
             <code>ForkJoinPool</code>具有给定参数。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#awaitQuiescence-long-java.util.concurrent.TimeUnit-">awaitQuiescence</a></span>(long timeout, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              如果被一个ForkJoinTask调用在这个池中运行，相当于 
             <a href="../../../java/util/concurrent/ForkJoinTask.html#helpQuiesce--"><code>ForkJoinTask.helpQuiesce()</code></a> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#awaitTermination-long-java.util.concurrent.TimeUnit-">awaitTermination</a></span>(long timeout, <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              阻止所有任务在关闭请求完成后执行，或发生超时，或当前线程中断，以先到者为准。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static <a href="../../../java/util/concurrent/ForkJoinPool.html" title="class in java.util.concurrent">ForkJoinPool</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#commonPool--">commonPool</a></span>()</code>
<div class="block">
              返回公共池实例。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#drainTasksTo-java.util.Collection-">drainTasksTo</a></span>(<a href="../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? super <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt;&gt; c)</code>
<div class="block">
              从调度队列中删除所有可用的未执行的提交和分派任务，并将其添加到给定集合中，而不会更改其执行状态。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#execute-java.util.concurrent.ForkJoinTask-">execute</a></span>(<a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt; task)</code>
<div class="block">
              为异步执行给定任务的排列。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#execute-java.lang.Runnable-">execute</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</code>
<div class="block">
              在将来的某个时间执行给定的命令。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getActiveThreadCount--">getActiveThreadCount</a></span>()</code>
<div class="block">
              返回当前正在窃取或执行任务的线程数的估计。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getAsyncMode--">getAsyncMode</a></span>()</code>
<div class="block">
              返回 
             <code>true</code>如果此池使用本地先入先出调度模式，用于从未加入的分叉任务。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getCommonPoolParallelism--">getCommonPoolParallelism</a></span>()</code>
<div class="block">
              返回公共池的目标并行度级别。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getFactory--">getFactory</a></span>()</code>
<div class="block">
              返回用于构建新工人的工厂。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getParallelism--">getParallelism</a></span>()</code>
<div class="block">
              返回此池的目标并行度级别。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getPoolSize--">getPoolSize</a></span>()</code>
<div class="block">
              返回已启动但尚未终止的工作线程数。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getQueuedSubmissionCount--">getQueuedSubmissionCount</a></span>()</code>
<div class="block">
              返回提交给此池尚未开始执行的任务数量的估计。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getQueuedTaskCount--">getQueuedTaskCount</a></span>()</code>
<div class="block">
              返回由工作线程（但不包括提交到池中尚未开始执行的任务）当前在队列中保留的任务总数的估计值。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getRunningThreadCount--">getRunningThreadCount</a></span>()</code>
<div class="block">
              返回等待加入任务或其他受管同步的未阻止的工作线程数的估计。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getStealCount--">getStealCount</a></span>()</code>
<div class="block">
              返回从另一个线程的工作队列中偷取的任务总数的估计值。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="../../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#getUncaughtExceptionHandler--">getUncaughtExceptionHandler</a></span>()</code>
<div class="block">
              返回由于在执行任务时遇到不可恢复的错误而终止的内部工作线程的处理程序。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#hasQueuedSubmissions--">hasQueuedSubmissions</a></span>()</code>
<div class="block">
              返回 
             <code>true</code>如果有提交给该池尚未开始执行任何任务。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>&lt;T&gt; T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#invoke-java.util.concurrent.ForkJoinTask-">invoke</a></span>(<a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt; task)</code>
<div class="block">
              执行给定的任务，在完成后返回其结果。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#invokeAll-java.util.Collection-">invokeAll</a></span>(<a href="../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt;&gt; tasks)</code>
<div class="block">
              执行给定的任务，返回持有他们的状态和结果的所有完成的期货列表。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#isQuiescent--">isQuiescent</a></span>()</code>
<div class="block">
              如果所有工作线程当前处于空闲状态，则返回 
             <code>true</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#isShutdown--">isShutdown</a></span>()</code>
<div class="block">
              如果此池已关闭，则返回 
             <code>true</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#isTerminated--">isTerminated</a></span>()</code>
<div class="block">
              如果所有任务在关闭后完成，则返回 
             <code>true</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#isTerminating--">isTerminating</a></span>()</code>
<div class="block">
              如果 
             <code>true</code>程序已经开始但尚未完成，则返回true。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#managedBlock-java.util.concurrent.ForkJoinPool.ManagedBlocker-">managedBlock</a></span>(<a href="../../../java/util/concurrent/ForkJoinPool.ManagedBlocker.html" title="interface in java.util.concurrent">ForkJoinPool.ManagedBlocker</a> blocker)</code>
<div class="block">
              阻挡符合给定的阻滞剂。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>protected &lt;T&gt; <a href="../../../java/util/concurrent/RunnableFuture.html" title="interface in java.util.concurrent">RunnableFuture</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#newTaskFor-java.util.concurrent.Callable-">newTaskFor</a></span>(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; callable)</code>
<div class="block">
              返回给定可调用任务的 
             <code>RunnableFuture</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>protected &lt;T&gt; <a href="../../../java/util/concurrent/RunnableFuture.html" title="interface in java.util.concurrent">RunnableFuture</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#newTaskFor-java.lang.Runnable-T-">newTaskFor</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> runnable, T value)</code>
<div class="block">
              返回给定的可运行和默认值的 
             <code>RunnableFuture</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>protected <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#pollSubmission--">pollSubmission</a></span>()</code>
<div class="block">
              删除并返回下一个未执行的提交（如果有）。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#shutdown--">shutdown</a></span>()</code>
<div class="block">
              可能启动有序关闭，其中先前提交的任务被执行，但不会接受任何新的任务。 
            </div> </td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code><a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#shutdownNow--">shutdownNow</a></span>()</code>
<div class="block">
              可能尝试取消和/或停止所有任务，并拒绝所有后续提交的任务。 
            </div> </td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#submit-java.util.concurrent.Callable-">submit</a></span>(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; task)</code>
<div class="block">
              提交值返回任务以执行，并返回代表任务待处理结果的Future。 
            </div> </td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#submit-java.util.concurrent.ForkJoinTask-">submit</a></span>(<a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt; task)</code>
<div class="block">
              提交一个ForkJoinTask来执行。 
            </div> </td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code><a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#submit-java.lang.Runnable-">submit</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</code>
<div class="block">
              提交一个可运行的任务执行，并返回一个表示该任务的未来。 
            </div> </td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#submit-java.lang.Runnable-T-">submit</a></span>(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task, T result)</code>
<div class="block">
              提交一个可运行的任务执行，并返回一个表示该任务的未来。 
            </div> </td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/ForkJoinPool.html#toString--">toString</a></span>()</code>
<div class="block">
              返回一个标识此池的字符串，以及它的状态，包括运行状态，并行级和工作和任务计数的指示。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.util.concurrent.AbstractExecutorService">
<!-- --> </a> <h3>Methods inherited from class java.util.concurrent.<a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></h3> <code><a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll-java.util.Collection-long-java.util.concurrent.TimeUnit-">invokeAll</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny-java.util.Collection-">invokeAny</a>, <a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny-java.util.Collection-long-java.util.concurrent.TimeUnit-">invokeAny</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="defaultForkJoinWorkerThreadFactory">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>defaultForkJoinWorkerThreadFactory</h4> <pre>public static final <a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a> defaultForkJoinWorkerThreadFactory</pre>
<div class="block">
<span>创建一个新的ForkJoinWorkerThread。</span>
<span>该工厂被使用，除非在ForkJoinPool构造函数中被覆盖。</span>
</div> </li>
</ul> </li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="ForkJoinPool--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ForkJoinPool</h4> <pre>public ForkJoinPool()</pre>
<div class="block">
            创建一个 
           <code>ForkJoinPool</code>度等于 
           <a href="../../../java/lang/Runtime.html#availableProcessors--"><code>Runtime.availableProcessors()</code></a> ，使用 
           <a href="../../../java/util/concurrent/ForkJoinPool.html#defaultForkJoinWorkerThreadFactory">default thread factory</a> ，没有UncaughtExceptionHandler和非同步LIFO处理模式。 
          </div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且主叫方不允许修改线程，因为它不保留<a href="../../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("modifyThread")</code></span>
</dd>
</dl> </li>
</ul> <a name="ForkJoinPool-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ForkJoinPool</h4> <pre>public ForkJoinPool(int parallelism)</pre>
<div class="block">
            创建具有 
           <code>ForkJoinPool</code>并行级别的 
           <a href="../../../java/util/concurrent/ForkJoinPool.html#defaultForkJoinWorkerThreadFactory">ForkJoinPool，default thread factory</a> ，没有UncaughtExceptionHandler和非同步LIFO处理模式。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>parallelism</code> - 并行级别 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果并行度小于或等于零，或大于实现限制 
           </dd>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且调用者不允许修改线程，因为它不保留<a href="../../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("modifyThread")</code></span>
</dd>
</dl> </li>
</ul> <a name="ForkJoinPool-int-java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory-java.lang.Thread.UncaughtExceptionHandler-boolean-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>ForkJoinPool</h4> <pre>public ForkJoinPool(int parallelism,
                    <a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a> factory,
                    <a href="../../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> handler,
                    boolean asyncMode)</pre>
<div class="block">
            创建一个 
           <code>ForkJoinPool</code>具有给定参数。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>parallelism</code> - 并行级别。</span>
<span>对于默认值，请使用<a href="../../../java/lang/Runtime.html#availableProcessors--"><code>Runtime.availableProcessors()</code></a> 。</span>
</dd>
<dd>
<span><code>factory</code> - 创建新线程的工厂。</span>
<span>默认值为<a href="../../../java/util/concurrent/ForkJoinPool.html#defaultForkJoinWorkerThreadFactory"><code>defaultForkJoinWorkerThreadFactory</code></a> 。</span>
</dd>
<dd>
<span><code>handler</code> - 由于执行任务时遇到不可恢复的错误而终止的内部工作线程的处理程序。</span>
<span>默认值为<code>null</code> 。</span>
</dd>
<dd>
<span><code>asyncMode</code> - 如果为true，请为从未连接的分叉任务建立本地先进先出调度模式。</span>
<span>在工作线程仅处理事件式异步任务的应用程序中，此模式可能比默认的基于本地堆栈的模式更合适。</span>
<span>默认值为<code>false</code> 。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果并行度小于或等于零，或大于实现限制 
           </dd>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果工厂为空 
           </dd>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且主叫方不允许修改线程，因为它不保留<a href="../../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("modifyThread")</code></span>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="commonPool--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>commonPool</h4> <pre>public static <a href="../../../java/util/concurrent/ForkJoinPool.html" title="class in java.util.concurrent">ForkJoinPool</a> commonPool()</pre>
<div class="block">
<span>返回公共池实例。</span>
<span>这个游泳池是静态的;</span>
<span>其运行状态不受尝试<a href="../../../java/util/concurrent/ForkJoinPool.html#shutdown--"><code>shutdown()</code></a>或<a href="../../../java/util/concurrent/ForkJoinPool.html#shutdownNow--"><code>shutdownNow()</code>的影响</a> 。</span>
<span>但是，该池和任何正在进行的处理将在程序<a href="../../../java/lang/System.html#exit-int-"><code>System.exit(int)</code>自动终止</a> 。</span>
<span>在程序终止前依赖于异步任务处理完成的任何程序，应在退出之前调用<code>commonPool().</code> <a href="../../../java/util/concurrent/ForkJoinPool.html#awaitQuiescence-long-java.util.concurrent.TimeUnit-"><code>awaitQuiescence</code></a> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             公共池实例 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="invoke-java.util.concurrent.ForkJoinTask-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>invoke</h4> <pre>public &lt;T&gt; T invoke(<a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt; task)</pre>
<div class="block">
<span>执行给定的任务，在完成后返回其结果。</span>
<span>如果计算遇到未检查的异常或错误，则将其重新定义为此调用的结果。</span>
<span>Rethrown异常的行为与常规异常的方式相同，但如果可能，则包含当前线程以及实际遇到异常的线程的堆栈跟踪（例如使用<code>ex.printStackTrace()</code> ）;</span>
<span>最低限度只有后者。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 任务结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             任务的结果 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="execute-java.util.concurrent.ForkJoinTask-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>execute</h4> <pre>public void execute(<a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt; task)</pre>
<div class="block">
            为异步执行给定任务的排列。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 任务 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="execute-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>execute</h4> <pre>public void execute(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../java/util/concurrent/Executor.html#execute-java.lang.Runnable-">Executor</a></code>复制</span>
</div>
<div class="block">
<span>在将来的某个时间执行给定的命令。</span>
<span>该命令可以在一个新线程，一个合并的线程中或在调用线程中执行，由<code>Executor</code>实现。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 可运行的任务 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="submit-java.util.concurrent.ForkJoinTask-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>submit</h4> <pre>public &lt;T&gt; <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt; submit(<a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt; task)</pre>
<div class="block">
            提交一个ForkJoinTask来执行。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 任务结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 提交的任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             任务 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="submit-java.util.concurrent.Callable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>submit</h4> <pre>public &lt;T&gt; <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt; submit(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; task)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../java/util/concurrent/ExecutorService.html#submit-java.util.concurrent.Callable-">ExecutorService</a></code>复制</span>
</div>
<div class="block">
<span>提交值返回任务以执行，并返回代表任务待处理结果的Future。</span>
<span>未来的<code>get</code>方法将在成功完成后返回任务的结果。</span>
<p> <span>如果您想立即阻止等待任务，您可以使用result = exec.submit(aCallable).get();格式的<code>result = exec.submit(aCallable).get();</code></span> </p>
<p> <span>注意： <a href="../../../java/util/concurrent/Executors.html" title="java.util.concurrent中的类"><code>Executors</code></a>类包括一组可以将一些其他常见的类似闭包的对象（例如<a href="../../../java/security/PrivilegedAction.html" title="java.security中的接口"><code>PrivilegedAction</code>）转换</a>为<a href="../../../java/util/concurrent/Callable.html" title="java.util.concurrent中的接口"><code>Callable</code></a>表单的方法，以便他们可以提交。</span> </p>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/ExecutorService.html#submit-java.util.concurrent.Callable-">submit</a></code>在界面 
            <code><a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code>
</dd>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/AbstractExecutorService.html#submit-java.util.concurrent.Callable-">submit</a></code>在类别 
            <code><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 任务结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 提交的任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个未来的代表，待完成任务 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="submit-java.lang.Runnable-java.lang.Object-">
<!-- --> </a><a name="submit-java.lang.Runnable-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>submit</h4> <pre>public &lt;T&gt; <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt; submit(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task,
                                  T result)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面复制： <code><a href="../../../java/util/concurrent/ExecutorService.html#submit-java.lang.Runnable-T-">ExecutorService</a></code></span>
</div>
<div class="block">
<span>提交一个可运行的任务执行，并返回一个表示该任务的未来。</span>
<span>未来的<code>get</code>方法将在成功完成后返回给定的结果。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/ExecutorService.html#submit-java.lang.Runnable-T-">submit</a></code>在界面 
            <code><a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code>
</dd>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/AbstractExecutorService.html#submit-java.lang.Runnable-T-">submit</a></code>在类别 
            <code><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 提交的任务 
           </dd>
<dd>
<code>result</code> - 结果返回 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个未来的代表，待完成任务 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="submit-java.lang.Runnable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>submit</h4> <pre>public <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt; submit(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> task)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../java/util/concurrent/ExecutorService.html#submit-java.lang.Runnable-">ExecutorService</a></code>复制</span>
</div>
<div class="block">
<span>提交一个可运行的任务执行，并返回一个表示该任务的未来。</span>
<span>未来的<code>get</code>方法将返回<code>null</code> <em>成功</em>完成时。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/ExecutorService.html#submit-java.lang.Runnable-">submit</a></code>在界面 
            <code><a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code>
</dd>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/AbstractExecutorService.html#submit-java.lang.Runnable-">submit</a></code>在类别 
            <code><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></code>
</dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>task</code> - 提交的任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个未来的代表，待完成任务 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务为空 
           </dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="invokeAll-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>invokeAll</h4> <pre>public &lt;T&gt; <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a>&lt;T&gt;&gt; invokeAll(<a href="../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? extends <a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt;&gt; tasks)</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../java/util/concurrent/ExecutorService.html#invokeAll-java.util.Collection-">ExecutorService</a></code>复制</span>
</div>
<div class="block">
<span>执行给定的任务，返回持有他们的状态和结果的所有完成的期货列表。</span>
<span><a href="../../../java/util/concurrent/Future.html#isDone--"><code>Future.isDone()</code></a>是返回列表的每个元素的<code>true</code> 。</span>
<span>请注意， <em>完成的</em>任务可能会正常终止或抛出异常。</span>
<span>如果在此操作正在进行中修改了给定的集合，则此方法的结果是未定义的。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/ExecutorService.html#invokeAll-java.util.Collection-">invokeAll</a></code>在界面 
            <code><a href="../../../java/util/concurrent/ExecutorService.html" title="interface in java.util.concurrent">ExecutorService</a></code>
</dd>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll-java.util.Collection-">invokeAll</a></code> ，在类别 
            <code><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 从任务返回的值的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>tasks</code> - 任务的收集 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示任务的期货列表，按照给定任务列表的迭代器产生的顺序顺序，每个都已完成 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任务或其任何元素是 
            <code>null</code>
</dd>
<dd>
<code><a href="../../../java/util/concurrent/RejectedExecutionException.html" title="class in java.util.concurrent">RejectedExecutionException</a></code> - 如果任何任务无法安排执行 
           </dd>
</dl> </li>
</ul> <a name="getFactory--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getFactory</h4> <pre>public <a href="../../../java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html" title="interface in java.util.concurrent">ForkJoinPool.ForkJoinWorkerThreadFactory</a> getFactory()</pre>
<div class="block">
            返回用于构建新工人的工厂。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             工厂用于建造新工人 
           </dd>
</dl> </li>
</ul> <a name="getUncaughtExceptionHandler--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getUncaughtExceptionHandler</h4> <pre>public <a href="../../../java/lang/Thread.UncaughtExceptionHandler.html" title="interface in java.lang">Thread.UncaughtExceptionHandler</a> getUncaughtExceptionHandler()</pre>
<div class="block">
            返回由于在执行任务时遇到不可恢复的错误而终止的内部工作线程的处理程序。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             处理程序，或 
            <code>null</code>如果没有 
           </dd>
</dl> </li>
</ul> <a name="getParallelism--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getParallelism</h4> <pre>public int getParallelism()</pre>
<div class="block">
            返回此池的目标并行度级别。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             这个池的目标平行度水平 
           </dd>
</dl> </li>
</ul> <a name="getCommonPoolParallelism--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getCommonPoolParallelism</h4> <pre>public static int getCommonPoolParallelism()</pre>
<div class="block">
            返回公共池的目标并行度级别。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             共同池的目标平行度水平 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.8 
           </dd>
</dl> </li>
</ul> <a name="getPoolSize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPoolSize</h4> <pre>public int getPoolSize()</pre>
<div class="block">
<span>返回已启动但尚未终止的工作线程数。</span>
<span>这种方法返回的结果可能与<a href="../../../java/util/concurrent/ForkJoinPool.html#getParallelism--"><code>getParallelism()</code></a>有所不同，当线程被创建以在其他协作阻塞时保持并行性。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             工作线程数 
           </dd>
</dl> </li>
</ul> <a name="getAsyncMode--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAsyncMode</h4> <pre>public boolean getAsyncMode()</pre>
<div class="block">
            返回 
           <code>true</code>如果此池对于从未加入的分叉任务使用本地先进先出调度模式。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果此池使用异步模式 
           </dd>
</dl> </li>
</ul> <a name="getRunningThreadCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getRunningThreadCount</h4> <pre>public int getRunningThreadCount()</pre>
<div class="block">
<span>返回等待加入任务或其他受管同步的未阻止的工作线程数的估计。</span>
<span>此方法可能会高估正在运行的线程数。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             工作线程数 
           </dd>
</dl> </li>
</ul> <a name="getActiveThreadCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getActiveThreadCount</h4> <pre>public int getActiveThreadCount()</pre>
<div class="block">
<span>返回当前正在窃取或执行任务的线程数的估计。</span>
<span>此方法可能会高估活动线程的数量。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             活动线程的数量 
           </dd>
</dl> </li>
</ul> <a name="isQuiescent--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isQuiescent</h4> <pre>public boolean isQuiescent()</pre>
<div class="block">
<span>如果所有工作线程当前处于空闲状态，则返回<code>true</code> 。</span>
<span>空闲的工作者是无法获取执行任务的工作，因为没有可用于从其他线程窃取，并且没有等待提交给池。</span>
<span>这种方法是保守的</span>
<span>它可能不会在所有线程空闲时立即返回<code>true</code> ，但如果线程保持不活动，则最终会变为true。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果所有线程当前都处于空闲状态 
           </dd>
</dl> </li>
</ul> <a name="getStealCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getStealCount</h4> <pre>public long getStealCount()</pre>
<div class="block">
<span>返回从另一个线程的工作队列中偷取的任务总数的估计值。</span>
<span>报告的价值低估了池不是静止时的实际偷窃总数。</span>
<span>该值可能对于监视和调优fork / join程序很有用：通常来说，窃取计数应该足够高以保持线程忙，但足够低以避免线程间的开销和争用。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             偷窃的次数 
           </dd>
</dl> </li>
</ul> <a name="getQueuedTaskCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getQueuedTaskCount</h4> <pre>public long getQueuedTaskCount()</pre>
<div class="block">
<span>返回由工作线程（但不包括提交到池中尚未开始执行的任务）当前在队列中保留的任务总数的估计值。</span>
<span>该值只是通过遍历池中的所有线程获得的近似值。</span>
<span>此方法对于调整任务粒度可能很有用。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             排队任务的数量 
           </dd>
</dl> </li>
</ul> <a name="getQueuedSubmissionCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getQueuedSubmissionCount</h4> <pre>public int getQueuedSubmissionCount()</pre>
<div class="block">
<span>返回提交给此池尚未开始执行的任务数量的估计。</span>
<span>该方法可能需要与提交的数量成比例的时间。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             排队提交的数量 
           </dd>
</dl> </li>
</ul> <a name="hasQueuedSubmissions--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hasQueuedSubmissions</h4> <pre>public boolean hasQueuedSubmissions()</pre>
<div class="block">
            返回 
           <code>true</code>如果有提交给该池尚未开始执行任何任务。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果有任何排队提交 
           </dd>
</dl> </li>
</ul> <a name="pollSubmission--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>pollSubmission</h4> <pre>protected <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt; pollSubmission()</pre>
<div class="block">
<span>删除并返回下一个未执行的提交（如果有）。</span>
<span>此方法在对具有多个池的系统中重新分配工作的此类的扩展中可能很有用。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一次提交，或 
            <code>null</code>如果没有 
           </dd>
</dl> </li>
</ul> <a name="drainTasksTo-java.util.Collection-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>drainTasksTo</h4> <pre>protected int drainTasksTo(<a href="../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;? super <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;?&gt;&gt; c)</pre>
<div class="block">
<span>从调度队列中删除所有可用的未执行的提交和分派任务，并将其添加到给定集合中，而不会更改其执行状态。</span>
<span>这些可能包括人为生成或包装的任务。</span>
<span>该方法仅在池已知静止时被调用。</span>
<span>其他时间的调用可能不会删除所有任务。</span>
<span>尝试向集合<code>c</code>添加元素时遇到的<code>c</code>可能导致在抛出关联的异常时，元素既不在两个集合中，也可能不是两个集合。</span>
<span>如果在操作进行中修改了指定的集合，则此操作的行为是未定义的。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>c</code> - 传输元素的集合 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             转移的元素数量 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
            返回一个标识此池的字符串，以及它的状态，包括运行状态，并行级和工作和任务计数的指示。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个标识这个池的字符串，以及它的状态 
           </dd>
</dl> </li>
</ul> <a name="shutdown--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>shutdown</h4> <pre>public void shutdown()</pre>
<div class="block">
<span>可能启动有序关闭，其中先前提交的任务被执行，但不会接受任何新的任务。</span>
<span>如果这是<a href="../../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>commonPool()</code></a> ，调用对执行状态没有影响，如果已经关闭，则不起作用。</span>
<span>在此方法过程中同时提交的任务可能会被拒绝，也可能不会被拒绝。</span>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理器存在，并且主叫方不允许修改线程，因为它不保留<a href="../../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("modifyThread")</code></span>
</dd>
</dl> </li>
</ul> <a name="shutdownNow--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>shutdownNow</h4> <pre>public <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&gt; shutdownNow()</pre>
<div class="block">
<span>可能尝试取消和/或停止所有任务，并拒绝所有后续提交的任务。</span>
<span>如果这是<a href="../../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>commonPool()</code></a> ，调用对执行状态没有影响，如果已经关闭，则不起作用。</span>
<span>否则，在此方法过程中同时提交或执行的任务可能会被拒绝也可能不会被拒绝。</span>
<span>该方法取消现有和未执行的任务，以便在存在任务依赖性的情况下允许终止。</span>
<span>所以方法总是返回一个空列表（与其他执行程序不同）。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个空的列表 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理员，并且主叫方不允许修改线程，因为它不保留<a href="../../../java/lang/RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("modifyThread")</code></span>
</dd>
</dl> </li>
</ul> <a name="isTerminated--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isTerminated</h4> <pre>public boolean isTerminated()</pre>
<div class="block">
            如果所有任务在关闭后完成，则返回 
           <code>true</code> 。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果所有任务已完成以后关闭 
           </dd>
</dl> </li>
</ul> <a name="isTerminating--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isTerminating</h4> <pre>public boolean isTerminating()</pre>
<div class="block">
<span>如果<code>true</code>程序已经开始但尚未完成，则返回true。</span>
<span>此方法可能对调试有用。</span>
<span>返回<code>true</code>报告了关机后的足够的时间可能表示提交的任务已经忽略或抑制中断，或正在等待I / O，导致执行器不能正常终止。</span>
<span>（请参阅<a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a>的咨询说明，说明任务通常不应该阻塞操作，但如果这样做，则必须中断它们）。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果终止但尚未终止 
           </dd>
</dl> </li>
</ul> <a name="isShutdown--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isShutdown</h4> <pre>public boolean isShutdown()</pre>
<div class="block">
            如果此池已关闭，则返回 
           <code>true</code> 。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果这个池已被关闭 
           </dd>
</dl> </li>
</ul> <a name="awaitTermination-long-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>awaitTermination</h4> <pre>public boolean awaitTermination(long timeout,
                                <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)
                         throws <a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>阻止所有任务在关闭请求完成后执行，或发生超时，或当前线程中断，以先到者为准。</span>
<span>由于<a href="../../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>commonPool()</code></a>永远不会终止，直到程序关闭，当应用到公共池，这种方法相当于<a href="../../../java/util/concurrent/ForkJoinPool.html#awaitQuiescence-long-java.util.concurrent.TimeUnit-"><code>awaitQuiescence(long, TimeUnit)</code></a> ，但总是返回<code>false</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>timeout</code> - 等待的最长时间 
           </dd>
<dd>
<code>unit</code> - 超时参数的时间单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果这个执行者终止了，并且 
            <code>false</code>之前的超时时间是false 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果在等待时中断 
           </dd>
</dl> </li>
</ul> <a name="awaitQuiescence-long-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>awaitQuiescence</h4> <pre>public boolean awaitQuiescence(long timeout,
                               <a href="../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</pre>
<div class="block">
<span>如果被一个ForkJoinTask调用在这个池中运行，相当于<a href="../../../java/util/concurrent/ForkJoinTask.html#helpQuiesce--"><code>ForkJoinTask.helpQuiesce()</code></a> 。</span>
<span>否则，等待和/或尝试协助执行任务，直到此池<a href="../../../java/util/concurrent/ForkJoinPool.html#isQuiescent--"><code>isQuiescent()</code></a>或指示的超时过去。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>timeout</code> - 等待的最长时间 
           </dd>
<dd>
<code>unit</code> - 超时参数的时间单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果静止;</span>
<span><code>false</code>如果超时已过。</span>
</dd>
</dl> </li>
</ul> <a name="managedBlock-java.util.concurrent.ForkJoinPool.ManagedBlocker-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>managedBlock</h4> <pre>public static void managedBlock(<a href="../../../java/util/concurrent/ForkJoinPool.ManagedBlocker.html" title="interface in java.util.concurrent">ForkJoinPool.ManagedBlocker</a> blocker)
                         throws <a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>阻挡符合给定的阻滞剂。</span>
<span>如果当前线程是<a href="../../../java/util/concurrent/ForkJoinWorkerThread.html" title="java.util.concurrent中的类"><code>ForkJoinWorkerThread</code></a> ，如果<a href="../../../java/util/concurrent/ForkJoinWorkerThread.html" title="java.util.concurrent中的类">需要</a> ，该方法可能会排列一个备用线程，以确保当前线程被阻塞时的足够的并行性。</span>
<p> <span>如果呼叫者不是<a href="../../../java/util/concurrent/ForkJoinTask.html" title="java.util.concurrent中的类"><code>ForkJoinTask</code></a> ，则此方法在行为上相当于</span> </p>
<pre>  <span><code> while (!blocker.isReleasable()) if (blocker.block()) return; </code></span> </pre>
<span>如果来电者是<code>ForkJoinTask</code> ，那么这个池可以先扩展，以确保并行性，然后调整。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>blocker</code> - 阻滞剂 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果blocker.block这样做 
           </dd>
</dl> </li>
</ul> <a name="newTaskFor-java.lang.Runnable-java.lang.Object-">
<!-- --> </a><a name="newTaskFor-java.lang.Runnable-T-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>newTaskFor</h4> <pre>protected &lt;T&gt; <a href="../../../java/util/concurrent/RunnableFuture.html" title="interface in java.util.concurrent">RunnableFuture</a>&lt;T&gt; newTaskFor(<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a> runnable,
                                           T value)</pre>
<div class="block">
<span class="descfrmTypeLabel">描述从类别： <code><a href="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor-java.lang.Runnable-T-">AbstractExecutorService</a></code>复制</span>
</div>
<div class="block">
            为给定的可运行和默认值返回 
           <code>RunnableFuture</code> 。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor-java.lang.Runnable-T-">newTaskFor</a></code>在类别 
            <code><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 给定值的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>runnable</code> - 正在包装的可运行任务 
           </dd>
<dd>
<code>value</code> - 返回的未来的默认值 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>RunnableFuture</code> ，当运行时，将运行底层的可运行程序，作为 
            <code>Future</code> ，它将产生给定的值作为其结果，并提供取消基础任务 
           </dd>
</dl> </li>
</ul> <a name="newTaskFor-java.util.concurrent.Callable-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>newTaskFor</h4> <pre>protected &lt;T&gt; <a href="../../../java/util/concurrent/RunnableFuture.html" title="interface in java.util.concurrent">RunnableFuture</a>&lt;T&gt; newTaskFor(<a href="../../../java/util/concurrent/Callable.html" title="interface in java.util.concurrent">Callable</a>&lt;T&gt; callable)</pre>
<div class="block">
<span class="descfrmTypeLabel">描述从类别： <code><a href="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor-java.util.concurrent.Callable-">AbstractExecutorService</a></code>复制</span>
</div>
<div class="block">
            为给定的可调用任务返回 
           <code>RunnableFuture</code> 。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor-java.util.concurrent.Callable-">newTaskFor</a></code>在类别 
            <code><a href="../../../java/util/concurrent/AbstractExecutorService.html" title="class in java.util.concurrent">AbstractExecutorService</a></code>
</dd>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 可调用结果的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>callable</code> - 被打包的 
            <code>callable</code>任务 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个 
            <code>RunnableFuture</code> ，当运行时，将调用底层可调用，并且作为 
            <code>Future</code>将作为其结果产生可调用的结果，并提供取消基础任务 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>