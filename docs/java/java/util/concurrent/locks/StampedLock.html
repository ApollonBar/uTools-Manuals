<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util.concurrent.locks 
   </div>
<h2 class="title" title="Class StampedLock">Class StampedLock</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.concurrent.locks.StampedLock</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../../../java/io/Serializable.html" title="java.io中的接口">Serializable</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">StampedLock</span>
extends <a href="../../../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../../../java/io/Serializable.html" title="interface in java.io">Serializable</a></pre>
<div class="block">
<span>一种基于能力的锁，具有三种模式用于控制读/写访问。</span>
<span>StampedLock的状态由版本和模式组成。</span>
<span>锁定采集方法返回一个表示和控制相对于锁定状态的访问的印记;</span>
<span>这些方法的“尝试”版本可能会返回特殊值为零以表示获取访问失败。</span>
<span>锁定释放和转换方法要求邮票作为参数，如果它们与锁的状态不匹配则失败。</span>
<span>这三种模式是：</span>
<ul>
<li> <span><b>写作。</b></span> <span>方法<a href="../../../../java/util/concurrent/locks/StampedLock.html#writeLock--"><code>writeLock()</code></a>可能阻止等待独占访问，返回可以在方法<a href="../../../../java/util/concurrent/locks/StampedLock.html#unlockWrite-long-"><code>unlockWrite(long)</code></a>中使用的<a href="../../../../java/util/concurrent/locks/StampedLock.html#unlockWrite-long-">邮票</a>来释放锁定。</span> <span>不定时的和定时版本<code>tryWriteLock</code> ，还提供。</span> <span>当锁保持写入模式时，不能获得读取锁定，并且所有乐观读取验证都将失败。</span> </li>
<li> <span><b>读。</b></span> <span>方法<a href="../../../../java/util/concurrent/locks/StampedLock.html#readLock--"><code>readLock()</code></a>可能阻止等待非独占访问，返回可用于方法<a href="../../../../java/util/concurrent/locks/StampedLock.html#unlockRead-long-"><code>unlockRead(long)</code></a>释放锁的<a href="../../../../java/util/concurrent/locks/StampedLock.html#unlockRead-long-">戳记</a> 。</span> <span>不定时的和定时版本<code>tryReadLock</code> ，还提供。</span> </li>
<li> <span><b>乐观阅读</b></span> <span>方法<a href="../../../../java/util/concurrent/locks/StampedLock.html#tryOptimisticRead--"><code>tryOptimisticRead()</code></a>只有当锁当前未保持在写入模式<a href="../../../../java/util/concurrent/locks/StampedLock.html#tryOptimisticRead--">时才</a>返回非零标记。</span> <span>方法<a href="../../../../java/util/concurrent/locks/StampedLock.html#validate-long-"><code>validate(long)</code></a>返回true，如果在获取给定的邮票时尚未在写入模式中获取锁定。</span> <span>这种模式可以被认为是一个非常弱的版本的读锁，可以随时由作家打破。</span> <span>对简单的只读代码段使用乐观模式通常会减少争用并提高吞吐量。</span> <span>然而，其使用本质上是脆弱的。</span> <span>乐观阅读部分只能读取字段并将其保存在局部变量中，以供后验证使用。</span> <span>以乐观模式读取的字段可能会非常不一致，因此只有在熟悉数据表示以检查一致性和/或重复调用方法<code>validate()</code>时，使用情况才适用。</span> <span>例如，当首次读取对象或数组引用，然后访问其字段，元素或方法之一时，通常需要这样的步骤。</span> </li>
</ul>
<p> <span>此类还支持有条件地在三种模式下提供转换的方法。</span> <span>例如，方法<a href="../../../../java/util/concurrent/locks/StampedLock.html#tryConvertToWriteLock-long-"><code>tryConvertToWriteLock(long)</code></a>尝试“升级”模式，如果（1）在读取模式下已经在写入模式（2）中并且没有其他读取器或（3）处于乐观模式并且锁可用，则返回有效写入戳记。</span> <span>这些方法的形式旨在帮助减少在基于重试的设计中出现的一些代码膨胀。</span> </p>
<p> <span>StampedLocks设计用作线程安全组件开发中的内部实用程序。</span> <span>他们的使用依赖于他们保护的数据，对象和方法的内部属性的知识。</span> <span>它们不是可重入的，所以锁定的机构不应该调用其他可能尝试重新获取锁的未知方法（尽管您可以将戳记传递给可以使用或转换它的其他方法）。</span> <span>读锁定模式的使用依赖于相关的代码段是无副作用的。</span> <span>未经验证的乐观阅读部分不能调用不知道容忍潜在不一致的方法。</span> <span>邮票使用有限表示，并且不是加密安全的（即，有效的邮票可能是可猜测的）。</span> <span>邮票值可以在连续运行一年后（不早于）回收。</span> <span>不超过此期限使用或验证的邮票可能无法正确验证。</span> <span>StampedLocks是可序列化的，但总是反序列化为初始解锁状态，因此它们对于远程锁定无用。</span> </p>
<p> <span>StampedLock的调度策略不一致优先于读者，反之亦然。</span> <span>所有“尝试”方法都是尽力而为，并不一定符合任何调度或公平政策。</span> <span>用于获取或转换锁定的任何“try”方法的零返回不携带关于锁的状态的任何信息;</span> <span>随后的调用可能会成功。</span> </p>
<p> <span>因为它支持跨多个锁模式的协调使用，所以该类不直接实现<a href="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks中的接口"><code>Lock</code></a>或<a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks中的接口"><code>ReadWriteLock</code></a>接口。</span> <span>然而，StampedLock可以看作<a href="../../../../java/util/concurrent/locks/StampedLock.html#asReadLock--"><code>asReadLock()</code></a> ， <a href="../../../../java/util/concurrent/locks/StampedLock.html#asWriteLock--"><code>asWriteLock()</code></a> ，或<a href="../../../../java/util/concurrent/locks/StampedLock.html#asReadWriteLock--"><code>asReadWriteLock()</code></a>中，仅需要在一组相关联的功能的应用程序。</span> </p>
<p> <span><b>样品用法。</b></span> <span>下面说明了一个维护简单二维点的类中的一些使用习语。</span> <span>示例代码说明了一些try / catch约定，即使这些惯例在这里不是严格需要的，因为它们的身体中不会发生异常。</span> <br/></p>
<pre>  <span><code> class Point { private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { // an exclusively locked method long stamp = sl.writeLock(); try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); } } double distanceFromOrigin() { // A read-only method long stamp = sl.tryOptimisticRead(); double currentX = x, currentY = y; if (!sl.validate(stamp)) { stamp = sl.readLock(); try { currentX = x; currentY = y; } finally { sl.unlockRead(stamp); } } return Math.sqrt(currentX * currentX + currentY * currentY); } void moveIfAtOrigin(double newX, double newY) { // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try { while (x == 0.0 &amp;&amp; y == 0.0) { long ws = sl.tryConvertToWriteLock(stamp); if (ws != 0L) { stamp = ws; x = newX; y = newY; break; } else { sl.unlockRead(stamp); stamp = sl.writeLock(); } } } finally { sl.unlock(stamp); } } }</code></span> </pre>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.8 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../../serialized-form.html#java.util.concurrent.locks.StampedLock">Serialized Form</a>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#StampedLock--">StampedLock</a></span>()</code>
<div class="block">
              创建一个新的锁，最初处于未锁定状态。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../../../java/util/concurrent/locks/Lock.html" title="interface in java.util.concurrent.locks">Lock</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#asReadLock--">asReadLock</a></span>()</code>
<div class="block">
<span>返回此StampedLock的一个简单的<a href="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks中的接口"><code>Lock</code></a>视图，其中<a href="../../../../java/util/concurrent/locks/Lock.html#lock--"><code>Lock.lock()</code></a>方法映射到<a href="../../../../java/util/concurrent/locks/StampedLock.html#readLock--"><code>readLock()</code></a> ，并且类似地用于其他方法。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="interface in java.util.concurrent.locks">ReadWriteLock</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#asReadWriteLock--">asReadWriteLock</a></span>()</code>
<div class="block">
<span>返回此StampedLock的<a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks中的接口"><code>ReadWriteLock</code></a>视图，其中<a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock--"><code>ReadWriteLock.readLock()</code></a>方法映射到<a href="../../../../java/util/concurrent/locks/StampedLock.html#asReadLock--"><code>asReadLock()</code>，<code>ReadWriteLock.writeLock()</code></a> <a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock--">转换</a>为<a href="../../../../java/util/concurrent/locks/StampedLock.html#asWriteLock--"><code>asWriteLock()</code></a> 。</span>
</div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../../../java/util/concurrent/locks/Lock.html" title="interface in java.util.concurrent.locks">Lock</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#asWriteLock--">asWriteLock</a></span>()</code>
<div class="block">
<span>返回此StampedLock的一个简单的<a href="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks中的接口"><code>Lock</code></a>视图，其中<a href="../../../../java/util/concurrent/locks/Lock.html#lock--"><code>Lock.lock()</code></a>方法映射到<a href="../../../../java/util/concurrent/locks/StampedLock.html#writeLock--"><code>writeLock()</code></a> ，并且类似地用于其他方法。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#getReadLockCount--">getReadLockCount</a></span>()</code>
<div class="block">
              查询为此锁持有的读取锁的数量。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#isReadLocked--">isReadLocked</a></span>()</code>
<div class="block">
              返回 
             <code>true</code>如果锁当前是非排他地。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#isWriteLocked--">isWriteLocked</a></span>()</code>
<div class="block">
              返回 
             <code>true</code>如果锁当前是唯一的。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#readLock--">readLock</a></span>()</code>
<div class="block">
              不排他地获取锁定，如有必要，阻塞。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#readLockInterruptibly--">readLockInterruptibly</a></span>()</code>
<div class="block">
              非排他性地获取锁定，如有必要，阻塞，直到可用或当前线程中断。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="../../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#toString--">toString</a></span>()</code>
<div class="block">
              返回一个标识此锁的字符串以及其锁定状态。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryConvertToOptimisticRead-long-">tryConvertToOptimisticRead</a></span>(long stamp)</code>
<div class="block">
              如果锁定状态符合给定的印记，则如果印记表示持有锁定，则释放它并返回观察印记。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryConvertToReadLock-long-">tryConvertToReadLock</a></span>(long stamp)</code>
<div class="block">
              如果锁定状态与给定的标记匹配，则执行以下操作之一。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryConvertToWriteLock-long-">tryConvertToWriteLock</a></span>(long stamp)</code>
<div class="block">
              如果锁定状态与给定的标记匹配，则执行以下操作之一。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryOptimisticRead--">tryOptimisticRead</a></span>()</code>
<div class="block">
              返回可以稍后验证的印记，如果专门锁定则返回零。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryReadLock--">tryReadLock</a></span>()</code>
<div class="block">
              非专门获取锁，如果它立即可用。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryReadLock-long-java.util.concurrent.TimeUnit-">tryReadLock</a></span>(long time, <a href="../../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              如果在给定时间内可用，并且当前线程未被中断，则非排他性地获取锁。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryUnlockRead--">tryUnlockRead</a></span>()</code>
<div class="block">
              释放读锁定的一个保持位，如果保持，而不需要戳记值。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryUnlockWrite--">tryUnlockWrite</a></span>()</code>
<div class="block">
              释放写入锁定，如果被保留，而不需要标记值。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryWriteLock--">tryWriteLock</a></span>()</code>
<div class="block">
              专门获取锁，如果它立即可用。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#tryWriteLock-long-java.util.concurrent.TimeUnit-">tryWriteLock</a></span>(long time, <a href="../../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)</code>
<div class="block">
              如果在给定时间内可用，并且当前线程未被中断，则专门获取该锁。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#unlock-long-">unlock</a></span>(long stamp)</code>
<div class="block">
              如果锁定状态与给定的标记匹配，则释放相应的锁定模式。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#unlockRead-long-">unlockRead</a></span>(long stamp)</code>
<div class="block">
              如果锁定状态与给定的标记匹配，则释放非排他锁。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#unlockWrite-long-">unlockWrite</a></span>(long stamp)</code>
<div class="block">
              如果锁定状态与给定的邮票相匹配，则释放排他锁。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#validate-long-">validate</a></span>(long stamp)</code>
<div class="block">
              如果从发布给定邮票以来没有专门获取锁，则返回true。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#writeLock--">writeLock</a></span>()</code>
<div class="block">
              专门获取锁定，如有必要，阻塞。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/StampedLock.html#writeLockInterruptibly--">writeLockInterruptibly</a></span>()</code>
<div class="block">
              专门获取锁定，如有必要，阻塞，直到可用或当前线程中断。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="StampedLock--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>StampedLock</h4> <pre>public StampedLock()</pre>
<div class="block">
            创建一个新的锁，最初处于未锁定状态。 
          </div> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="writeLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>writeLock</h4> <pre>public long writeLock()</pre>
<div class="block">
            专门获取锁定，如有必要，阻塞。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票 
           </dd>
</dl> </li>
</ul> <a name="tryWriteLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryWriteLock</h4> <pre>public long tryWriteLock()</pre>
<div class="block">
            专门获取锁，如果它立即可用。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票，如果锁不可用，则为零 
           </dd>
</dl> </li>
</ul> <a name="tryWriteLock-long-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryWriteLock</h4> <pre>public long tryWriteLock(long time,
                         <a href="../../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)
                  throws <a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>如果在给定时间内可用，并且当前线程未被中断，则专门获取该锁。</span>
<span>在超时和中断情况下的行为匹配方法<a href="../../../../java/util/concurrent/locks/Lock.html#tryLock-long-java.util.concurrent.TimeUnit-"><code>Lock.tryLock(long,TimeUnit)</code>指定</a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>time</code> - 等待锁的最长时间 
           </dd>
<dd>
<code>unit</code> - 
            <code>time</code>参数的时间单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票，如果锁不可用，则为零 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果当前线程在获取锁定之前中断 
           </dd>
</dl> </li>
</ul> <a name="writeLockInterruptibly--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>writeLockInterruptibly</h4> <pre>public long writeLockInterruptibly()
                            throws <a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>专门获取锁定，如有必要，阻塞，直到可用或当前线程中断。</span>
<span>中断行为符合方法<a href="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly--"><code>Lock.lockInterruptibly()</code>规定的行为</a> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果当前线程在获取锁定之前中断 
           </dd>
</dl> </li>
</ul> <a name="readLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>readLock</h4> <pre>public long readLock()</pre>
<div class="block">
            不排他地获取锁定，如有必要，阻塞。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票 
           </dd>
</dl> </li>
</ul> <a name="tryReadLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryReadLock</h4> <pre>public long tryReadLock()</pre>
<div class="block">
            非专门获取锁，如果它立即可用。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票，如果锁不可用，则为零 
           </dd>
</dl> </li>
</ul> <a name="tryReadLock-long-java.util.concurrent.TimeUnit-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryReadLock</h4> <pre>public long tryReadLock(long time,
                        <a href="../../../../java/util/concurrent/TimeUnit.html" title="enum in java.util.concurrent">TimeUnit</a> unit)
                 throws <a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>如果在给定时间内可用，并且当前线程未被中断，则非排他性地获取锁。</span>
<span>超时和中断下的行为匹配方法<a href="../../../../java/util/concurrent/locks/Lock.html#tryLock-long-java.util.concurrent.TimeUnit-"><code>Lock.tryLock(long,TimeUnit)</code>指定</a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>time</code> - 等待锁的最长时间 
           </dd>
<dd>
<code>unit</code> - 
            <code>time</code>参数的时间单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票，如果锁不可用，则为零 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果当前线程在获取锁定之前中断 
           </dd>
</dl> </li>
</ul> <a name="readLockInterruptibly--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>readLockInterruptibly</h4> <pre>public long readLockInterruptibly()
                           throws <a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></pre>
<div class="block">
<span>非排他性地获取锁定，如有必要，阻塞，直到可用或当前线程中断。</span>
<span>中断行为符合方法<a href="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly--"><code>Lock.lockInterruptibly()</code>规定的行为</a> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可用于解锁或转换模式的邮票 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/InterruptedException.html" title="class in java.lang">InterruptedException</a></code> - 如果当前线程在获取锁之前中断 
           </dd>
</dl> </li>
</ul> <a name="tryOptimisticRead--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryOptimisticRead</h4> <pre>public long tryOptimisticRead()</pre>
<div class="block">
            返回可以稍后验证的印记，如果专门锁定则返回零。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             邮票，或零，如果专门锁定 
           </dd>
</dl> </li>
</ul> <a name="validate-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>validate</h4> <pre>public boolean validate(long stamp)</pre>
<div class="block">
<span>如果从发布给定邮票以来没有专门获取锁，则返回true。</span>
<span>如果邮票为零，则总是返回false。</span>
<span>如果邮票代表当前持有的锁，则始终返回true。</span>
<span>使用未从<a href="../../../../java/util/concurrent/locks/StampedLock.html#tryOptimisticRead--"><code>tryOptimisticRead()</code></a>获取的值或此锁定的锁定方法调用此方法没有定义的效果或结果。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>stamp</code> - 邮票 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span><code>true</code>如果锁定自发行给定邮票以来没有被专门获取;</span>
<span>否则假</span>
</dd>
</dl> </li>
</ul> <a name="unlockWrite-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unlockWrite</h4> <pre>public void unlockWrite(long stamp)</pre>
<div class="block">
            如果锁定状态与给定的邮票相匹配，则释放排他锁。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>stamp</code> - 通过写锁操作返回的邮票 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/IllegalMonitorStateException.html" title="class in java.lang">IllegalMonitorStateException</a></code> - 如果邮票与此锁的当前状态不匹配 
           </dd>
</dl> </li>
</ul> <a name="unlockRead-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unlockRead</h4> <pre>public void unlockRead(long stamp)</pre>
<div class="block">
            如果锁定状态与给定的标记匹配，则释放非排他锁。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>stamp</code> - 通过读锁操作返回的邮票 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/IllegalMonitorStateException.html" title="class in java.lang">IllegalMonitorStateException</a></code> - 如果邮票与此锁的当前状态不匹配 
           </dd>
</dl> </li>
</ul> <a name="unlock-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unlock</h4> <pre>public void unlock(long stamp)</pre>
<div class="block">
            如果锁定状态与给定的标记匹配，则释放相应的锁定模式。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>stamp</code> - 由锁定操作返回的邮票 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/IllegalMonitorStateException.html" title="class in java.lang">IllegalMonitorStateException</a></code> - 如果邮票与此锁的当前状态不匹配 
           </dd>
</dl> </li>
</ul> <a name="tryConvertToWriteLock-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryConvertToWriteLock</h4> <pre>public long tryConvertToWriteLock(long stamp)</pre>
<div class="block">
<span>如果锁定状态与给定的标记匹配，则执行以下操作之一。</span>
<span>如果邮票表示持有写锁，则返回。</span>
<span>或者，如果读取锁定，如果写入锁定可用，则释放读取锁定并返回写入戳记。</span>
<span>或者，如果乐观阅读，只有在立即可用的情况下才会返回写入戳。</span>
<span>在所有其他情况下，此方法返回零。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>stamp</code> - 邮票 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             有效写入戳记，或失败时为零 
           </dd>
</dl> </li>
</ul> <a name="tryConvertToReadLock-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryConvertToReadLock</h4> <pre>public long tryConvertToReadLock(long stamp)</pre>
<div class="block">
<span>如果锁定状态与给定的标记匹配，则执行以下操作之一。</span>
<span>如果邮票表示持有写锁，则释放它并获取读锁。</span>
<span>或者，如果读锁，返回。</span>
<span>或者，如果乐观读取，只有在立即可用时才获取读锁定并返回读取戳。</span>
<span>在所有其他情况下，此方法返回零。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>stamp</code> - 邮票 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             有效的读取戳记，或者失败时为零 
           </dd>
</dl> </li>
</ul> <a name="tryConvertToOptimisticRead-long-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryConvertToOptimisticRead</h4> <pre>public long tryConvertToOptimisticRead(long stamp)</pre>
<div class="block">
<span>如果锁定状态符合给定的印记，则如果印记表示持有锁定，则释放它并返回观察印记。</span>
<span>或者，如果乐观阅读，如果验证返回。</span>
<span>在所有其他情况下，此方法返回零，因此可能作为“tryUnlock”的形式有用。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>stamp</code> - 邮票 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             有效的乐观阅读印记，或失败时为零 
           </dd>
</dl> </li>
</ul> <a name="tryUnlockWrite--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryUnlockWrite</h4> <pre>public boolean tryUnlockWrite()</pre>
<div class="block">
<span>释放写入锁定，如果被保留，而不需要标记值。</span>
<span>此方法可能对错误后的恢复有用。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果锁被保持，否则为false 
           </dd>
</dl> </li>
</ul> <a name="tryUnlockRead--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tryUnlockRead</h4> <pre>public boolean tryUnlockRead()</pre>
<div class="block">
<span>释放读锁定的一个保持位，如果保持，而不需要戳记值。</span>
<span>此方法可能对错误后的恢复有用。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果读取锁定，则为 
            <code>true</code> ，否则为false 
           </dd>
</dl> </li>
</ul> <a name="isWriteLocked--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isWriteLocked</h4> <pre>public boolean isWriteLocked()</pre>
<div class="block">
            返回 
           <code>true</code>如果锁目前是唯一的。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果锁目前是唯一的 
           </dd>
</dl> </li>
</ul> <a name="isReadLocked--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isReadLocked</h4> <pre>public boolean isReadLocked()</pre>
<div class="block">
            返回 
           <code>true</code>如果锁当前非排他地。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果锁当前是非排他性的 
           </dd>
</dl> </li>
</ul> <a name="getReadLockCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getReadLockCount</h4> <pre>public int getReadLockCount()</pre>
<div class="block">
<span>查询为此锁持有的读取锁的数量。</span>
<span>该方法设计用于监控系统状态，不用于同步控制。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             持有的读取锁的数量 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
<span>返回一个标识此锁的字符串以及其锁定状态。</span>
<span>括号中的状态包括字符串<code>"Unlocked"</code>或字符串<code>"Write-locked"</code>或字符串<code>"Read-locks:"</code>后跟当前持有的读锁定数。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             标识此锁的字符串以及其锁定状态 
           </dd>
</dl> </li>
</ul> <a name="asReadLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asReadLock</h4> <pre>public <a href="../../../../java/util/concurrent/locks/Lock.html" title="interface in java.util.concurrent.locks">Lock</a> asReadLock()</pre>
<div class="block">
<span>返回此StampedLock的一个简单的<a href="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks中的接口"><code>Lock</code></a>视图，其中<a href="../../../../java/util/concurrent/locks/Lock.html#lock--"><code>Lock.lock()</code></a>方法映射到<a href="../../../../java/util/concurrent/locks/StampedLock.html#readLock--"><code>readLock()</code></a> ，其他方法类似。</span>
<span>返回的Lock不支持<a href="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks中的接口"><code>Condition</code></a> ;</span>
<span>方法<a href="../../../../java/util/concurrent/locks/Lock.html#newCondition--"><code>Lock.newCondition()</code></a>抛出<code>UnsupportedOperationException</code> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             锁 
           </dd>
</dl> </li>
</ul> <a name="asWriteLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>asWriteLock</h4> <pre>public <a href="../../../../java/util/concurrent/locks/Lock.html" title="interface in java.util.concurrent.locks">Lock</a> asWriteLock()</pre>
<div class="block">
<span>返回此StampedLock的一个平面<a href="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks中的接口"><code>Lock</code></a>视图，其中<a href="../../../../java/util/concurrent/locks/Lock.html#lock--"><code>Lock.lock()</code></a>方法映射到<a href="../../../../java/util/concurrent/locks/StampedLock.html#writeLock--"><code>writeLock()</code></a> ，并且类似地用于其他方法。</span>
<span>返回的Lock不支持<a href="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks中的接口"><code>Condition</code></a> ;</span>
<span>方法<a href="../../../../java/util/concurrent/locks/Lock.html#newCondition--"><code>Lock.newCondition()</code></a>抛出<code>UnsupportedOperationException</code> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             锁 
           </dd>
</dl> </li>
</ul> <a name="asReadWriteLock--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>asReadWriteLock</h4> <pre>public <a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="interface in java.util.concurrent.locks">ReadWriteLock</a> asReadWriteLock()</pre>
<div class="block">
<span>返回一个<a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks中的接口"><code>ReadWriteLock</code></a>视图此StampedLock其中的<a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock--"><code>ReadWriteLock.readLock()</code></a>方法被映射到<a href="../../../../java/util/concurrent/locks/StampedLock.html#asReadLock--"><code>asReadLock()</code></a>和<a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock--"><code>ReadWriteLock.writeLock()</code></a>至<a href="../../../../java/util/concurrent/locks/StampedLock.html#asWriteLock--"><code>asWriteLock()</code></a> 。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             the lock 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>