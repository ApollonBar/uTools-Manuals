<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.util.concurrent.locks 
   </div>
<h2 class="title" title="Class ReentrantReadWriteLock">Class ReentrantReadWriteLock</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.util.concurrent.locks.ReentrantReadWriteLock</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../../../java/io/Serializable.html" title="java.io中的接口">Serializable</a> ， <a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks中的接口">ReadWriteLock</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">ReentrantReadWriteLock</span>
extends <a href="../../../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="interface in java.util.concurrent.locks">ReadWriteLock</a>, <a href="../../../../java/io/Serializable.html" title="interface in java.io">Serializable</a></pre>
<div class="block">
<span><code>ReadWriteLock</code>的一个<a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks中的接口">实现</a>支持类似的语义到<a href="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks中的类"><code>ReentrantLock</code></a> 。</span>
<p> <span>此类具有以下属性：</span> </p>
<ul>
<li> <span><b>收购令</b></span> <p> <span>此类不会强加读卡器或写入器优先顺序锁定访问。</span> <span>但是，它确实支持可选的<em>公平</em>政策。</span> </p>
<dl>
<dt>
<span><b><i>非公平模式（默认）</i></b></span>
</dt>
<dd>
<span>当被构造为不公平（默认）时，进入读写锁定的顺序是未指定的，受到重入限制。</span>
<span>持续竞争的非空格锁可能无限期地推迟一个或多个读卡器或写入器线程，但通常具有比公平锁定更高的吞吐量。</span>
</dd>
<dt>
<span><b><i>公平模式</i></b></span>
</dt>
<dd>
<span>当公平地构建时，线程使用近似到达订单策略来争取进入。</span>
<span>当释放当前持有的锁时，最长等待的单个写入器线程将被分配写入锁定，或者如果有一组读取器线程等待比所有等待写入器线程长的时间，则该组将被分配读取锁定。</span>
<p> <span>尝试获取公平读锁（不可重入）的线程将阻塞，如果写锁定或有等待的写入程序线程。</span> <span>直到最旧的当前正在等待的写入程序线程获取并释放写入锁之后，该线程才会获取读锁定。</span> <span>当然，如果一个等待的作家放弃了等待，留下一个或多个阅读器线程作为队列中最长的服务器，其中写锁定空闲，那么这些读取器将被分配读取锁定。</span> </p>
<p> <span>尝试获取公平写入锁（非重入）的线程将阻止，除非读锁定和写锁定都是空闲的（这意味着没有等待线程）。</span> <span>（请注意，无阻塞<a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html#tryLock--"><code>ReentrantReadWriteLock.ReadLock.tryLock()</code></a>和<a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock--"><code>ReentrantReadWriteLock.WriteLock.tryLock()</code></a>方法不<a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock--">符合</a>此公平的设置，如果可能，将立即获取锁定，而不管等待线程。）</span> </p>
<p></p>
</dd>
</dl></li>
<li> <span><b>可重入</b></span> <p> <span>这把锁既让读者和作家重新获取读取或写入锁在风格<a href="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks中的类"><code>ReentrantLock</code></a> 。</span> <span>在写入线程所持有的所有写入锁已经被释放之前，不允许非重入读取器。</span> </p><p> <span>另外，写入器可以获取读锁，但反之亦然。</span> <span>在其他应用程序中，当在执行在读锁定下执行读取的方法的调用或回调期间保留写入锁时，重入可能是有用的。</span> <span>如果读者尝试获取写入锁定，它将永远不会成功。</span> </p></li>
<li> <span><b>锁定降级</b></span> <p> <span>重入还允许通过获取写入锁定，然后读取锁定然后释放写入锁定从写入锁定到读取锁定。</span> <span>但是，从读锁定升级到写锁是<b>不可能</b>的。</span> </p></li>
<li> <span><b>中断锁获取</b></span> <p> <span>读取锁定和写入锁定在锁定采集期间都支持中断。</span> </p></li>
<li> <span><b><a href="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks中的接口"><code>Condition</code></a>支持</b></span> <p> <span>写入锁提供了一个<a href="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks中的接口"><code>Condition</code></a>实现，其行为以同样的方式，相对于写入锁定，为<a href="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks中的接口"><code>Condition</code></a>所提供的实施<a href="../../../../java/util/concurrent/locks/ReentrantLock.html#newCondition--"><code>ReentrantLock.newCondition()</code></a>确实为<a href="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks中的类"><code>ReentrantLock</code></a> 。</span> <span>这个<a href="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks中的接口"><code>Condition</code></a>当然只能用于写锁。</span> </p><p> <span>读锁不支持<a href="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks中的接口"><code>Condition</code></a>和<code>readLock().newCondition()</code>投掷<code>UnsupportedOperationException</code> 。</span> </p></li>
<li> <span><b>仪器仪表</b></span> <p> <span>该类支持确定锁是否被保持或竞争的方法。</span> <span>这些方法设计用于监视系统状态，而不是进行同步控制。</span> </p></li>
</ul>
<p> <span>此类的序列化与内置锁的操作方式相同：反序列化锁处于未锁定状态，无论其序列化时的状态如何。</span> </p>
<p> <span><b>示例用法</b></span> <span>这是一个代码草图，显示了如何在更新缓存后执行锁定降级（异常处理在以非嵌套方式处理多个锁时尤为棘手）：</span> </p>
<pre>  <span><code> class CachedData { Object data; volatile boolean cacheValid; final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() { rwl.readLock().lock(); if (!cacheValid) { // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try { // Recheck state because another thread might have // acquired write lock and changed state before we did. if (!cacheValid) { data = ... cacheValid = true; } // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); } finally { rwl.writeLock().unlock(); // Unlock write, still hold read } } try { use(data); } finally { rwl.readLock().unlock(); } } }</code></span> </pre>
<span>ReentrantReadWriteLocks可用于改进某些类型集合的某些用途中的并发性。</span>
<span>这通常只有当集合被预期为较大时才能访问，比读者线程更多的读者线程访问，并且需要超出同步开销的开销的操作。</span>
<span>例如，这里是一个使用TreeMap的类，该类将被大量并且被同时访问。</span>
<pre>  <span><code> class RWDictionary { private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;(); private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); private final Lock r = rwl.readLock(); private final Lock w = rwl.writeLock(); public Data get(String key) { r.lock(); try { return m.get(key); } finally { r.unlock(); } } public String[] allKeys() { r.lock(); try { return m.keySet().toArray(); } finally { r.unlock(); } } public Data put(String key, Data value) { w.lock(); try { return m.put(key, value); } finally { w.unlock(); } } public void clear() { w.lock(); try { m.clear(); } finally { w.unlock(); } } }</code></span> </pre>
<h3> <span>实施说明</span> </h3>
<p> <span>此锁最多支持65535个递归写锁和65535个读锁。</span> <span>尝试超过这些限制导致<a href="../../../../java/lang/Error.html" title="java.lang中的类"><code>Error</code></a>从锁定方法抛出。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.5 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../../serialized-form.html#java.util.concurrent.locks.ReentrantReadWriteLock">Serialized Form</a>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="class in java.util.concurrent.locks">ReentrantReadWriteLock.ReadLock</a></span></code>
<div class="block">
              该锁由方法 
             <a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#readLock--"><code>readLock()</code></a>返回。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="class in java.util.concurrent.locks">ReentrantReadWriteLock.WriteLock</a></span></code>
<div class="block">
              该锁由方法 
             <a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock--"><code>writeLock()</code></a>返回。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock--">ReentrantReadWriteLock</a></span>()</code>
<div class="block">
              创建一个新的 
             <code>ReentrantReadWriteLock</code>与默认（非空）订购属性。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock-boolean-">ReentrantReadWriteLock</a></span>(boolean fair)</code>
<div class="block">
              创建一个新的 
             <code>ReentrantReadWriteLock</code>与给定的公平政策。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>protected <a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getOwner--">getOwner</a></span>()</code>
<div class="block">
              返回当前拥有写锁的线程，如果不拥有，则返回 
             <code>null</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedReaderThreads--">getQueuedReaderThreads</a></span>()</code>
<div class="block">
              返回一个包含可能正在等待获取读取锁的线程的集合。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedThreads--">getQueuedThreads</a></span>()</code>
<div class="block">
              返回一个包含可能正在等待获取读取或写入锁定的线程的集合。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedWriterThreads--">getQueuedWriterThreads</a></span>()</code>
<div class="block">
              返回一个包含可能正在等待获取写入锁的线程的集合。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueueLength--">getQueueLength</a></span>()</code>
<div class="block">
              返回等待获取读取或写入锁定的线程数的估计。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getReadHoldCount--">getReadHoldCount</a></span>()</code>
<div class="block">
              查询当前线程对此锁的可重入读取保留数。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getReadLockCount--">getReadLockCount</a></span>()</code>
<div class="block">
              查询为此锁持有的读取锁的数量。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitingThreads-java.util.concurrent.locks.Condition-">getWaitingThreads</a></span>(<a href="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</a> condition)</code>
<div class="block">
              返回包含可能在与写锁相关联的给定条件下等待的线程的集合。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitQueueLength-java.util.concurrent.locks.Condition-">getWaitQueueLength</a></span>(<a href="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</a> condition)</code>
<div class="block">
              返回与写入锁相关联的给定条件等待的线程数的估计。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWriteHoldCount--">getWriteHoldCount</a></span>()</code>
<div class="block">
              查询当前线程对此锁的可重入写入数量。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThread-java.lang.Thread-">hasQueuedThread</a></span>(<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a> thread)</code>
<div class="block">
              查询给定线程是否等待获取读取或写入锁定。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThreads--">hasQueuedThreads</a></span>()</code>
<div class="block">
              查询是否有任何线程正在等待获取读取或写入锁定。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasWaiters-java.util.concurrent.locks.Condition-">hasWaiters</a></span>(<a href="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</a> condition)</code>
<div class="block">
              查询任何线程是否等待与写锁相关联的给定条件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isFair--">isFair</a></span>()</code>
<div class="block">
              如果此锁的公平设置为true，则返回 
             <code>true</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLocked--">isWriteLocked</a></span>()</code>
<div class="block">
              查询写锁是否由任何线程持有。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLockedByCurrentThread--">isWriteLockedByCurrentThread</a></span>()</code>
<div class="block">
              查询写锁是否由当前线程持有。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="class in java.util.concurrent.locks">ReentrantReadWriteLock.ReadLock</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#readLock--">readLock</a></span>()</code>
<div class="block">
              返回用于阅读的锁。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#toString--">toString</a></span>()</code>
<div class="block">
              返回一个标识此锁的字符串以及其锁定状态。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="class in java.util.concurrent.locks">ReentrantReadWriteLock.WriteLock</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock--">writeLock</a></span>()</code>
<div class="block">
              返回用于写入的锁。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="ReentrantReadWriteLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>ReentrantReadWriteLock</h4> <pre>public ReentrantReadWriteLock()</pre>
<div class="block">
            创建一个新的 
           <code>ReentrantReadWriteLock</code>与默认（非空）订购属性。 
          </div> </li>
</ul> <a name="ReentrantReadWriteLock-boolean-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>ReentrantReadWriteLock</h4> <pre>public ReentrantReadWriteLock(boolean fair)</pre>
<div class="block">
            创建一个新的 
           <code>ReentrantReadWriteLock</code>与给定的公平政策。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>fair</code> - 
            <code>true</code>如果此锁应使用合理的订购策略 
           </dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="writeLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>writeLock</h4> <pre>public <a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="class in java.util.concurrent.locks">ReentrantReadWriteLock.WriteLock</a> writeLock()</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock--">ReadWriteLock</a></code>复制</span>
</div>
<div class="block">
            返回用于写入的锁。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock--">writeLock</a></code>在界面 
            <code><a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="interface in java.util.concurrent.locks">ReadWriteLock</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             用于书写的锁 
           </dd>
</dl> </li>
</ul> <a name="readLock--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>readLock</h4> <pre>public <a href="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="class in java.util.concurrent.locks">ReentrantReadWriteLock.ReadLock</a> readLock()</pre>
<div class="block">
<span class="descfrmTypeLabel">说明从界面： <code><a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock--">ReadWriteLock</a></code>复制</span>
</div>
<div class="block">
            返回用于阅读的锁。 
          </div>
<dl>
<dt>
<span class="overrideSpecifyLabel">Specified by:</span>
</dt>
<dd>
<code><a href="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock--">readLock</a></code>在界面 
            <code><a href="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="interface in java.util.concurrent.locks">ReadWriteLock</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             用于阅读的锁 
           </dd>
</dl> </li>
</ul> <a name="isFair--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isFair</h4> <pre>public final boolean isFair()</pre>
<div class="block">
            如果此锁的公平设置为true，则返回 
           <code>true</code> 。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果这个锁的公平设置为true 
           </dd>
</dl> </li>
</ul> <a name="getOwner--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getOwner</h4> <pre>protected <a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a> getOwner()</pre>
<div class="block">
<span>返回当前拥有写锁的线程，如果不拥有，则返回<code>null</code> 。</span>
<span>当这个方法被不是所有者的线程调用时，返回值反映了当前锁定状态的尽力近似。</span>
<span>例如，业主可能暂时<code>null</code>即使有线程试图获取锁，但还没有这样做。</span>
<span>该方法旨在便于构建提供更广泛的锁定监控设施的子类。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所有者，或 
            <code>null</code>如果不拥有 
           </dd>
</dl> </li>
</ul> <a name="getReadLockCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getReadLockCount</h4> <pre>public int getReadLockCount()</pre>
<div class="block">
<span>查询为此锁持有的读取锁的数量。</span>
<span>该方法设计用于监控系统状态，不用于同步控制。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             持有的读取锁的数量 
           </dd>
</dl> </li>
</ul> <a name="isWriteLocked--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isWriteLocked</h4> <pre>public boolean isWriteLocked()</pre>
<div class="block">
<span>查询写锁是否由任何线程持有。</span>
<span>该方法设计用于监控系统状态，不用于同步控制。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果任何线程持有写锁定， 
            <code>false</code> false 
           </dd>
</dl> </li>
</ul> <a name="isWriteLockedByCurrentThread--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isWriteLockedByCurrentThread</h4> <pre>public boolean isWriteLockedByCurrentThread()</pre>
<div class="block">
            查询写锁是否由当前线程持有。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果当前线程保持写锁定， 
            <code>false</code> false 
           </dd>
</dl> </li>
</ul> <a name="getWriteHoldCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getWriteHoldCount</h4> <pre>public int getWriteHoldCount()</pre>
<div class="block">
<span>查询当前线程对此锁的可重入写入数量。</span>
<span>写入线程对于与解锁操作不匹配的每个锁定操作都保持锁定。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前线程对写锁定的保持数，如果当前线程不保留写锁定，则为零 
           </dd>
</dl> </li>
</ul> <a name="getReadHoldCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getReadHoldCount</h4> <pre>public int getReadHoldCount()</pre>
<div class="block">
<span>查询当前线程对此锁的可重入读取保留数。</span>
<span>读取器线程对于与解锁动作不匹配的每个锁定动作保持锁定。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前线程读锁定的保持数，如果当前线程未读取锁定，则为零 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="getQueuedWriterThreads--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getQueuedWriterThreads</h4> <pre>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt; getQueuedWriterThreads()</pre>
<div class="block">
<span>返回一个包含可能正在等待获取写入锁的线程的集合。</span>
<span>因为在构建此结果时，实际的线程集可能会动态更改，所以返回的集合只是尽力而为的估计。</span>
<span>返回的集合的元素没有特定的顺序。</span>
<span>该方法旨在便于构建提供更广泛的锁定监控设施的子类。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程的收集 
           </dd>
</dl> </li>
</ul> <a name="getQueuedReaderThreads--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getQueuedReaderThreads</h4> <pre>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt; getQueuedReaderThreads()</pre>
<div class="block">
<span>返回一个包含可能正在等待获取读取锁的线程的集合。</span>
<span>因为在构建此结果时，实际的线程集可能会动态更改，所以返回的集合只是尽力而为的估计。</span>
<span>返回的集合的元素没有特定的顺序。</span>
<span>该方法旨在便于构建提供更广泛的锁定监控设施的子类。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程的收集 
           </dd>
</dl> </li>
</ul> <a name="hasQueuedThreads--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hasQueuedThreads</h4> <pre>public final boolean hasQueuedThreads()</pre>
<div class="block">
<span>查询是否有任何线程正在等待获取读取或写入锁定。</span>
<span>请注意，由于取消可能随时发生， <code>true</code>返回不保证任何其他线程将获得锁。</span>
<span>该方法主要用于监视系统状态。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果可能有其他线程等待获取锁 
           </dd>
</dl> </li>
</ul> <a name="hasQueuedThread-java.lang.Thread-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hasQueuedThread</h4> <pre>public final boolean hasQueuedThread(<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a> thread)</pre>
<div class="block">
<span>查询给定线程是否等待获取读取或写入锁定。</span>
<span>请注意，由于取消可能随时发生， <code>true</code>返回不保证此线程将获得锁。</span>
<span>该方法主要用于监视系统状态。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>thread</code> - 线程 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果给定的线程排队等待这个锁 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果线程为空 
           </dd>
</dl> </li>
</ul> <a name="getQueueLength--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getQueueLength</h4> <pre>public final int getQueueLength()</pre>
<div class="block">
<span>返回等待获取读取或写入锁定的线程数的估计。</span>
<span>该值只是一个估计，因为线程数可能会在此方法遍历内部数据结构时动态更改。</span>
<span>该方法设计用于监视系统状态，不用于同步控制。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             估计等待这个锁的线程数 
           </dd>
</dl> </li>
</ul> <a name="getQueuedThreads--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getQueuedThreads</h4> <pre>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt; getQueuedThreads()</pre>
<div class="block">
<span>返回一个包含可能正在等待获取读取或写入锁定的线程的集合。</span>
<span>因为在构建此结果时，实际的线程集可能会动态更改，所以返回的集合只是尽力而为的估计。</span>
<span>返回的集合的元素没有特定的顺序。</span>
<span>该方法旨在便于构建提供更广泛监控设施的子类。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程的收集 
           </dd>
</dl> </li>
</ul> <a name="hasWaiters-java.util.concurrent.locks.Condition-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hasWaiters</h4> <pre>public boolean hasWaiters(<a href="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</a> condition)</pre>
<div class="block">
<span>查询任何线程是否等待与写锁相关联的给定条件。</span>
<span>请注意，由于超时和中断可能随时发生， <code>true</code>返回不能保证将来的<code>signal</code>将唤醒任何线程。</span>
<span>该方法主要用于监视系统状态。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>condition</code> - 条件 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>true</code>如果有任何等待的线程 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/IllegalMonitorStateException.html" title="class in java.lang">IllegalMonitorStateException</a></code> - 如果此锁不被保留 
           </dd>
<dd>
<code><a href="../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的条件不与此锁相关联 
           </dd>
<dd>
<code><a href="../../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果条件为空 
           </dd>
</dl> </li>
</ul> <a name="getWaitQueueLength-java.util.concurrent.locks.Condition-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getWaitQueueLength</h4> <pre>public int getWaitQueueLength(<a href="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</a> condition)</pre>
<div class="block">
<span>返回与写入锁相关联的给定条件等待的线程数的估计。</span>
<span>请注意，由于超时和中断可能在任何时间发生，估计仅作为实际服务员人数的上限。</span>
<span>该方法设计用于监视系统状态，不用于同步控制。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>condition</code> - 条件 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             估计等待线程数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/IllegalMonitorStateException.html" title="class in java.lang">IllegalMonitorStateException</a></code> - 如果此锁没有保持 
           </dd>
<dd>
<code><a href="../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的条件不与此锁相关联 
           </dd>
<dd>
<code><a href="../../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果条件为空 
           </dd>
</dl> </li>
</ul> <a name="getWaitingThreads-java.util.concurrent.locks.Condition-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getWaitingThreads</h4> <pre>protected <a href="../../../../java/util/Collection.html" title="interface in java.util">Collection</a>&lt;<a href="../../../../java/lang/Thread.html" title="class in java.lang">Thread</a>&gt; getWaitingThreads(<a href="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</a> condition)</pre>
<div class="block">
<span>返回包含可能在与写锁相关联的给定条件下等待的线程的集合。</span>
<span>因为在构建此结果时，实际的线程集可能会动态更改，所以返回的集合只是尽力而为的估计。</span>
<span>返回的集合的元素没有特定的顺序。</span>
<span>该方法旨在便于构建提供更广泛的状态监测设施的子类。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>condition</code> - 条件 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             线程的收集 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../../java/lang/IllegalMonitorStateException.html" title="class in java.lang">IllegalMonitorStateException</a></code> - 如果此锁没有保持 
           </dd>
<dd>
<code><a href="../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的条件与此锁没有关联 
           </dd>
<dd>
<code><a href="../../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果条件为空 
           </dd>
</dl> </li>
</ul> <a name="toString--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>toString</h4> <pre>public <a href="../../../../java/lang/String.html" title="class in java.lang">String</a> toString()</pre>
<div class="block">
<span>返回一个标识此锁的字符串以及其锁定状态。</span>
<span>括号中的状态包括字符串<code>"Write locks ="</code>其后是可重入的写入锁的数量，字符串<code>"Read locks ="</code>后面是持有的读锁定数。</span>
</div>
<dl>
<dt>
<span class="overrideSpecifyLabel">重写：</span>
</dt>
<dd>
<code><a href="../../../../java/lang/Object.html#toString--">toString</a></code>在类别 
            <code><a href="../../../../java/lang/Object.html" title="class in java.lang">Object</a></code>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             标识此锁的字符串以及其锁定状态 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>