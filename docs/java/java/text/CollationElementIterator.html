<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.text 
   </div>
<h2 class="title" title="Class CollationElementIterator">Class CollationElementIterator</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.text.CollationElementIterator</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public final class <span class="typeNameLabel">CollationElementIterator</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span><code>CollationElementIterator</code>类用作遍历国际字符串的每个字符的迭代器。</span>
<span>使用迭代器返回定位字符的排序优先级。</span>
<span>字符的排序优先级，我们将其称为键，定义了字符在给定的排序规则对象中的整理方式。</span>
<p> <span>例如，考虑以下西班牙语：</span> </p>
<blockquote>
<span><pre>
 "ca" → the first key is key('c') and second key is key('a').
 "cha" → the first key is key('ch') and second key is key('a').
 </pre></span>
</blockquote>
<span>在德国，</span>
<blockquote>
<span><pre>
 "�b" → the first key is key('a'), the second key is key('e'), and
 the third key is key('b').
 </pre></span>
</blockquote>
<span>一个字符的键是一个整数，由一个小阶（short），二次（byte）和三阶（byte）组成。</span>
<span>Java严格定义了其原始数据类型的大小和签名。</span>
<span>因此，静态函数<code>primaryOrder</code> ， <code>secondaryOrder</code>和<code>tertiaryOrder</code>回报<code>int</code> ， <code>short</code>和<code>short</code>分别以确保密钥值的正确性。</span>
<p> <span>迭代器使用的示例，</span> </p>
<blockquote>
<span><pre>

  String testString = "This is a test";
  Collator col = Collator.getInstance();
  if (col instanceof RuleBasedCollator) {
      RuleBasedCollator ruleBasedCollator = (RuleBasedCollator)col;
      CollationElementIterator collationElementIterator = ruleBasedCollator.getCollationElementIterator(testString);
      int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next());
          :
  }
 </pre></span>
</blockquote>
<p> <span><code>CollationElementIterator.next</code>返回下一个字符的排序规则顺序。</span> <span>整理订单由一级订单，二级订单和三级订单组成。</span> <span>归类顺序的数据类型为<strong>int</strong> 。</span> <span>排序顺序的前16位是其主要顺序;</span> <span>接下来的8位是次级，最后8位是第三级。</span> </p>
<p> <span><b>注：</b> <code>CollationElementIterator</code>是的一部分<code>RuleBasedCollator</code>实现。</span> <span>它只能用于<code>RuleBasedCollator</code>实例。</span> </p>
</div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/text/Collator.html" title="java.text中的类"><code>Collator</code></a> ， <a href="../../java/text/RuleBasedCollator.html" title="java.text中的类"><code>RuleBasedCollator</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!-- --> </a> <h3>Field Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Field Summary table, listing fields, and an explanation">
<caption>
<span>Fields</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#NULLORDER">NULLORDER</a></span></code>
<div class="block">
              指示字符串结束的空白顺序由光标到达。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#getMaxExpansion-int-">getMaxExpansion</a></span>(int order)</code>
<div class="block">
              返回以指定的比较顺序结束的任何扩展序列的最大长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#getOffset--">getOffset</a></span>()</code>
<div class="block">
              返回与下一个排序规则元素对应的原始文本中的字符偏移量。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#next--">next</a></span>()</code>
<div class="block">
              获取字符串中的下一个排序规则元素。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#previous--">previous</a></span>()</code>
<div class="block">
              获取字符串中的以前的排序规则元素。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#primaryOrder-int-">primaryOrder</a></span>(int order)</code>
<div class="block">
              返回排序规则元素的主要组件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#reset--">reset</a></span>()</code>
<div class="block">
              将光标重置为字符串的开头。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static short</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#secondaryOrder-int-">secondaryOrder</a></span>(int order)</code>
<div class="block">
              返回排序规则元素的次要组件。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#setOffset-int-">setOffset</a></span>(int newOffset)</code>
<div class="block">
              将迭代器设置为指向与指定字符对应的排序规则元素（参数是原始字符串中的CHARACTER偏移量，而不是其对应的排序规则元素序列中的偏移量）。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#setText-java.text.CharacterIterator-">setText</a></span>(<a href="../../java/text/CharacterIterator.html" title="interface in java.text">CharacterIterator</a> source)</code>
<div class="block">
              设置要迭代的新字符串。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#setText-java.lang.String-">setText</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> source)</code>
<div class="block">
              设置要迭代的新字符串。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static short</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/text/CollationElementIterator.html#tertiaryOrder-int-">tertiaryOrder</a></span>(int order)</code>
<div class="block">
              返回排序规则元素的三级分量。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!-- --> </a> <h3>字段详细信息</h3> <a name="NULLORDER">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>NULLORDER</h4> <pre>public static final int NULLORDER</pre>
<div class="block">
            指示字符串结束的空白顺序由光标到达。 
          </div>
<dl>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../constant-values.html#java.text.CollationElementIterator.NULLORDER">Constant Field Values</a>
</dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="reset--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>reset</h4> <pre>public void reset()</pre>
<div class="block">
<span>将光标重置为字符串的开头。</span>
<span>next（）的下一个调用将返回字符串中的第一个排序规则元素。</span>
</div> </li>
</ul> <a name="next--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>next</h4> <pre>public int next()</pre>
<div class="block">
<span>获取字符串中的下一个排序规则元素。</span>
<p> <span>该迭代器遍历从字符串构建的一系列排序规则元素。</span> <span>因为没有必要从字符到排序规则元素的一对一映射，这并不意味着与“返回字符串中下一个字符的排序规则元素[或排序优先级]”相同。</span> </p>
<p> <span>此函数返回迭代器当前指向的排序规则元素，然后更新内部指针以指向下一个元素。</span> <span>previous（）首先更新指针，然后返回该元素。</span> <span>这意味着当您在迭代时更改方向（即，调用next（），然后调用previous（）或调用previous（）然后调用next（）），您将返回相同的元素两次。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             下一个排序规则元素 
           </dd>
</dl> </li>
</ul> <a name="previous--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>previous</h4> <pre>public int previous()</pre>
<div class="block">
<span>获取字符串中的以前的排序规则元素。</span>
<p> <span>该迭代器遍历从字符串构建的一系列排序规则元素。</span> <span>因为没有必要从字符到排序规则元素的一对一映射，这并不意味着与“返回字符串中前一个字符的排序规则元素[或排序优先级]”相同。</span> </p>
<p> <span>此函数将迭代器的内部指针更新为指向当前指向的collation元素，然后返回该元素，而next（）返回当前元素，然后更新指针。</span> <span>这意味着当您在迭代时更改方向（即，调用next（），然后调用previous（）或调用previous（）然后调用next（）），您将返回相同的元素两次。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             以前的排序规则元素 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="primaryOrder-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>primaryOrder</h4> <pre>public static final int primaryOrder(int order)</pre>
<div class="block">
            返回排序规则元素的主要组件。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>order</code> - 排序规则元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             元素的主要组成部分 
           </dd>
</dl> </li>
</ul> <a name="secondaryOrder-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>secondaryOrder</h4> <pre>public static final short secondaryOrder(int order)</pre>
<div class="block">
            返回排序规则元素的次要组件。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>order</code> - 排序规则元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             元素的次要组件 
           </dd>
</dl> </li>
</ul> <a name="tertiaryOrder-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>tertiaryOrder</h4> <pre>public static final short tertiaryOrder(int order)</pre>
<div class="block">
            返回排序规则元素的三级分量。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>order</code> - 排序规则元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             元素的第三部分 
           </dd>
</dl> </li>
</ul> <a name="setOffset-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setOffset</h4> <pre>public void setOffset(int newOffset)</pre>
<div class="block">
<span>将迭代器设置为指向与指定字符对应的排序规则元素（参数是原始字符串中的CHARACTER偏移量，而不是其对应的排序规则元素序列中的偏移量）。</span>
<span>下一次调用next（）返回的值将是对应于文本中指定位置的排序规则元素。</span>
<span>如果该位置在合约字符序列的中间，下一次调用next（）的结果是该序列的排序规则元素。</span>
<span>这意味着getOffset（）不能保证返回与传递给setOffset（）的前一个调用相同的值。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>newOffset</code> - 新的字符偏移到原始文本。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="getOffset--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getOffset</h4> <pre>public int getOffset()</pre>
<div class="block">
<span>返回与下一个排序规则元素对应的原始文本中的字符偏移量。</span>
<span>（也就是说，getOffset（）返回与下一次调用next（）返回的排序规则元素对应的文本中的位置）。该值将始终是对应于排序规则元素的第一个字符的索引（a当两个或更多个字符都对应于相同的排序规则元素时，收缩字符序列）。</span>
<span>这意味着如果您立即使用getOffset（）执行setOffset（x），getOffset（）将不一定返回x。</span>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             对应于下一次调用next（）返回的排序规则元素的原始文本中的字符偏移量。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="getMaxExpansion-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getMaxExpansion</h4> <pre>public int getMaxExpansion(int order)</pre>
<div class="block">
            返回以指定的比较顺序结束的任何扩展序列的最大长度。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>order</code> - 上一个或下一个返回的归类顺序。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             以指定顺序结束的任何扩展序列的最大长度。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="setText-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setText</h4> <pre>public void setText(<a href="../../java/lang/String.html" title="class in java.lang">String</a> source)</pre>
<div class="block">
            设置要迭代的新字符串。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>source</code> - 新的源文本 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> <a name="setText-java.text.CharacterIterator-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>setText</h4> <pre>public void setText(<a href="../../java/text/CharacterIterator.html" title="interface in java.text">CharacterIterator</a> source)</pre>
<div class="block">
            设置要迭代的新字符串。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>source</code> - 新的源文本。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.2 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>