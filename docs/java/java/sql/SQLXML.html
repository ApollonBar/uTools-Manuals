<div class="header">
<div class="subTitle">
     compact2, compact3 
   </div>
<div class="subTitle">
     java.sql 
   </div>
<h2 class="title" title="Interface SQLXML">Interface SQLXML</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public interface <span class="typeNameLabel">SQLXML</span></pre>
<div class="block">
<span>用于SQL XML类型的JavaTM编程语言中的映射。</span>
<span>XML是一种内置类型，它将XML值作为列值存储在数据库表的一行中。</span>
<span>默认情况下，驱动程序实现SQLXML对象作为XML数据的逻辑指针，而不是数据本身。</span>
<span>SQLXML对象在创建事务的持续时间内是有效的。</span>
<p> <span>SQLXML接口提供了以String，Reader或Writer或Stream的形式访问XML值的方法。</span> <span>XML值也可以通过源访问或设置为结果，它们与XML解析器API（如DOM，SAX和StAX）一起使用，以及XSLT转换和XPath评估。</span> </p>
<p> <span>接口ResultSet，CallableStatement和PreparedStatement中的方法（如getSQLXML）允许程序员访问XML值。</span> <span>此外，该界面还具有更新XML值的方法。</span> </p>
<p> <span>可以使用BinaryStream获取SQLXML实例的XML值</span> </p>
<pre>  <span>SQLXML sqlxml = resultSet.getSQLXML(column);
   InputStream binaryStream = sqlxml.getBinaryStream();</span> </pre>
<span>例如，使用DOM解析器解析XML值：</span>
<pre>  <span>DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
   Document result = parser.parse(binaryStream);</span> </pre>
<span>或使用SAX解析器解析XML值到您的处理程序：</span>
<pre>  <span>SAXParser parser = SAXParserFactory.newInstance().newSAXParser();
   parser.parse(binaryStream, myHandler);</span> </pre>
<span>或使用StAX解析器解析XML值：</span>
<pre>  <span>XMLInputFactory factory = XMLInputFactory.newInstance();
   XMLStreamReader streamReader = factory.createXMLStreamReader(binaryStream);</span> </pre>
<p> <span>因为数据库可能会使用XML的优化表示，通过getSource（）和setResult（）访问该值可以提高处理性能，而不需要序列化到流表示和解析XML。</span> </p>
<p> <span>例如，要获取DOM文档节点：</span> </p>
<pre>  <span>DOMSource domSource = sqlxml.getSource(DOMSource.class);
   Document document = (Document) domSource.getNode();</span> </pre>
<span>或将值设置为DOM文档节点到myNode：</span>
<pre>  <span>DOMResult domResult = sqlxml.setResult(DOMResult.class);
   domResult.setNode(myNode);</span> </pre>
<span>或者，将SAX事件发送到您的处理程序：</span>
<pre>  <span>SAXSource saxSource = sqlxml.getSource(SAXSource.class);
   XMLReader xmlReader = saxSource.getXMLReader();
   xmlReader.setContentHandler(myHandler);
   xmlReader.parse(saxSource.getInputSource());</span> </pre>
<span>或者，从SAX事件设置结果值：</span>
<pre>  <span>SAXResult saxResult = sqlxml.setResult(SAXResult.class);
   ContentHandler contentHandler = saxResult.getHandler();
   contentHandler.startDocument();
   // set the XML elements and attributes into the result
   contentHandler.endDocument();</span> </pre>
<span>或者，要获得StAX事件：</span>
<pre>  <span>StAXSource staxSource = sqlxml.getSource(StAXSource.class);
   XMLStreamReader streamReader = staxSource.getXMLStreamReader();</span> </pre>
<span>或者，从StAX事件设置结果值：</span>
<pre>  <span>StAXResult staxResult = sqlxml.setResult(StAXResult.class);
   XMLStreamWriter streamWriter = staxResult.getXMLStreamWriter();</span> </pre>
<span>或者，使用xsltFile输出中的XSLT将XML值执行XSLT转换为文件resultFile：</span>
<pre>  <span>File xsltFile = new File("a.xslt");
   File myFile = new File("result.xml");
   Transformer xslt = TransformerFactory.newInstance().newTransformer(new StreamSource(xsltFile));
   Source source = sqlxml.getSource(null);
   Result result = new StreamResult(myFile);
   xslt.transform(source, result);</span> </pre>
<span>或者，评估XML值上的XPath表达式：</span>
<pre>  <span>XPath xpath = XPathFactory.newInstance().newXPath();
   DOMSource domSource = sqlxml.getSource(DOMSource.class);
   Document document = (Document) domSource.getNode();
   String expression = "/foo/@bar";
   String barValue = xpath.evaluate(expression, document);</span> </pre>
<span>要将XML值设置为XSLT转换的结果：</span>
<pre>  <span>File sourceFile = new File("source.xml");
   Transformer xslt = TransformerFactory.newInstance().newTransformer(new StreamSource(xsltFile));
   Source streamSource = new StreamSource(sourceFile);
   Result result = sqlxml.setResult(null);
   xslt.transform(streamSource, result);</span> </pre>
<span>可以使用调用newTransformer（）指定的标识变换将任何源转换为Result：</span>
<pre>  <span>Transformer identity = TransformerFactory.newInstance().newTransformer();
   Source source = sqlxml.getSource(null);
   File myFile = new File("result.xml");
   Result result = new StreamResult(myFile);
   identity.transform(source, result);</span> </pre>
<span>要将Source的内容写入标准输出：</span>
<pre>  <span>Transformer identity = TransformerFactory.newInstance().newTransformer();
   Source source = sqlxml.getSource(null);
   Result result = new StreamResult(System.out);
   identity.transform(source, result);</span> </pre>
<span>从DOMResult创建DOMSource：</span>
<pre>  <span>DOMSource domSource = new DOMSource(domResult.getNode());</span> </pre>
<p> <span>不完整或无效的XML值在设置时可能导致SQLException，或者在执行execute（）时可能会发生异常。</span> <span>在执行execute（）之前必须关闭所有流，否则将抛出SQLException。</span> </p>
<p> <span>读取和写入SQLXML对象的XML值最多可以发生一次。</span> <span>可读和不可读的概念状态确定读取API中的一个是否返回值或抛出异常。</span> <span>可写和不可写的概念状态确定一个写入API是否将设置值或抛出异常。</span> </p>
<p> <span>free（）或任何读取API被调用时，状态从可读到不可读：getBinaryStream（），getCharacterStream（），getSource（）和getString（）。</span> <span>当这种情况发生时，实现也可能会将状态更改为不可写。</span> </p>
<p> <span>一旦free（）或任何一种编写的API被调用，状态从可写到不可写：setBinaryStream（），setCharacterStream（），setResult（）和setString（）。</span> <span>当这种情况发生时，实现也可能会将状态更改为不可读。</span> </p>
<p> <span>所有的方法<code>SQLXML</code>接口必须如果JDBC驱动程序支持的数据类型得到充分执行。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.6 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../javax/xml/parsers/package-summary.html"><code>javax.xml.parsers</code></a> ， 
        <a href="../../javax/xml/stream/package-summary.html"><code>javax.xml.stream</code></a> ， 
        <a href="../../javax/xml/transform/package-summary.html"><code>javax.xml.transform</code></a> ， 
        <a href="../../javax/xml/xpath/package-summary.html"><code>javax.xml.xpath</code></a>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#free--">free</a></span>()</code>
<div class="block">
              此方法关闭此对象并释放其持有的资源。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../java/io/InputStream.html" title="class in java.io">InputStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#getBinaryStream--">getBinaryStream</a></span>()</code>
<div class="block">
              检索此SQLXML实例指定的XML值作为流。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../java/io/Reader.html" title="class in java.io">Reader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#getCharacterStream--">getCharacterStream</a></span>()</code>
<div class="block">
              将此SQLXML实例指定的XML值作为java.io.Reader对象检索。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>&lt;T extends <a href="../../javax/xml/transform/Source.html" title="interface in javax.xml.transform">Source</a>&gt;<br/>T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#getSource-java.lang.Class-">getSource</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; sourceClass)</code>
<div class="block">
              返回一个用于读取此SQLXML实例指定的XML值的源。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../java/lang/String.html" title="class in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#getString--">getString</a></span>()</code>
<div class="block">
              返回此SQLXML实例指定的XML值的字符串表示形式。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../java/io/OutputStream.html" title="class in java.io">OutputStream</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#setBinaryStream--">setBinaryStream</a></span>()</code>
<div class="block">
              检索可用于编写此SQLXML实例所代表的XML值的流。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../java/io/Writer.html" title="class in java.io">Writer</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#setCharacterStream--">setCharacterStream</a></span>()</code>
<div class="block">
              检索用于写入此SQLXML实例所代表的XML值的流。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>&lt;T extends <a href="../../javax/xml/transform/Result.html" title="interface in javax.xml.transform">Result</a>&gt;<br/>T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#setResult-java.lang.Class-">setResult</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; resultClass)</code>
<div class="block">
              返回一个用于设置此SQLXML实例指定的XML值的结果。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/sql/SQLXML.html#setString-java.lang.String-">setString</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> value)</code>
<div class="block">
              将此SQLXML实例指定的XML值设置为给定的String表示形式。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="free--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>free</h4> <pre>void free()
   throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>此方法关闭此对象并释放其持有的资源。</span>
<span>当调用此方法时，SQL XML对象变得无效，既不可读，也不可写。</span>
<span><code>free</code>被调用后，任何尝试调用<code>free</code>以外的方法将导致<code>SQLException</code>被抛出。</span>
<span>如果<code>free</code>被多次调用，在后续调用<code>free</code>被视为无操作。</span>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果存在释放XML值的错误。 
           </dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="getBinaryStream--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getBinaryStream</h4> <pre><a href="../../java/io/InputStream.html" title="class in java.io">InputStream</a> getBinaryStream()
                     throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>检索此SQLXML实例指定的XML值作为流。</span>
<span>输入流的字节根据XML 1.0规范的附录F进行解释。</span>
<span>当ResultSet的指定列具有SQLXML类型java.sql.Types时，此方法的行为与ResultSet.getBinaryStream（）相同。</span>
<p> <span>当调用此方法时，SQL XML对象变得不可读，并且根据实现情况也可能不可写。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             包含XML数据的流。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果在处理XML值时出错。</span>
<span>如果状态不可读，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="setBinaryStream--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setBinaryStream</h4> <pre><a href="../../java/io/OutputStream.html" title="class in java.io">OutputStream</a> setBinaryStream()
                      throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>检索可用于编写此SQLXML实例所代表的XML值的流。</span>
<span>流从位置0开始。流的字节根据XML 1.0规范的附录F进行解释当ResultSet的指定列具有类型java.sql时，此方法的行为与ResultSet.updateBinaryStream（）相同。 SQLXML的类型。</span>
<p> <span>当调用此方法时，SQL XML对象变得无法写入，并且根据实现情况也可能变得不可读取。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可以写入数据的流。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果处理XML值时出错。</span>
<span>如果状态不可写，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="getCharacterStream--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getCharacterStream</h4> <pre><a href="../../java/io/Reader.html" title="class in java.io">Reader</a> getCharacterStream()
                   throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>将此SQLXML实例指定的XML值作为java.io.Reader对象检索。</span>
<span>此流的格式由org.xml.sax.InputSource定义，根据XML 1.0规范的第2节和附录B，流中的字符表示XML的unicode代码点。</span>
<span>虽然可能存在unicode以外的编码声明，但是流的编码是unicode。</span>
<span>当ResultSet的指定列具有SQLXML类型java.sql.Types时，此方法的行为与ResultSet.getCharacterStream（）相同。</span>
<p> <span>当调用此方法时，SQL XML对象变得不可读，并且根据实现情况也可能不可写。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             包含XML数据的流。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果处理XML值时出错。</span>
<span>异常的getCause（）方法可能会提供更详细的异常，例如，如果流不包含有效字符。</span>
<span>如果状态不可读，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="setCharacterStream--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setCharacterStream</h4> <pre><a href="../../java/io/Writer.html" title="class in java.io">Writer</a> setCharacterStream()
                   throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>检索用于写入此SQLXML实例所代表的XML值的流。</span>
<span>此流的格式由org.xml.sax.InputSource定义，根据XML 1.0规范的第2节和附录B，流中的字符表示XML的unicode代码点。</span>
<span>虽然可能存在unicode以外的编码声明，但是流的编码是unicode。</span>
<span>当ResultSet的指定列具有SQLXML类型java.sql.Types时，此方法的行为与ResultSet.updateCharacterStream（）相同。</span>
<p> <span>当调用此方法时，SQL XML对象变得无法写入，并且根据实现情况也可能变得不可读取。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             可以写入数据的流。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果在处理XML值时出错。</span>
<span>异常的getCause（）方法可能会提供更详细的异常，例如，如果流不包含有效字符。</span>
<span>如果状态不可写，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="getString--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getString</h4> <pre><a href="../../java/lang/String.html" title="class in java.lang">String</a> getString()
          throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>返回此SQLXML实例指定的XML值的字符串表示形式。</span>
<span>此字符串的格式由org.xml.sax.InputSource定义，根据XML 1.0规范的第2节和附录B，流中的字符表示XML的unicode代码点。</span>
<span>虽然可能存在unicode以外的编码声明，但String的编码是unicode。</span>
<span>当ResultSet的指定列具有SQLXML类型java.sql.Types时，此方法的行为与ResultSet.getString（）相同。</span>
<p> <span>当调用此方法时，SQL XML对象变得不可读，并且根据实现情况也可能不可写。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             由此SQLXML实例指定的XML值的字符串表示形式。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果处理XML值时出错。</span>
<span>异常的getCause（）方法可能会提供更详细的异常，例如，如果流不包含有效字符。</span>
<span>如果状态不可读，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="setString-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setString</h4> <pre>void setString(<a href="../../java/lang/String.html" title="class in java.lang">String</a> value)
        throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>将此SQLXML实例指定的XML值设置为给定的String表示形式。</span>
<span>此字符串的格式由org.xml.sax.InputSource定义，根据XML 1.0规范的第2节和附录B，流中的字符表示XML的unicode代码点。</span>
<span>虽然可能存在unicode以外的编码声明，但String的编码是unicode。</span>
<span>当ResultSet的指定列具有SQLXML类型java.sql.Types时，此方法的行为与ResultSet.updateString（）相同。</span>
<p> <span>当调用此方法时，SQL XML对象变得无法写入，并且根据实现情况也可能变得不可读取。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>value</code> - XML值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果在处理XML值时出错。</span>
<span>异常的getCause（）方法可能会提供更详细的异常，例如，如果流不包含有效字符。</span>
<span>如果状态不可写，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="getSource-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSource</h4> <pre>&lt;T extends <a href="../../javax/xml/transform/Source.html" title="interface in javax.xml.transform">Source</a>&gt; T getSource(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; sourceClass)
                        throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>返回一个用于读取此SQLXML实例指定的XML值的源。</span>
<span>来源用作XML解析器和XSLT变换器的输入。</span>
<p> <span>默认情况下，XML解析器的源将进行命名空间处理。</span> <span>Source的systemID是依赖于实现的。</span> </p>
<p> <span>当调用此方法时，SQL XML对象变得不可读，并且根据实现情况也可能不可写。</span> </p>
<p> <span>请注意，SAX是一个回调架构，因此，返回的SAXSource应该被设置为一个内容处理程序，它将从解析中接收SAX事件。</span> <span>内容处理程序将基于XML的内容接收回调。</span> </p>
<pre>  <span>SAXSource saxSource = sqlxml.getSource(SAXSource.class);
   XMLReader xmlReader = saxSource.getXMLReader();
   xmlReader.setContentHandler(myHandler);
   xmlReader.parse(saxSource.getInputSource());</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 由此Class对象建模的类的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>sourceClass</code> - 源的类，或null。</span>
<span>如果该类为null，则将返回供应商特定的Source实现。</span>
<span>至少支持以下类别：</span>
<pre>  <span>javax.xml.transform.dom.DOMSource - returns a DOMSource
   javax.xml.transform.sax.SAXSource - returns a SAXSource
   javax.xml.transform.stax.StAXSource - returns a StAXSource
   javax.xml.transform.stream.StreamSource - returns a StreamSource</span> </pre>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             用于读取XML值的源。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果在处理XML值时出错，或者不支持此功能。</span>
<span>异常的getCause（）方法可能会提供更详细的异常，例如，如果发生XML解析器异常。</span>
<span>如果状态不可读，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> <a name="setResult-java.lang.Class-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>setResult</h4> <pre>&lt;T extends <a href="../../javax/xml/transform/Result.html" title="interface in javax.xml.transform">Result</a>&gt; T setResult(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; resultClass)
                        throws <a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></pre>
<div class="block">
<span>返回一个用于设置此SQLXML实例指定的XML值的结果。</span>
<p> <span>结果的systemID依赖于实现。</span> </p>
<p> <span>当调用此方法时，SQL XML对象变得无法写入，并且根据实现情况也可能变得不可读取。</span> </p>
<p> <span>请注意，SAX是一个回调架构，返回的SAXResult具有分配的内容处理程序，它将基于XML的内容接收SAX事件。</span> <span>使用XML文档的内容调用内容处理程序来分配值。</span> </p>
<pre>  <span>SAXResult saxResult = sqlxml.setResult(SAXResult.class);
   ContentHandler contentHandler = saxResult.getXMLReader().getContentHandler();
   contentHandler.startDocument();
   // set the XML elements and attributes into the result
   contentHandler.endDocument();</span> </pre>
</div>
<dl>
<dt>
<span class="paramLabel">参数类型</span>
</dt>
<dd>
<code>T</code> - 由此Class对象建模的类的类型 
           </dd>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>resultClass</code> - 结果的类，或null。</span>
<span>如果resultClass为null，将返回一个供应商特定的Result实现。</span>
<span>至少支持以下类别：</span>
<pre>  <span>javax.xml.transform.dom.DOMResult - returns a DOMResult
   javax.xml.transform.sax.SAXResult - returns a SAXResult
   javax.xml.transform.stax.StAXResult - returns a StAXResult
   javax.xml.transform.stream.StreamResult - returns a StreamResult</span> </pre>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             返回设置XML值的结果。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/sql/SQLException.html" title="class in java.sql">SQLException</a></code> - 如果在处理XML值时出错，或者不支持此功能。</span>
<span>异常的getCause（）方法可能会提供更详细的异常，例如，如果发生XML解析器异常。</span>
<span>如果状态不可写，则抛出异常。</span>
</dd>
<dd>
<code><a href="../../java/sql/SQLFeatureNotSupportedException.html" title="class in java.sql">SQLFeatureNotSupportedException</a></code> - 如果JDBC驱动程序不支持此方法 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.6 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>