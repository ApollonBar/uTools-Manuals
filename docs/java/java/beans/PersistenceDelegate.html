<div class="header">
<div class="subTitle">
     java.beans 
   </div>
<h2 class="title" title="Class PersistenceDelegate">Class PersistenceDelegate</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.beans.PersistenceDelegate</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
        已知直接子类：
       </dt>
<dd>
<span><a href="../../java/beans/DefaultPersistenceDelegate.html" title="java.beans中的类">DefaultPersistenceDelegate</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public abstract class <span class="typeNameLabel">PersistenceDelegate</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>PersistenceDelegate类负责根据类的公共API中的方法来表达给定类的实例的状态。</span>
<span>相反关联的持久性与类本身完成，例如，由责任<code>readObject</code>种<code>writeObject</code>由所使用的方法<code>ObjectOutputStream</code> ，溪流如<code>XMLEncoder</code>其使用该代理模型可以有自己的行为独立控制的类本身。</span>
<span>通常来说，这个班级是在这个授权计划中可以很容易地表达这些信息和惯例的最佳方法。</span>
<span>然而，有时候，单个类中的一个小问题可以防止整个对象图形被写入，并且这可以使应用程序开发人员无需追索权，而是尝试在本地影响有问题的类或使用替代的持久性技术。</span>
<span>在这种情况下，授权模型给应用程序开发人员提供了相对干净的机制来干预序列化过程的所有部分，而不需要对不是应用程序本身的一部分的类的实现进行修改。</span>
<p> <span>除了使用委托模型之外，该持久性方案与传统的串行化方案不同，需要不具有对应的<code>readObject</code>方法的<code>writeObject</code>方法的模拟。</span> <span><code>writeObject</code>模拟器根据其公共API对每个实例进行编码，不需要定义<code>readObject</code>模拟，因为用于读取序列化表单的过程由Java语言规范中规定的方法调用的语义定义。</span> <span>打破之间的依赖<code>writeObject</code>个<code>readObject</code>实施方式中，其可以从版本更改为版本，是使通过该技术不受在它们所涉及的类的私有实现的变化所产生的档案的关键因素。</span> </p>
<p> <span>持久代理可以控制对象持久化的所有方面，包括：</span> </p>
<ul>
<li> <span>决定一个实例是否可以被突变成同一个类的另一个实例。</span> </li>
<li> <span>通过调用公共构造函数或公共工厂方法来实例化对象。</span> </li>
<li> <span>执行对象的初始化。</span> </li>
</ul>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.4 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../java/beans/XMLEncoder.html" title="java.beans中的类"><code>XMLEncoder</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../java/beans/PersistenceDelegate.html#PersistenceDelegate--">PersistenceDelegate</a></span>()</code> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/beans/PersistenceDelegate.html#initialize-java.lang.Class-java.lang.Object-java.lang.Object-java.beans.Encoder-">initialize</a></span>(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance, <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</code>
<div class="block">
              生成一系列对newInstance具有副作用的 
             <code>newInstance</code> ，使新实例变得 
             <em>相当于</em>
<code>oldInstance</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>protected abstract <a href="../../java/beans/Expression.html" title="class in java.beans">Expression</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/beans/PersistenceDelegate.html#instantiate-java.lang.Object-java.beans.Encoder-">instantiate</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance, <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</code>
<div class="block">
              返回值为 
             <code>oldInstance</code> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/beans/PersistenceDelegate.html#mutatesTo-java.lang.Object-java.lang.Object-">mutatesTo</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance, <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance)</code>
<div class="block">
              如果 
             <em>等效</em>副本，则返回true 
             <code>oldInstance</code>可以通过将一系列语句来创建 
             <code>newInstance</code> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../java/beans/PersistenceDelegate.html#writeObject-java.lang.Object-java.beans.Encoder-">writeObject</a></span>(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance, <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</code>
<div class="block">
<code>writeObject</code>是 
             <code>writeObject</code>性的单个入口点，由 
             <code>Encoder</code>的授权模式Encoder使用。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="PersistenceDelegate--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>PersistenceDelegate</h4> <pre>public PersistenceDelegate()</pre> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="writeObject-java.lang.Object-java.beans.Encoder-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>writeObject</h4> <pre>public void writeObject(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance,
                        <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</pre>
<div class="block">
<span><code>writeObject</code>是<code>writeObject</code>性的单个入口点，由<code>Encoder</code>的授权模式Encoder使用。</span>
<span>虽然这种方法不是最终的，但在正常情况下不需要进行子类化。</span>
<p> <span>这个实现首先检查流是否已经遇到这个对象。</span> <span>接下来， <code>mutatesTo</code>方法来查看从流返回的候选人是否可以突变为<code>oldInstance</code>的准确副本。</span> <span>如果可以，则<code>initialize</code>方法来执行初始化。</span> <span>如果没有，候选人将从流中删除，并调用<code>instantiate</code>方法为此对象创建新的候选项。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>oldInstance</code> - 将由此表达式创建的实例。 
           </dd>
<dd>
<code>out</code> - 将写入此表达式的流。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>out</code>是 
            <code>null</code>
</dd>
</dl> </li>
</ul> <a name="mutatesTo-java.lang.Object-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>mutatesTo</h4> <pre>protected boolean mutatesTo(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance,
                            <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance)</pre>
<div class="block">
<span>如果<em>等效</em>副本，则返回true <code>oldInstance</code>可以通过将一系列语句来创建<code>newInstance</code> 。</span>
<span>在这种方法的规范中，我们的意思是相当于修改后的实例与其公共API中相关方法的行为不能区别于<code>oldInstance</code> 。</span>
<span>[注意：我们使用短语<em>相关</em>方法而不是<em>所有</em>方法，只因为严格正确， <code>hashCode</code>和<code>toString</code>类的方法可防止大多数类生成其实例的真正难以区别的副本]。</span>
<p> <span>如果两个实例的类相同，则默认行为返回<code>true</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>oldInstance</code> - 要复制的实例。 
           </dd>
<dd>
<code>newInstance</code> - 要修改的实例。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             真要是的等效副本 
            <code>newInstance</code>可通过应用一系列突变要创建 
            <code>oldInstance</code> 。 
           </dd>
</dl> </li>
</ul> <a name="instantiate-java.lang.Object-java.beans.Encoder-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>instantiate</h4> <pre>protected abstract <a href="../../java/beans/Expression.html" title="class in java.beans">Expression</a> instantiate(<a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance,
                                          <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</pre>
<div class="block">
<span>返回值为<code>oldInstance</code> 。</span>
<span>此方法用于表征应用于创建给定对象的构造函数或工厂方法。</span>
<span>例如， <code>instantiate</code>的持久委托的方法<code>Field</code>类可以被定义如下：</span>
<pre>  <span>Field f = (Field)oldInstance;
 return new Expression(f, f.getDeclaringClass(), "getField", new Object[]{f.getName()});</span> </pre>
<span>请注意，我们声明返回的表达式的值，以便表达式的值（由<code>getValue</code>返回）将与oldInstance <code>oldInstance</code> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>oldInstance</code> - 将由此表达式创建的实例。 
           </dd>
<dd>
<code>out</code> - 要写入此表达式的流。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             一个值为 
            <code>oldInstance</code> 。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>out</code>是 
            <code>null</code> ，并且该值用于该方法 
           </dd>
</dl> </li>
</ul> <a name="initialize-java.lang.Class-java.lang.Object-java.lang.Object-java.beans.Encoder-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>initialize</h4> <pre>protected void initialize(<a href="../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt; type,
                          <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> oldInstance,
                          <a href="../../java/lang/Object.html" title="class in java.lang">Object</a> newInstance,
                          <a href="../../java/beans/Encoder.html" title="class in java.beans">Encoder</a> out)</pre>
<div class="block">
<span>生成一系列对newInstance具有副作用的<code>newInstance</code> ，使新实例变得<em>相当于</em> <code>oldInstance</code> 。</span>
<span>在这种方法的规范中，我们的意思是相当于在方法返回之后，修改后的实例与其公共API中所有方法的行为不<code>newInstance</code> 。</span>
<p> <span>实施通常通过产生一系列涉及<code>oldInstance</code>及其公开可用状态的“发生了什么”声明来实现这一目标。</span> <span>这些语句使用其<code>writeExpression</code>方法发送到输出流，该方法返回一个涉及在读取期间模拟输入流状态的克隆环境中的元素的表达式。</span> <span>返回的每个语句都将使旧环境中的所有实例都替换为新对象。</span> <span>特别地，引用这些语句的目标，首先作为oldInstance的<code>oldInstance</code>返回作为newInstance的<code>newInstance</code> 。</span> <span>执行这些语句会对两个对象的状态进行增量对齐，这是对新环境中对象的一系列修改。</span> <span>在初始化方法返回之前，应该不可能通过使用它们的公共API来将两个实例分开。</span> <span>最重要的是，用于使这些对象看起来是等效的步骤序列将被输出流记录，并且当流被刷新时将形成实际的输出。</span> </p>
<p> <span>默认实现，调用<code>initialize</code>类型的超类的方法。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>type</code> - 
            <code>type</code>的类型 
           </dd>
<dd>
<code>oldInstance</code> - 要复制的实例。 
           </dd>
<dd>
<code>newInstance</code> - 要修改的实例。 
           </dd>
<dd>
<code>out</code> - 应写入任何初始化语句的流。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>out</code>是 
            <code>null</code>
</dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>