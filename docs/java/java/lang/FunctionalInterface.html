<div class="header">
<div class="subTitle">
     java.lang 
   </div>
<h2 class="title" title="Annotation Type FunctionalInterface">Annotation Type FunctionalInterface</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre><a href="../../java/lang/annotation/Documented.html" title="annotation in java.lang.annotation">@Documented</a>
 <a href="../../java/lang/annotation/Retention.html" title="annotation in java.lang.annotation">@Retention</a>(<a href="../../java/lang/annotation/Retention.html#value--">value</a>=<a href="../../java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</a>)
 <a href="../../java/lang/annotation/Target.html" title="annotation in java.lang.annotation">@Target</a>(<a href="../../java/lang/annotation/Target.html#value--">value</a>=<a href="../../java/lang/annotation/ElementType.html#TYPE">TYPE</a>)
public @interface <span class="memberNameLabel">FunctionalInterface</span></pre>
<div class="block">
<span>使用的信息注释类型，以指示在接口类型声明旨在是一个<i>功能接口</i>由Java语言规范所定义的。</span>
<span>在概念上，功能界面只有一个抽象方法。</span>
<span>由于<a href="../../java/lang/reflect/Method.html#isDefault--">default methods</a>有一个实现，它们不是抽象的。</span>
<span>如果接口声明了一个抽象方法覆盖的公共方法之一<code>java.lang.Object</code> ，也<em>不会</em>向接口的抽象方法计数统计以来的接口的任何实施都会有一个实现从<code>java.lang.Object</code>或其他地方。</span>
<p> <span>请注意，可以使用lambda表达式，方法引用或构造函数引用创建函数接口的实例。</span> </p>
<p> <span>如果使用此注释类型注释类型，则编译器需要生成错误消息，除非：</span> </p>
<ul>
<li> <span>类型是接口类型，而不是注释类型，枚举或类。</span> </li>
<li> <span>注释类型满足功能界面的要求。</span> </li>
</ul>
<p> <span>但是，编译器会将符合功能接口定义的任何接口视为功能接口，而不管<code>FunctionalInterface</code>声明是否存在FunctionalInterface注释。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.8 
       </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
<span>4.3.2。</span>
<span>类对象，9.8功能接口，9.4.3接口方法体</span>
</dd>
</dl> </li>
</ul>
</div>
</div>