<div class="header">
<div class="subTitle">
     compact1, compact2, compact3 
   </div>
<div class="subTitle">
     java.lang.invoke 
   </div>
<h2 class="title" title="Class SwitchPoint">Class SwitchPoint</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>java.lang.invoke.SwitchPoint</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public class <span class="typeNameLabel">SwitchPoint</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<p> <span>A <code>SwitchPoint</code>是可以将状态转换发布到其他线程的对象。</span> <span>切换点最初处于<em>有效</em>状态，但可随时更改为<em>无效</em>状态。</span> <span>无效无法撤销。</span> <span>切换点可以将<em>守卫的一</em>对方法句柄组合成<em>守卫的委托者</em> 。</span> <span>守卫的委托者是一个方法句柄，它将一个旧的方法句柄委托。</span> <span>切换点的状态确定两者中的哪一个获得授权。</span> </p>
<p> <span>单个切换点可用于控制任意数量的方法句柄。</span> <span>（间接地，它可以控制任何数量的呼叫站点）。这是通过使用单个切换点作为工厂来完成的，将任意数量的守卫方法句柄对组合成守卫的委托者。</span> </p>
<p> <span>当一个守卫的委托者是从一个守卫的对创建的时候，该对被包裹在一个新的方法句柄<code>M</code> ，它与创建它的切换点永久关联。</span> <span>每对由目标<code>T</code>和后备<code>F</code> 。</span> <span>当切换点有效时，M的<code>M</code>委托给<code>T</code> 。</span> <span>无效后，调用委托给<code>F</code> 。</span> </p>
<p> <span>无效是全局和立即的，就像每次调用M时，切换点包含一个易失性布尔变量<code>M</code> 。</span> <span>无效也是永久的，这意味着切换点只能改变一次状态。</span> <span>切换点始终在<code>F</code>被委托后无效。</span> <span>此时<code>guardWithTest</code>可能会忽略<code>T</code>并返回<code>F</code> 。</span> </p>
<p> <span>下面是一个切换点的例子：</span> </p>
<blockquote>
<span><pre><code>
MethodHandle MH_strcat = MethodHandles.lookup()
    .findVirtual(String.class, "concat", MethodType.methodType(String.class, String.class));
SwitchPoint spt = new SwitchPoint();
assert(!spt.hasBeenInvalidated());
// the following steps may be repeated to re-use the same switch point:
MethodHandle worker1 = MH_strcat;
MethodHandle worker2 = MethodHandles.permuteArguments(MH_strcat, MH_strcat.type(), 1, 0);
MethodHandle worker = spt.guardWithTest(worker1, worker2);
assertEquals("method", (String) worker.invokeExact("met", "hod"));
SwitchPoint.invalidateAll(new SwitchPoint[]{ spt });
assert(spt.hasBeenInvalidated());
assertEquals("hodmet", (String) worker.invokeExact("met", "hod"));
 </code></pre></span>
</blockquote>
<p style="font-size:smaller;"> <span><em>讨论：</em>切换点在没有子类化的情况下是有用的。</span> <span>他们也可能被分类。</span> <span>这可能是有用的，以便将应用程序特定的无效逻辑与切换点相关联。</span> <span>请注意，切换点与其生成和使用的方法句柄之间没有永久关联。</span> <span>垃圾收集器可以独立于开关点本身的寿命，收集切换点产生或消耗的方法手柄。</span> </p>
<p style="font-size:smaller;"> <span><em>实现注意：</em>切换点的行为就像在<code>MutableCallSite</code>之上实现<a href="../../../java/lang/invoke/MutableCallSite.html" title="class java.lang.invoke">一样</a> ，大致如下：</span> </p>
<blockquote>
<span><pre><code>
public class SwitchPoint {
  private static final MethodHandle
    K_true  = MethodHandles.constant(boolean.class, true),
    K_false = MethodHandles.constant(boolean.class, false);
  private final MutableCallSite mcs;
  private final MethodHandle mcsInvoker;
  public SwitchPoint() {
    this.mcs = new MutableCallSite(K_true);
    this.mcsInvoker = mcs.dynamicInvoker();
  }
  public MethodHandle guardWithTest(
                MethodHandle target, MethodHandle fallback) {
    // Note:  mcsInvoker is of type ()boolean.
    // Target and fallback may take any arguments, but must have the same type.
    return MethodHandles.guardWithTest(this.mcsInvoker, target, fallback);
  }
  public static void invalidateAll(SwitchPoint[] spts) {
    List&amp;lt;MutableCallSite&amp;gt; mcss = new ArrayList&amp;lt;&amp;gt;();
    for (SwitchPoint spt : spts)  mcss.add(spt.mcs);
    for (MutableCallSite mcs : mcss)  mcs.setTarget(K_false);
    MutableCallSite.syncAll(mcss.toArray(new MutableCallSite[0]));
  }
}
 </code></pre></span>
</blockquote>
</div> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/SwitchPoint.html#SwitchPoint--">SwitchPoint</a></span>()</code>
<div class="block">
              创建一个新的切换点。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t1"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/SwitchPoint.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">guardWithTest</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> fallback)</code>
<div class="block">
              返回一个方法句柄，它始终将它们委托给目标或后备。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/SwitchPoint.html#hasBeenInvalidated--">hasBeenInvalidated</a></span>()</code>
<div class="block">
              确定此切换点是否已被无效。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/SwitchPoint.html#invalidateAll-java.lang.invoke.SwitchPoint:A-">invalidateAll</a></span>(<a href="../../../java/lang/invoke/SwitchPoint.html" title="class in java.lang.invoke">SwitchPoint</a>[] switchPoints)</code>
<div class="block">
              将所有给定的切换点设置为无效状态。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="SwitchPoint--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>SwitchPoint</h4> <pre>public SwitchPoint()</pre>
<div class="block">
            创建一个新的切换点。 
          </div> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="hasBeenInvalidated--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>hasBeenInvalidated</h4> <pre>public boolean hasBeenInvalidated()</pre>
<div class="block">
<span>确定此切换点是否已被无效。</span>
<p style="font-size:smaller;"> <span><em>讨论：</em>由于<em>无效</em>的单向性质，一旦切换点开始返回<code>hasBeenInvalidated</code> ，将来会一直这样做。</span> <span>另一方面，由于另一个线程的请求，其他线程可见的有效切换点可能在任何时候无效。</span> </p>
<p style="font-size:smaller;"> <span>由于无效是一个全局和立即的操作，所以在有效的切换点上执行此查询必须与可能导致无效的任何其他线程进行内部排序。</span> <span>因此，该查询可能是昂贵的。</span> <span>建立该查询切换点的失效状态的布尔值的方法处理的推荐方法<code>s</code>是调用<code>s.guardWithTest</code>上<a href="../../../java/lang/invoke/MethodHandles.html#constant-java.lang.Class-java.lang.Object-"><code>constant</code></a>真假的方法处理。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果此切换点已被无效，则为true 
           </dd>
</dl> </li>
</ul> <a name="guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>guardWithTest</h4> <pre>public <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> guardWithTest(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> target,
                                  <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a> fallback)</pre>
<div class="block">
<span>返回一个方法句柄，它始终将它们委托给目标或后备。</span>
<span>只要切换点有效，方法句柄将正确地委派给目标。</span>
<span>之后，它将永久地委托回退。</span>
<p> <span>目标和后备必须是完全相同的方法类型，结果组合方法句柄也将是这种类型。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>target</code> - 切换点选择的方法句柄，只要它有效 
           </dd>
<dd>
<code>fallback</code> - 切换点无效后选择的方法句柄 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             总是调用目标或后备的组合方法句柄 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果两种方法类型不匹配 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>MethodHandles.guardWithTest(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a>
</dd>
</dl> </li>
</ul> <a name="invalidateAll-java.lang.invoke.SwitchPoint:A-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>invalidateAll</h4> <pre>public static void invalidateAll(<a href="../../../java/lang/invoke/SwitchPoint.html" title="class in java.lang.invoke">SwitchPoint</a>[] switchPoints)</pre>
<div class="block">
<span>将所有给定的切换点设置为无效状态。</span>
<span>执行此呼叫后，任何线程都不会发现任何切换点处于有效状态。</span>
<p> <span>这个操作可能是昂贵的，应该谨慎使用。</span> <span>如果可能，应对缓冲器进行缓冲，以便对交换点集合进行批处理。</span> </p>
<p> <span>如果<code>switchPoints</code>包含一个空元素，那么<code>NullPointerException</code>将被提出。</span> <span>在这种情况下，方法返回异常之前，可能会处理数组中的一些非空元素。</span> <span>哪些元素（如果有的话）是依赖于实现的。</span> </p>
<p style="font-size:smaller;"> <span><em>讨论：</em>出于性能原因， <code>invalidateAll</code>不是单个切换点上的虚拟方法，而是适用于一组切换点。</span> <span>一些实现可能产生用于处理一个或多个无效操作的大的固定开销成本，但是对于每个额外的无效，都需要较小的增量成本。</span> <span>在任何情况下，该操作可能是昂贵的，因为其他线程可能必须以某种方式中断，以便使它们注意更新的切换点状态。</span> <span>然而，可以观察到，使多个切换点无效的单个呼叫与多个呼叫具有相同的形式效果，每个呼叫仅在一个切换点上。</span> </p>
<p style="font-size:smaller;"> <span><em>实现注意：</em>简单实现<code>SwitchPoint</code>可以使用私人<a href="../../../java/lang/invoke/MutableCallSite.html" title="class java.lang.invoke"><code>MutableCallSite</code></a>发布一个开关点的状态。</span> <span>在这种实现中， <code>invalidateAll</code>方法可以简单地更改呼叫站点的目标，并发出一个呼叫到所有私人呼叫站点的<a href="../../../java/lang/invoke/MutableCallSite.html#syncAll-java.lang.invoke.MutableCallSite:A-">synchronize</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>switchPoints</code> - 要同步的呼叫站点数组 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>switchPoints</code>数组引用为空或数组包含一个空值 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>