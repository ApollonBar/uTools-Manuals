<div class="header">
<h1 class="title" title="Package">Package java.lang.ref</h1>
<div class="docSummary">
<div class="block">
      提供参考对象类，它支持与垃圾收集器的有限度的交互。 
    </div>
</div>
<p>See: <a href="#package.description">描述</a></p>
</div><div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table border="0" cellpadding="3" cellspacing="0" class="typeSummary" summary="Class Summary table, listing classes, and an explanation">
<caption>
<span>类摘要</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">类</th>
<th class="colLast" scope="col">描述</th>
</tr>
</tbody>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/ref/PhantomReference.html" title="class in java.lang.ref">PhantomReference</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
           在收集者确定其指示物可能被回收之后排入队列的Phantom参考对象。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/lang/ref/Reference.html" title="class in java.lang.ref">Reference</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
           参考对象的抽象基类。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/ref/ReferenceQueue.html" title="class in java.lang.ref">ReferenceQueue</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
           在检测到适当的可达性更改后，引用队列被垃圾收集器附加到哪个已注册的参考对象。 
         </div> </td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/lang/ref/SoftReference.html" title="class in java.lang.ref">SoftReference</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
           软参考对象，由垃圾收集器根据内存需求自行清除。 
         </div> </td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/ref/WeakReference.html" title="class in java.lang.ref">WeakReference</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">
           弱参考对象，不会阻止其指定对象的最终确定，最终确定，然后被回收。 
         </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<a name="package.description">
<!-- --> </a>
<h2 title="Package java.lang.ref Description">Package java.lang.ref Description</h2>
<div class="block">
     Provides reference-object classes, which support a limited degree of interaction with the garbage collector. A program may use a reference object to maintain a reference to some other object in such a way that the latter object may still be reclaimed by the collector. A program may also arrange to be notified some time after the collector has determined that the reachability of a given object has changed. 
    <h2>Package Specification</h2> A 
    <em>reference object</em> encapsulates a reference to some other object so that the reference itself may be examined and manipulated like any other object. Three types of reference objects are provided, each weaker than the last: 
    <em>soft</em>, 
    <em>weak</em>, and 
    <em>phantom</em>. Each type corresponds to a different level of reachability, as defined below. Soft references are for implementing memory-sensitive caches, weak references are for implementing canonicalizing mappings that do not prevent their keys (or values) from being reclaimed, and phantom references are for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism. 
    <p> Each reference-object type is implemented by a subclass of the abstract base <code><a href="../../../java/lang/ref/Reference.html" title="class in java.lang.ref"><code>Reference</code></a></code> class. An instance of one of these subclasses encapsulates a single reference to a particular object, called the <em>referent</em>. Every reference object provides methods for getting and clearing the reference. Aside from the clearing operation reference objects are otherwise immutable, so no <code>set</code> operation is provided. A program may further subclass these subclasses, adding whatever fields and methods are required for its purposes, or it may use these subclasses without change. </p>
<h3>Notification</h3> A program may request to be notified of changes in an object's reachability by 
    <em>registering</em> an appropriate reference object with a 
    <em>reference queue</em> at the time the reference object is created. Some time after the garbage collector determines that the reachability of the referent has changed to the value corresponding to the type of the reference, it will add the reference to the associated queue. At this point, the reference is considered to be 
    <em>enqueued</em>. The program may remove references from a queue either by polling or by blocking until a reference becomes available. Reference queues are implemented by the 
    <code><a href="../../../java/lang/ref/ReferenceQueue.html" title="class in java.lang.ref"><code>ReferenceQueue</code></a></code> class. 
    <p> The relationship between a registered reference object and its queue is one-sided. That is, a queue does not keep track of the references that are registered with it. If a registered reference becomes unreachable itself, then it will never be enqueued. It is the responsibility of the program using reference objects to ensure that the objects remain reachable for as long as the program is interested in their referents. </p>
<p> While some programs will choose to dedicate a thread to removing reference objects from one or more queues and processing them, this is by no means necessary. A tactic that often works well is to examine a reference queue in the course of performing some other fairly-frequent action. For example, a hashtable that uses weak references to implement weak keys could poll its reference queue each time the table is accessed. This is how the <code><a href="../../../java/util/WeakHashMap.html" title="class in java.util"><code>WeakHashMap</code></a></code> class works. Because the <code><a href="../../../java/lang/ref/ReferenceQueue.html#poll--"><code>ReferenceQueue.poll</code></a></code> method simply checks an internal data structure, this check will add little overhead to the hashtable access methods. </p>
<h3>Automatically-cleared references</h3> Soft and weak references are automatically cleared by the collector before being added to the queues with which they are registered, if any. Therefore soft and weak references need not be registered with a queue in order to be useful, while phantom references do. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable. 
    <a name="reachability"></a>
<h3>Reachability</h3> Going from strongest to weakest, the different levels of reachability reflect the life cycle of an object. They are operationally defined as follows: 
    <ul>
<li> An object is <em>strongly reachable</em> if it can be reached by some thread without traversing any reference objects. A newly-created object is strongly reachable by the thread that created it. </li>
<li> An object is <em>softly reachable</em> if it is not strongly reachable but can be reached by traversing a soft reference. </li>
<li> An object is <em>weakly reachable</em> if it is neither strongly nor softly reachable but can be reached by traversing a weak reference. When the weak references to a weakly-reachable object are cleared, the object becomes eligible for finalization. </li>
<li> An object is <em>phantom reachable</em> if it is neither strongly, softly, nor weakly reachable, it has been finalized, and some phantom reference refers to it. </li>
<li> Finally, an object is <em>unreachable</em>, and therefore eligible for reclamation, when it is not reachable in any of the above ways. </li>
</ul>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
      1.2 
     <!--
<h2>Related Documentation</h2>

For overviews, tutorials, examples, guides, and tool documentation, please see:
<ul>
  <li><a href="">##### REFER TO NON-SPEC DOCUMENTATION HERE #####</a>
</ul>
-->
</dd>
</dl>
</div>