<div class="header">
<div class="subTitle">
     java.lang 
   </div>
<h2 class="title" title="Annotation Type SafeVarargs">Annotation Type SafeVarargs</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre><a href="../../java/lang/annotation/Documented.html" title="annotation in java.lang.annotation">@Documented</a>
 <a href="../../java/lang/annotation/Retention.html" title="annotation in java.lang.annotation">@Retention</a>(<a href="../../java/lang/annotation/Retention.html#value--">value</a>=<a href="../../java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</a>)
 <a href="../../java/lang/annotation/Target.html" title="annotation in java.lang.annotation">@Target</a>(<a href="../../java/lang/annotation/Target.html#value--">value</a>={<a href="../../java/lang/annotation/ElementType.html#CONSTRUCTOR">CONSTRUCTOR</a>,<a href="../../java/lang/annotation/ElementType.html#METHOD">METHOD</a>})
public @interface <span class="memberNameLabel">SafeVarargs</span></pre>
<div class="block">
<span>程序员断言注释方法或构造函数的正文不会对其varargs参数执行潜在的不安全操作。</span>
<span>将此注释应用于方法或构造函数可抑制关于<i>不可重新引用的</i>变量arity（vararg）类型的未经检查的警告，并禁止在调用站点创建参数化数组的未检查警告。</span>
<p> <span>除了<a href="../../java/lang/annotation/Target.html" title="java.lang.annotation中的注释"><code>@Target</code></a>元注释的使用限制外，还需要编译器对此注释类型实施其他使用限制;</span> <span>如果方法或构造函数声明使用<code>@SafeVarargs</code>注释注释，则是编译时错误，并且：</span> </p>
<ul>
<li> <span>声明是一种固定的方法或构造函数</span> </li>
<li> <span>声明是一种既不是<code>static</code>也不是<code>final</code>的可变方法。</span> </li>
</ul>
<p> <span>当这种注释类型应用于方法或构造函数声明时，鼓励编译器发出警告：</span> </p>
<ul>
<li> <span>变量arity参数具有可重新定义的元素类型，包括原始类型<code>Object</code>和<code>String</code> 。</span> <span>（可注释元素类型不会发生此注释类型禁止的未选中的警告。）</span> </li>
<li> <span>方法或构造函数声明的正文执行潜在的不安全操作，例如对生成未选中警告的变量arity参数数组的元素的赋值。</span> <span>某些不安全的操作不会触发未检查的警告。</span> <span>例如，</span>
<blockquote>
<span><pre>
 @SafeVarargs // Not actually safe!
 static void m(List&lt;String&gt;... stringLists) {
   Object[] array = stringLists;
   List&lt;Integer&gt; tmpList = Arrays.asList(42);
   array[0] = tmpList; // Semantically invalid, but compiles without warnings
   String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!
 }
 </pre></span>
</blockquote> <span>在运行时导致<code>ClassCastException</code> 。</span> <p> <span>该平台的未来版本可能要求对这种不安全操作的编译器错误。</span> </p></li>
</ul>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.7 
       </dd>
<dt>
<span class="simpleTagLabel">See <cite> The Java™ Language Specification</cite>:</span>
</dt>
<dd>
         4.7可重用类型，8.4.1正式参数，9.6.3.7 @SafeVarargs 
       </dd>
</dl> </li>
</ul>
</div>
</div>