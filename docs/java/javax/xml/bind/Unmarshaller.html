<div class="header">
<div class="subTitle">
     javax.xml.bind 
   </div>
<h2 class="title" title="Interface Unmarshaller">Interface Unmarshaller</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
        所有已知实现类：
       </dt>
<dd>
<span><a href="../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html" title="javax.xml.bind.helpers中的类">AbstractUnmarshallerImpl</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public interface <span class="typeNameLabel">Unmarshaller</span></pre>
<div class="block">
<span><tt>Unmarshaller</tt>类管理将XML数据反序列化为新创建的Java内容树的过程，可选地在未编组的情况下验证XML数据。</span>
<span>它为许多不同的输入类型提供了未装模式的超载。</span>
<p> <span>从文件解组：</span> </p>
<blockquote>
<span><pre>
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();
       Object o = u.unmarshal( new File( "nosferatu.xml" ) );
    </pre></span>
</blockquote>
<p> <span>从InputStream解组：</span> </p>
<blockquote>
<span><pre>
       InputStream is = new FileInputStream( "nosferatu.xml" );
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();
       Object o = u.unmarshal( is );
    </pre></span>
</blockquote>
<p> <span>从网址解组：</span> </p>
<blockquote>
<span><pre>
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();
       URL url = new URL( "http://beaker.east/nosferatu.xml" );
       Object o = u.unmarshal( url );
    </pre></span>
</blockquote>
<p> <span>使用javax.xml.transform.stream.StreamSource从StringBuffer <tt>解组</tt> ：</span> </p>
<blockquote>
<span><pre>
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();
       StringBuffer xmlStr = new StringBuffer( "&lt;?xml version="1.0"?&gt;..." );
       Object o = u.unmarshal( new StreamSource( new StringReader( xmlStr.toString() ) ) );
    </pre></span>
</blockquote>
<p> <span>从<tt>org.w3c.dom.Node解组</tt> ：</span> </p>
<blockquote>
<span><pre>
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();

       DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
       dbf.setNamespaceAware(true);
       DocumentBuilder db = dbf.newDocumentBuilder();
       Document doc = db.parse(new File( "nosferatu.xml"));

       Object o = u.unmarshal( doc );
    </pre></span>
</blockquote>
<p> <span>使用客户端从<tt>javax.xml.transform.sax.SAXSource</tt>解组指定的验证SAX2.0解析器：</span> </p>
<blockquote>
<span><pre>
       // configure a validating SAX2.0 parser (Xerces2)
       static final String JAXP_SCHEMA_LANGUAGE =
           "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
       static final String JAXP_SCHEMA_LOCATION =
           "http://java.sun.com/xml/jaxp/properties/schemaSource";
       static final String W3C_XML_SCHEMA =
           "http://www.w3.org/2001/XMLSchema";

       System.setProperty( "javax.xml.parsers.SAXParserFactory",
                           "org.apache.xerces.jaxp.SAXParserFactoryImpl" );

       SAXParserFactory spf = SAXParserFactory.newInstance();
       spf.setNamespaceAware(true);
       spf.setValidating(true);
       SAXParser saxParser = spf.newSAXParser();

       try {
           saxParser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);
           saxParser.setProperty(JAXP_SCHEMA_LOCATION, "http://....");
       } catch (SAXNotRecognizedException x) {
           // exception handling omitted
       }

       XMLReader xmlReader = saxParser.getXMLReader();
       SAXSource source =
           new SAXSource( xmlReader, new InputSource( "http://..." ) );

       // Setup JAXB to unmarshal
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();
       ValidationEventCollector vec = new ValidationEventCollector();
       u.setEventHandler( vec );

       // turn off the JAXB provider's default validation mechanism to
       // avoid duplicate validation
       u.setValidating( false )

       // unmarshal
       Object o = u.unmarshal( source );

       // check for events
       if( vec.hasEvents() ) {
          // iterate over events
       }
    </pre></span>
</blockquote>
<p> <span>从StAX XMLStreamReader解集：</span> </p>
<blockquote>
<span><pre>
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();

       javax.xml.stream.XMLStreamReader xmlStreamReader =
           javax.xml.stream.XMLInputFactory().newInstance().createXMLStreamReader( ... );

       Object o = u.unmarshal( xmlStreamReader );
    </pre></span>
</blockquote>
<p> <span>从StAX XMLEventReader解组：</span> </p>
<blockquote>
<span><pre>
       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();

       javax.xml.stream.XMLEventReader xmlEventReader =
           javax.xml.stream.XMLInputFactory().newInstance().createXMLEventReader( ... );

       Object o = u.unmarshal( xmlEventReader );
    </pre></span>
</blockquote>
<p> <span><a name="unmarshalEx"></a> <b>解组XML数据</b></span> <br/></p>
<blockquote>
<span>Unmarshalling can deserialize XML data that represents either an entire XML document or a subtree of an XML document. Typically, it is sufficient to use the unmarshalling methods described by <a href="#unmarshalGlobal">Unmarshal root element that is declared globally</a>. These unmarshal methods utilize <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a>'s mapping of global XML element declarations and type definitions to JAXB mapped classes to initiate the unmarshalling of the root element of XML data. When the <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a>'s mappings are not sufficient to unmarshal the root element of XML data, the application can assist the unmarshalling process by using the <a href="#unmarshalByDeclaredType">unmarshal by declaredType methods</a>. These methods are useful for unmarshalling XML data where the root element corresponds to a local element declaration in the schema.</span>
</blockquote>
<blockquote>
<span>An unmarshal method never returns null. If the unmarshal process is unable to unmarshal the root of XML content to a JAXB mapped object, a fatal error is reported that terminates processing by throwing JAXBException.</span>
</blockquote>
<p> <span><a name="unmarshalGlobal">解组</a> <b>名为全局声明的根元素</b></span> <br/></p>
<blockquote>
<span>The unmarshal methods that do not have an <tt>declaredType</tt> parameter use <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a> to unmarshal the root element of an XML data. The <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a> instance is the one that was used to create this <tt>Unmarshaller</tt>. The <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a> instance maintains a mapping of globally declared XML element and type definition names to JAXB mapped classes. The unmarshal method checks if <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a> has a mapping from the root element's XML name and/or <tt>@xsi:type</tt> to a JAXB mapped class. If it does, it umarshalls the XML data using the appropriate JAXB mapped class. Note that when the root element name is unknown and the root element has an <tt>@xsi:type</tt>, the XML data is unmarshalled using that JAXB mapped class as the value of a <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind"><code>JAXBElement</code></a>. When the <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a> object does not have a mapping for the root element's name nor its <tt>@xsi:type</tt>, if it exists, then the unmarshal operation will abort immediately by throwing a <a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind"><code>UnmarshalException</code></a>. This exception scenario can be worked around by using the unmarshal by declaredType methods described in the next subsection.</span>
</blockquote>
<p> <span><a name="unmarshalByDeclaredType"></a> <b>解组通过声明的类型</b></span> <br/></p>
<blockquote>
<span>The unmarshal methods with a <code>declaredType</code> parameter enable an application to deserialize a root element of XML data, even when there is no mapping in <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a> of the root element's XML name. The unmarshaller unmarshals the root element using the application provided mapping specified as the <tt>declaredType</tt> parameter. Note that even when the root element's element name is mapped by <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a>, the <code>declaredType</code> parameter overrides that mapping for deserializing the root element when using these unmarshal methods. Additionally, when the root element of XML data has an <tt>xsi:type</tt> attribute and that attribute's value references a type definition that is mapped to a JAXB mapped class by <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a>, that the root element's <tt>xsi:type</tt> attribute takes precedence over the unmarshal methods <tt>declaredType</tt> parameter. These methods always return a <tt>JAXBElement&lt;declaredType&gt;</tt> instance. The table below shows how the properties of the returned JAXBElement instance are set. <a name="unmarshalDeclaredTypeReturn"></a> <p> </p>
<table border="2" cellpadding="4" rules="all">
<thead>
<tr>
<th align="center" colspan="2"> Unmarshal By Declared Type returned JAXBElement </th>
</tr>
<tr>
<th>JAXBElement Property</th>
<th>Value</th>
</tr>
<tr>
<td>name</td>
<td><code>xml element name</code></td>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td><code>instanceof declaredType</code></td>
</tr>
<tr>
<td>declaredType</td>
<td>unmarshal method <code>declaredType</code> parameter</td>
</tr>
<tr>
<td>scope</td>
<td><code>null</code> <i>(actual scope is unknown)</i></td>
</tr>
</tbody>
</table></span>
</blockquote>
<p> <span>以下是一个例子<a href="#unmarshalByDeclaredType">unmarshal by declaredType method</a> 。</span> </p>
<p> <span>通过declaredType从一个<tt>org.w3c.dom.Node解组</tt> ：</span> </p>
<blockquote>
<span><pre>
       Schema fragment for example
       &lt;xs:schema&gt;
          &lt;xs:complexType name="FooType"&gt;...&lt;\xs:complexType&gt;
          &lt;!-- global element declaration "PurchaseOrder" --&gt;
          &lt;xs:element name="PurchaseOrder"&gt;
              &lt;xs:complexType&gt;
                 &lt;xs:sequence&gt;
                    &lt;!-- local element declaration "foo" --&gt;
                    &lt;xs:element name="foo" type="FooType"/&gt;
                    ...
                 &lt;/xs:sequence&gt;
              &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
       &lt;/xs:schema&gt;

       JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" );
       Unmarshaller u = jc.createUnmarshaller();

       DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
       dbf.setNamespaceAware(true);
       DocumentBuilder db = dbf.newDocumentBuilder();
       Document doc = db.parse(new File( "nosferatu.xml"));
       Element  fooSubtree = ...; // traverse DOM till reach xml element foo, constrained by a
                                  // local element declaration in schema.

       // FooType is the JAXB mapping of the type of local element declaration foo.
       JAXBElement&lt;FooType&gt; foo = u.unmarshal( fooSubtree, FooType.class);
    </pre></span>
</blockquote>
<p> <span><b>支持符合SAX2.0标准的解析器</b></span> <br/></p>
<blockquote>
<span>A client application has the ability to select the SAX2.0 compliant parser of their choice. If a SAX parser is not selected, then the JAXB Provider's default parser will be used. Even though the JAXB Provider's default parser is not required to be SAX2.0 compliant, all providers are required to allow a client application to specify their own SAX2.0 parser. Some providers may require the client application to specify the SAX2.0 parser at schema compile time. See <a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.transform.Source-"><code>unmarshal(Source)</code></a> for more detail.</span>
</blockquote>
<p> <span><b>验证和成型</b></span> <br/></p>
<blockquote>
<span><p> A client application can enable or disable JAXP 1.3 validation mechanism via the <tt>setSchema(javax.xml.validation.Schema)</tt> API. Sophisticated clients can specify their own validating SAX 2.0 compliant parser and bypass the JAXP 1.3 validation mechanism using the <a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.transform.Source-"><code>unmarshal(Source)</code></a> API. </p> <p> Since unmarshalling invalid XML content is defined in JAXB 2.0, the Unmarshaller default validation event handler was made more lenient than in JAXB 1.0. When schema-derived code generated by JAXB 1.0 binding compiler is registered with <a href="../../../javax/xml/bind/JAXBContext.html" title="class in javax.xml.bind"><code>JAXBContext</code></a>, the default unmarshal validation handler is <a href="../../../javax/xml/bind/helpers/DefaultValidationEventHandler.html" title="class in javax.xml.bind.helpers"><code>DefaultValidationEventHandler</code></a> and it terminates the marshal operation after encountering either a fatal error or an error. For a JAXB 2.0 client application, there is no explicitly defined default validation handler and the default event handling only terminates the unmarshal operation after encountering a fatal error. </p></span>
</blockquote>
<p> <span><a name="supportedProps"></a> <b>支持的属性</b></span> <br/></p>
<blockquote>
<span><p> There currently are not any properties required to be supported by all JAXB Providers on Unmarshaller. However, some providers may support their own set of provider specific properties. </p></span>
</blockquote>
<p> <span><a name="unmarshalEventCallback"></a> <b>解组事件回调</b></span> <br/></p>
<blockquote>
<span>The <a href="../../../javax/xml/bind/Unmarshaller.html" title="interface in javax.xml.bind"><code>Unmarshaller</code></a> provides two styles of callback mechanisms that allow application specific processing during key points in the unmarshalling process. In 'class defined' event callbacks, application specific code placed in JAXB mapped classes is triggered during unmarshalling. 'External listeners' allow for centralized processing of unmarshal events in one callback method rather than by type event callbacks. <p> 'Class defined' event callback methods allow any JAXB mapped class to specify its own specific callback methods by defining methods with the following method signature: </p>
<blockquote>
<pre>
   // This method is called immediately after the object is created and before the unmarshalling of this
   // object begins. The callback provides an opportunity to initialize JavaBean properties prior to unmarshalling.
   void beforeUnmarshal(Unmarshaller, Object parent);

   //This method is called after all the properties (except IDREF) are unmarshalled for this object,
   //but before this object is set to the parent object.
   void afterUnmarshal(Unmarshaller, Object parent);
 </pre>
</blockquote> The class defined callback methods should be used when the callback method requires access to non-public methods and/or fields of the class. <p> The external listener callback mechanism enables the registration of a <a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="class in javax.xml.bind"><code>Unmarshaller.Listener</code></a> instance with an <a href="../../../javax/xml/bind/Unmarshaller.html#setListener-javax.xml.bind.Unmarshaller.Listener-"><code>setListener(Listener)</code></a>. The external listener receives all callback events, allowing for more centralized processing than per class defined callback methods. The external listener receives events when unmarshalling proces is marshalling to a JAXB element or to JAXB mapped class. </p> <p> The 'class defined' and external listener event callback methods are independent of each other, both can be called for one event. The invocation ordering when both listener callback methods exist is defined in <a href="../../../javax/xml/bind/Unmarshaller.Listener.html#beforeUnmarshal-java.lang.Object-java.lang.Object-"><code>Unmarshaller.Listener.beforeUnmarshal(Object, Object)</code></a> and <a href="../../../javax/xml/bind/Unmarshaller.Listener.html#afterUnmarshal-java.lang.Object-java.lang.Object-"><code>Unmarshaller.Listener.afterUnmarshal(Object, Object)</code></a>. </p> <p> An event callback method throwing an exception terminates the current unmarshal process. </p></span>
</blockquote>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         JAXB1.0 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../javax/xml/bind/JAXBContext.html" title="javax.xml.bind中的类"><code>JAXBContext</code></a> ， <a href="../../../javax/xml/bind/Marshaller.html" title="javax.xml.bind中的接口"><code>Marshaller</code></a> ， <a href="../../../javax/xml/bind/Validator.html" title="javax.xml.bind中的接口"><code>Validator</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Interface and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="class in javax.xml.bind">Unmarshaller.Listener</a></span></code>
<div class="block">
<p></p>
<span>注册这个类的一个实现的实例与<a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a>从外部侦听解组事件。</span>
</div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t6"><span><a href="javascript:show(32);">弃用的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>&lt;A extends <a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="class in javax.xml.bind.annotation.adapters">XmlAdapter</a>&gt;<br/>A</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#getAdapter-java.lang.Class-">getAdapter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; type)</code>
<div class="block">
              获取与指定类型相关联的适配器。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="class in javax.xml.bind.attachment">AttachmentUnmarshaller</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#getAttachmentUnmarshaller--">getAttachmentUnmarshaller</a></span>()</code> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code><a href="../../../javax/xml/bind/ValidationEventHandler.html" title="interface in javax.xml.bind">ValidationEventHandler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#getEventHandler--">getEventHandler</a></span>()</code>
<div class="block">
              返回当前事件处理程序或默认事件处理程序（如果尚未设置）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code><a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="class in javax.xml.bind">Unmarshaller.Listener</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#getListener--">getListener</a></span>()</code>
<div class="block">
<span>返回<a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind中的类"><code>Unmarshaller.Listener</code></a>注册此<a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a> 。</span>
</div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#getProperty-java.lang.String-">getProperty</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)</code>
<div class="block">
              获取Unmarshaller的底层实现中的 
             <tt>特定属性</tt> 。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code><a href="../../../javax/xml/validation/Schema.html" title="class in javax.xml.validation">Schema</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#getSchema--">getSchema</a></span>()</code>
<div class="block">
<span>获取用于执行解密时间验证的JAXP 1.3 <a href="../../../javax/xml/validation/Schema.html" title="javax.xml.validation中的类"><code>Schema</code></a>对象。</span>
</div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../../../javax/xml/bind/UnmarshallerHandler.html" title="interface in javax.xml.bind">UnmarshallerHandler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#getUnmarshallerHandler--">getUnmarshallerHandler</a></span>()</code>
<div class="block">
              获取可以用作XML管道中组件的解组员处理程序对象。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#isValidating--">isValidating</a></span>()</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">由于JAXB2.0，请参阅<a href="../../../javax/xml/bind/Unmarshaller.html#getSchema--"><code>getSchema()</code></a></span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>&lt;A extends <a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="class in javax.xml.bind.annotation.adapters">XmlAdapter</a>&gt;<br/>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setAdapter-java.lang.Class-A-">setAdapter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; type, A adapter)</code>
<div class="block">
<span>相关联的配置实例<a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters中的类"><code>XmlAdapter</code></a>与此unmarshaller。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setAdapter-javax.xml.bind.annotation.adapters.XmlAdapter-">setAdapter</a></span>(<a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="class in javax.xml.bind.annotation.adapters">XmlAdapter</a> adapter)</code>
<div class="block">
<span>相关联的配置实例<a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters中的类"><code>XmlAdapter</code></a>与此unmarshaller。</span>
</div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setAttachmentUnmarshaller-javax.xml.bind.attachment.AttachmentUnmarshaller-">setAttachmentUnmarshaller</a></span>(<a href="../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="class in javax.xml.bind.attachment">AttachmentUnmarshaller</a> au)</code>
<div class="block">
              将解析cid，content-id URI的上下文关联到作为附件传递的二进制数据。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setEventHandler-javax.xml.bind.ValidationEventHandler-">setEventHandler</a></span>(<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="interface in javax.xml.bind">ValidationEventHandler</a> handler)</code>
<div class="block">
              允许申请注册一个 
             <tt>ValidationEventHandler</tt> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setListener-javax.xml.bind.Unmarshaller.Listener-">setListener</a></span>(<a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="class in javax.xml.bind">Unmarshaller.Listener</a> listener)</code>
<div class="block">
<span>注册unmarshal事件回调<a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind中的类"><code>Unmarshaller.Listener</code></a>与这<a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a> 。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setProperty-java.lang.String-java.lang.Object-">setProperty</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> name, <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> value)</code>
<div class="block">
              设置基础实现中的特定属性 
             <tt>Unmarshaller</tt> 。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setSchema-javax.xml.validation.Schema-">setSchema</a></span>(<a href="../../../javax/xml/validation/Schema.html" title="class in javax.xml.validation">Schema</a> schema)</code>
<div class="block">
<span>指定应用于验证后续解组操作的JAXP 1.3 <a href="../../../javax/xml/validation/Schema.html" title="javax.xml.validation中的类"><code>Schema</code></a>对象。</span>
</div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#setValidating-boolean-">setValidating</a></span>(boolean validating)</code>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<div class="block">
<span><span class="deprecationComment">因为JAXB2.0，请参阅<a href="../../../javax/xml/bind/Unmarshaller.html#setSchema-javax.xml.validation.Schema-"><code>setSchema(javax.xml.validation.Schema)</code></a></span></span>
</div>
</div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-java.io.File-">unmarshal</a></span>(<a href="../../../java/io/File.html" title="class in java.io">File</a> f)</code>
<div class="block">
              从指定的文件解组XML数据并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-org.xml.sax.InputSource-">unmarshal</a></span>(<a href="../../../org/xml/sax/InputSource.html" title="class in org.xml.sax">InputSource</a> source)</code>
<div class="block">
              从指定的SAX InputSource解组XML数据并返回结果内容树。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-java.io.InputStream-">unmarshal</a></span>(<a href="../../../java/io/InputStream.html" title="class in java.io">InputStream</a> is)</code>
<div class="block">
              从指定的InputStream中解组XML数据，并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-org.w3c.dom.Node-">unmarshal</a></span>(<a href="../../../org/w3c/dom/Node.html" title="interface in org.w3c.dom">Node</a> node)</code>
<div class="block">
              从指定的DOM树中解组全局XML数据，并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-org.w3c.dom.Node-java.lang.Class-">unmarshal</a></span>(<a href="../../../org/w3c/dom/Node.html" title="interface in org.w3c.dom">Node</a> node, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)</code>
<div class="block">
              通过JAXB映射 
             <tt>declaredType</tt>解组XML数据，并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-java.io.Reader-">unmarshal</a></span>(<a href="../../../java/io/Reader.html" title="class in java.io">Reader</a> reader)</code>
<div class="block">
              从指定的Reader中解组XML数据并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.transform.Source-">unmarshal</a></span>(<a href="../../../javax/xml/transform/Source.html" title="interface in javax.xml.transform">Source</a> source)</code>
<div class="block">
              从指定的XML Source中解组XML数据并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.transform.Source-java.lang.Class-">unmarshal</a></span>(<a href="../../../javax/xml/transform/Source.html" title="interface in javax.xml.transform">Source</a> source, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)</code>
<div class="block">
              通过 
             <tt>declaredType</tt>从指定的XML源解组XML数据，并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-java.net.URL-">unmarshal</a></span>(<a href="../../../java/net/URL.html" title="class in java.net">URL</a> url)</code>
<div class="block">
              从指定的URL解组XML数据并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.stream.XMLEventReader-">unmarshal</a></span>(<a href="../../../javax/xml/stream/XMLEventReader.html" title="interface in javax.xml.stream">XMLEventReader</a> reader)</code>
<div class="block">
              从指定的解析器解组XML数据并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.stream.XMLEventReader-java.lang.Class-">unmarshal</a></span>(<a href="../../../javax/xml/stream/XMLEventReader.html" title="interface in javax.xml.stream">XMLEventReader</a> reader, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)</code>
<div class="block">
              将根元素解组到JAXB映射 
             <tt>declaredType</tt>并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.stream.XMLStreamReader-">unmarshal</a></span>(<a href="../../../javax/xml/stream/XMLStreamReader.html" title="interface in javax.xml.stream">XMLStreamReader</a> reader)</code>
<div class="block">
              从指定的解析器解组XML数据并返回生成的内容树。 
            </div> </td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.stream.XMLStreamReader-java.lang.Class-">unmarshal</a></span>(<a href="../../../javax/xml/stream/XMLStreamReader.html" title="interface in javax.xml.stream">XMLStreamReader</a> reader, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)</code>
<div class="block">
              将根元素解组到JAXB映射 
             <tt>declaredType</tt>并返回生成的内容树。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="unmarshal-java.io.File-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../java/io/File.html" title="class in java.io">File</a> f)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的文件解组XML数据并返回生成的内容树。</span>
<p> <span>实现<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>f</code> - 从中解开XML数据的文件 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果file参数为null 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-java.io.InputStream-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../java/io/InputStream.html" title="class in java.io">InputStream</a> is)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的InputStream中解组XML数据，并返回生成的内容树。</span>
<span>使用这种形式的unmarshal API时，验证事件位置信息可能不完整。</span>
<p> <span>实现<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>is</code> - 从中解开XML数据的InputStream 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在解组时出现意外的错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果InputStream参数为空 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-java.io.Reader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../java/io/Reader.html" title="class in java.io">Reader</a> reader)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的Reader中解组XML数据并返回生成的内容树。</span>
<span>使用此形式的解密API时，验证事件位置信息可能不完整，因为Reader不提供系统ID。</span>
<p> <span>实现<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>reader</code> - 解读XML数据的读者 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果InputStream参数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-java.net.URL-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../java/net/URL.html" title="class in java.net">URL</a> url)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的URL解组XML数据并返回生成的内容树。</span>
<p> <span>实施<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>url</code> - 从中解开XML数据的URL 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果URL参数为空 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-org.xml.sax.InputSource-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../org/xml/sax/InputSource.html" title="class in org.xml.sax">InputSource</a> source)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的SAX InputSource解组XML数据并返回结果内容树。</span>
<p> <span>实施<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>source</code> - 解密XML数据的输入源 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果InputSource参数为空 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-org.w3c.dom.Node-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../org/w3c/dom/Node.html" title="interface in org.w3c.dom">Node</a> node)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的DOM树中解组全局XML数据，并返回生成的内容树。</span>
<p> <span>实现<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>node</code> - 从中解开XML数据的文档/元素。</span>
<span>呼叫者至少必须支持Document和Element。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果Node参数为空 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-org.w3c.dom.Node-java.lang.Class-"><code>unmarshal(org.w3c.dom.Node, Class)</code></a>
</dd>
</dl> </li>
</ul> <a name="unmarshal-org.w3c.dom.Node-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt; unmarshal(<a href="../../../org/w3c/dom/Node.html" title="interface in org.w3c.dom">Node</a> node,
                             <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)
                      throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>通过JAXB映射<tt>declaredType</tt>解组XML数据，并返回生成的内容树。</span>
<p> <span>实施<a href="#unmarshalByDeclaredType">Unmarshal by Declared Type</a></span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>node</code> - 从中解开XML数据的文档/元素。</span>
<span>呼叫者至少必须支持Document和Element。</span>
</dd>
<dd>
<code>declaredType</code> - 适当的JAXB映射类保存 
            <tt>node</tt>的XML数据。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<a href="#unmarshalDeclaredTypeReturn">JAXB Element</a>代表 
            <tt>node</tt>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果任何参数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-javax.xml.transform.Source-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../javax/xml/transform/Source.html" title="interface in javax.xml.transform">Source</a> source)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的XML Source中解组XML数据并返回生成的内容树。</span>
<p> <span>实现<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
<p> <span><a name="saxParserPlugable"></a> <b>SAX 2.0解析器可插拔性</b></span> </p>
<p> <span>客户端应用程序可以选择不使用JAXB提供程序提供的默认解析器机制。</span> <span>任何SAX 2.0兼容解析器可以替代JAXB提供程序的默认机制。</span> <span>要做到这一点，客户端应用程序必须正确配置<tt>SAXSource</tt>包含由SAX 2.0解析器提供实现的<tt>XMLReader。</tt></span> <span>如果XMLReader在其上<tt>注册</tt>了一个<tt>org.xml.sax.ErrorHandler</tt> ，则将由JAXB提供者替换，以便通过JAXB的<tt>ValidationEventHandler</tt>机制报告验证错误。</span> <span>如果<tt>SAXSource</tt>不包含<tt>XMLReader</tt> ，则将使用JAXB提供程序的默认解析器机制。</span> </p>
<p> <span>此解析器替换机制也可用于替换JAXB提供者的解组时间验证引擎。</span> <span>客户端应用程序必须正确配置其SAX 2.0兼容解析器才能执行验证（如上例所示）。</span> <span>在<tt>解组</tt>操作期间解析器遇到的任何<tt>SAXParserExceptions</tt>将由JAXB提供商处理，并转换为JAXB <tt>ValidationEvent</tt>对象，这些对象将通过<tt>Unmarshaller</tt>注册的<tt>ValidationEventHandler</tt>报告回客户端。</span> <span><i>注意：</i>指定替代验证SAX 2.0解析器进行解组合并不一定取代JAXB提供程序用于执行按需验证的验证引擎。</span> </p>
<p> <span>客户端应用程序指定在解密期间使用的备用解析器机制的唯一方法是通过<tt>unmarshal(SAXSource)</tt> API。</span> <span>所有其他形式的解组方法（文件，URL，节点等）将使用JAXB提供程序的默认解析器和验证器机制。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>source</code> - 解析XML数据的XML源（提供者只需要支持SAXSource，DOMSource和StreamSource） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果Source参数为null 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.transform.Source-java.lang.Class-"><code>unmarshal(javax.xml.transform.Source, Class)</code></a>
</dd>
</dl> </li>
</ul> <a name="unmarshal-javax.xml.transform.Source-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt; unmarshal(<a href="../../../javax/xml/transform/Source.html" title="interface in javax.xml.transform">Source</a> source,
                             <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)
                      throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>通过<tt>declaredType</tt>从指定的XML源解组XML数据，并返回结果内容树。</span>
<p> <span>实现<a href="#unmarshalByDeclaredType">Unmarshal by Declared Type</a></span> </p>
<p> <span>见<a href="#saxParserPlugable">SAX 2.0 Parser Pluggability</a></span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>source</code> - 解析XML数据的XML源（提供者只需要支持SAXSource，DOMSource和StreamSource） 
           </dd>
<dd>
<code>declaredType</code> - 适当的JAXB映射类保存 
            <tt>source</tt>的xml根元素 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             Java内容根植于 
            <a href="#unmarshalDeclaredTypeReturn">JAXB Element</a>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在解组时出现意外的错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果任何参数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-javax.xml.stream.XMLStreamReader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../javax/xml/stream/XMLStreamReader.html" title="interface in javax.xml.stream">XMLStreamReader</a> reader)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的解析器解组XML数据并返回生成的内容树。</span>
<p> <span>实现<a href="#unmarshalGlobal">Unmarshal Global Root Element</a> 。</span> </p>
<p> <span>该方法假定解析器处于START_DOCUMENT或START_ELEMENT事件。</span> <span>解组将从此开始事件到相应的结束事件。</span> <span>如果此方法成功返回，则<tt>reader</tt>将在结束事件之后指向该令牌。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>reader</code> - 要读取的解析器。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>reader</tt>参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果 
            <tt>reader</tt>未指向START_DOCUMENT或START_ELEMENT事件。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.stream.XMLStreamReader-java.lang.Class-"><code>unmarshal(javax.xml.stream.XMLStreamReader, Class)</code></a>
</dd>
</dl> </li>
</ul> <a name="unmarshal-javax.xml.stream.XMLStreamReader-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt; unmarshal(<a href="../../../javax/xml/stream/XMLStreamReader.html" title="interface in javax.xml.stream">XMLStreamReader</a> reader,
                             <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)
                      throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>将根元素解组到JAXB映射<tt>declaredType</tt>并返回生成的内容树。</span>
<p> <span>该方法实现<a href="#unmarshalByDeclaredType">unmarshal by declaredType</a> 。</span> </p>
<p> <span>该方法假定解析器处于START_DOCUMENT或START_ELEMENT事件。</span> <span>解组将从此开始事件到相应的结束事件。</span> <span>如果此方法成功返回，则<tt>reader</tt>将在结束事件之后指向该令牌。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>reader</code> - 要读取的解析器。 
           </dd>
<dd>
<code>declaredType</code> - 适当的JAXB映射类保存 
            <tt>reader</tt>的START_ELEMENT XML数据。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             内容树根植于 
            <a href="#unmarshalDeclaredTypeReturn">JAXB Element representation</a>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果任何参数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="unmarshal-javax.xml.stream.XMLEventReader-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> unmarshal(<a href="../../../javax/xml/stream/XMLEventReader.html" title="interface in javax.xml.stream">XMLEventReader</a> reader)
          throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>从指定的解析器解组XML数据并返回生成的内容树。</span>
<p> <span>这个方法是一个<a href="#unmarshalGlobal">Unmarshal Global Root method</a> 。</span> </p>
<p> <span>该方法假定解析器处于START_DOCUMENT或START_ELEMENT事件。</span> <span>解组将从此开始事件到相应的结束事件。</span> <span>如果此方法成功返回，则<tt>reader</tt>将在结束事件之后指向令牌。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>reader</code> - 要读取的解析器。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新创建的java内容树的根对象。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <tt>reader</tt>参数为空 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果 
            <tt>reader</tt>未指向START_DOCUMENT或START_ELEMENT事件。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/xml/bind/Unmarshaller.html#unmarshal-javax.xml.stream.XMLEventReader-java.lang.Class-"><code>unmarshal(javax.xml.stream.XMLEventReader, Class)</code></a>
</dd>
</dl> </li>
</ul> <a name="unmarshal-javax.xml.stream.XMLEventReader-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>unmarshal</h4> <pre>&lt;T&gt; <a href="../../../javax/xml/bind/JAXBElement.html" title="class in javax.xml.bind">JAXBElement</a>&lt;T&gt; unmarshal(<a href="../../../javax/xml/stream/XMLEventReader.html" title="interface in javax.xml.stream">XMLEventReader</a> reader,
                             <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt; declaredType)
                      throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>将根元素解组到JAXB映射<tt>declaredType</tt>并返回生成的内容树。</span>
<p> <span>该方法实现<a href="#unmarshalByDeclaredType">unmarshal by declaredType</a> 。</span> </p>
<p> <span>该方法假定解析器处于START_DOCUMENT或START_ELEMENT事件。</span> <span>解组将从此开始事件到相应的结束事件。</span> <span>如果此方法成功返回，则<tt>reader</tt>将在结束事件之后指向该令牌。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>reader</code> - 要读取的解析器。 
           </dd>
<dd>
<code>declaredType</code> - 适当的JAXB映射类保存 
            <tt>reader</tt>的START_ELEMENT XML数据。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             内容树根植于 
            <a href="#unmarshalDeclaredTypeReturn">JAXB Element representation</a>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 解组时是否发生意外错误 
           </dd>
<dd>
<span><code><a href="../../../javax/xml/bind/UnmarshalException.html" title="class in javax.xml.bind">UnmarshalException</a></code> - 如果<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind中的接口"><code>ValidationEventHandler</code></a>从其<tt>handleEvent</tt>方法返回false，或者<tt>Unmarshaller</tt>无法执行XML到Java绑定。</span>
<span>见<a href="#unmarshalEx">Unmarshalling XML Data</a></span>
</dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果任何参数为空 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="getUnmarshallerHandler--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getUnmarshallerHandler</h4> <pre><a href="../../../javax/xml/bind/UnmarshallerHandler.html" title="interface in javax.xml.bind">UnmarshallerHandler</a> getUnmarshallerHandler()</pre>
<div class="block">
<span>获取可以用作XML管道中组件的解组员处理程序对象。</span>
<p> <span>JAXB提供程序可以返回相同的处理程序对象，用于此方法的多次调用。</span> <span>换句话说，这种方法不一定会创建一个新的实例<tt>UnmarshallerHandler</tt> 。</span> <span>如果应用程序需要使用多个<tt>UnmarshallerHandler</tt> ，应该创建多个<tt>Unmarshaller</tt> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             unmarshaller处理程序对象 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../javax/xml/bind/UnmarshallerHandler.html" title="javax.xml.bind中的接口"><code>UnmarshallerHandler</code></a></span>
</dd>
</dl> </li>
</ul> <a name="setValidating-boolean-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setValidating</h4> <pre>void setValidating(boolean validating)
            throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">由于JAXB2.0，请参阅<a href="../../../javax/xml/bind/Unmarshaller.html#setSchema-javax.xml.validation.Schema-"><code>setSchema(javax.xml.validation.Schema)</code></a></span></span>
</div>
<div class="block">
<span>指定<tt>Unmarshaller</tt>的默认验证机制是否应在解组操作验证。</span>
<span>默认情况下， <tt>Unmarshaller</tt>不验证。</span>
<p> <span>该方法只能在调用其中一个解组方法之前或之后调用。</span> </p>
<p> <span>此方法仅控制JAXB提供程序的默认解组时间验证机制 - 它对指定自己的验证SAX 2.0兼容解析器的客户端没有影响。</span> <span>指定自己的解密时间验证机制的客户端可能希望通过此API关闭JAXB提供商的默认验证机制，以避免“双重验证”。</span> </p>
<p> <span>该方法自JAXB 2.0以来已被弃用 - 请使用新的<a href="../../../javax/xml/bind/Unmarshaller.html#setSchema-javax.xml.validation.Schema-"><code>setSchema(javax.xml.validation.Schema)</code></a> API。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>validating</code> - 如果Unmarshaller在解组织期间应验证，则为true，否则为false 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在解密时启用或禁用验证时发生错误 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果在引用JAXB 2.0映射类的JAXBContext创建的Unmarshaller上调用此方法，则可能会抛出 
           </dd>
</dl> </li>
</ul> <a name="isValidating--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>isValidating</h4> <pre>boolean isValidating()
              throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span><span class="deprecatedLabel">已弃用</span></span>
<span><span class="deprecationComment">因为JAXB2.0，请参阅<a href="../../../javax/xml/bind/Unmarshaller.html#getSchema--"><code>getSchema()</code></a></span></span>
</div>
<div class="block">
<span>指示<tt>Unmarshaller</tt>是否被配置为在解组操作来验证。</span>
<p> <span>该API返回JAXB提供程序的默认unmarshal-time验证机制的状态。</span> </p>
<p> <span>该方法自JAXB 2.0以来已被弃用 - 请使用新的<a href="../../../javax/xml/bind/Unmarshaller.html#getSchema--"><code>getSchema()</code></a> API。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             如果Unmarshaller配置为在解组操作期间进行验证，则为true，否则为false 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在检索验证标志时发生错误 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果在引用JAXB 2.0映射类的JAXBContext创建的Unmarshaller上调用此方法，则可能会抛出 
           </dd>
</dl> </li>
</ul> <a name="setEventHandler-javax.xml.bind.ValidationEventHandler-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setEventHandler</h4> <pre>void setEventHandler(<a href="../../../javax/xml/bind/ValidationEventHandler.html" title="interface in javax.xml.bind">ValidationEventHandler</a> handler)
              throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
<span>允许申请注册一个<tt>ValidationEventHandler</tt> 。</span>
<p> <span><tt>ValidationEventHandler</tt>将由JAXB提供者调用，如果在任何解组方法的调用期间遇到任何验证错误。</span> <span>如果客户端应用程序在调用解密方法之前没有注册<tt>ValidationEventHandler</tt> ，那么<tt>ValidationEvents</tt>将由默认事件处理程序处理，该处理程序将在遇到第一个错误或致命错误后终止解组操作。</span> </p>
<p> <span>使用null参数调用此方法将导致Unmarshaller恢复为默认事件处理程序。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>handler</code> - 验证事件处理程序 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在设置事件处理程序时遇到错误 
           </dd>
</dl> </li>
</ul> <a name="getEventHandler--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getEventHandler</h4> <pre><a href="../../../javax/xml/bind/ValidationEventHandler.html" title="interface in javax.xml.bind">ValidationEventHandler</a> getEventHandler()
                                throws <a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></pre>
<div class="block">
            返回当前事件处理程序或默认事件处理程序（如果尚未设置）。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             当前的ValidationEventHandler或默认事件处理程序（如果尚未设置） 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/JAXBException.html" title="class in javax.xml.bind">JAXBException</a></code> - 如果在获取当前事件处理程序时遇到错误 
           </dd>
</dl> </li>
</ul> <a name="setProperty-java.lang.String-java.lang.Object-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setProperty</h4> <pre>void setProperty(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> name,
                 <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> value)
          throws <a href="../../../javax/xml/bind/PropertyException.html" title="class in javax.xml.bind">PropertyException</a></pre>
<div class="block">
<span>在底层实现中设置特定的属性<tt>Unmarshaller</tt> 。</span>
<span>此方法只能用于设置上述标准JAXB定义属性之一或提供者特定属性。</span>
<span>尝试设置未定义的属性将导致抛出PropertyException。</span>
<span>见<a href="#supportedProps">Supported Properties</a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>name</code> - 要设置的属性的名称。</span>
<span>可以使用常量字段或用户提供的字符串指定此值。</span>
</dd>
<dd>
<code>value</code> - 要设置的属性的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/PropertyException.html" title="class in javax.xml.bind">PropertyException</a></code> - 处理给定属性或值时出错 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果name参数为null 
           </dd>
</dl> </li>
</ul> <a name="getProperty-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getProperty</h4> <pre><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a> getProperty(<a href="../../../java/lang/String.html" title="class in java.lang">String</a> name)
            throws <a href="../../../javax/xml/bind/PropertyException.html" title="class in javax.xml.bind">PropertyException</a></pre>
<div class="block">
<span>获取Unmarshaller底层实现中的<tt>特定属性</tt> 。</span>
<span>此方法只能用于获取上述标准JAXB定义的属性之一或提供者特定属性。</span>
<span>尝试获取未定义的属性将导致抛出PropertyException。</span>
<span>见<a href="#supportedProps">Supported Properties</a> 。</span>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>name</code> - 要检索的属性的名称 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             请求的属性的值 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../javax/xml/bind/PropertyException.html" title="class in javax.xml.bind">PropertyException</a></code> - 检索给定属性或值属性名称时出现错误 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果name参数为null 
           </dd>
</dl> </li>
</ul> <a name="setSchema-javax.xml.validation.Schema-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setSchema</h4> <pre>void setSchema(<a href="../../../javax/xml/validation/Schema.html" title="class in javax.xml.validation">Schema</a> schema)</pre>
<div class="block">
<span>指定应用于验证后续解组操作的JAXP 1.3 <a href="../../../javax/xml/validation/Schema.html" title="javax.xml.validation中的类"><code>Schema</code></a>对象。</span>
<span>将null传递给此方法将禁用验证。</span>
<p> <span>此方法将替代已弃用的<a href="../../../javax/xml/bind/Unmarshaller.html#setValidating-boolean-"><code>setValidating(boolean)</code></a> API。</span> </p>
<p> <span>最初此属性设置为<tt>null</tt> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>schema</code> - 用于验证解组操作的模式对象或null以禁用验证 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果在引用JAXB 1.0映射类的JAXBContext创建的Unmarshaller上调用此方法，则可能会抛出 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="getSchema--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSchema</h4> <pre><a href="../../../javax/xml/validation/Schema.html" title="class in javax.xml.validation">Schema</a> getSchema()</pre>
<div class="block">
<span>获取用于执行解密时间验证的JAXP 1.3 <a href="../../../javax/xml/validation/Schema.html" title="javax.xml.validation中的类"><code>Schema</code></a>对象。</span>
<span>如果在unmarshaller上没有设置Schema，则该方法将返回null，表示将不执行解密时间验证。</span>
<p> <span>此方法提供了已弃用的<code>isValidating()</code> API以及对Schema对象的访问的替换<a href="../../../javax/xml/bind/Unmarshaller.html#isValidating--">功能</a> 。</span> <span>要确定Unmarshaller是否启用了验证，只需将null的返回类型测试：</span> </p>
<p> <code>boolean isValidating = u.getSchema()!=null;</code> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             用于执行解密时间验证的Schema对象，如果不存在则使用null 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果在引用JAXB 1.0映射类的JAXBContext创建的Unmarshaller上调用此方法，则可能会抛出 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="setAdapter-javax.xml.bind.annotation.adapters.XmlAdapter-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setAdapter</h4> <pre>void setAdapter(<a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="class in javax.xml.bind.annotation.adapters">XmlAdapter</a> adapter)</pre>
<div class="block">
<span>相关联的配置实例<a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters中的类"><code>XmlAdapter</code></a>与此unmarshaller。</span>
<p> <span>这是调用<code>setAdapter(adapter.getClass(),adapter);</code>的方便方法。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果适配器参数为空。 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code>调用JAXB 1.0实现。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<a href="../../../javax/xml/bind/Unmarshaller.html#setAdapter-java.lang.Class-A-"><code>setAdapter(Class,XmlAdapter)</code></a>
</dd>
</dl> </li>
</ul> <a name="setAdapter-java.lang.Class-javax.xml.bind.annotation.adapters.XmlAdapter-">
<!-- --> </a><a name="setAdapter-java.lang.Class-A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setAdapter</h4> <pre>&lt;A extends <a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="class in javax.xml.bind.annotation.adapters">XmlAdapter</a>&gt; void setAdapter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; type,
                                       A adapter)</pre>
<div class="block">
<span>相关联的配置实例<a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters中的类"><code>XmlAdapter</code></a>与此unmarshaller。</span>
<p> <span>每个unmarshaller内部维护一个<a href="../../../java/util/Map.html" title="java.util中的接口"><code>Map</code></a> &lt; <a href="../../../java/lang/Class.html" title="java.lang中的类"><code>类</code></a> ， <a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters中的类"><code>XmlAdapter</code></a> &gt;，它使用用于解组类，它们的字段/方法的注解为<a href="../../../javax/xml/bind/annotation/adapters/XmlJavaTypeAdapter.html" title="javax.xml.bind.annotation.adapters中的注释"><code>XmlJavaTypeAdapter</code></a> 。</span> </p>
<p> <span>此方法允许应用程序使用的一个配置实例<a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters中的类"><code>XmlAdapter</code></a> 。</span> <span>当未给出适配器的实例时，解组器将通过调用其默认构造函数来创建一个。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>type</code> - 适配器的类型。</span>
<span>指定的实例将在<a href="../../../javax/xml/bind/annotation/adapters/XmlJavaTypeAdapter.html#value--"><code>XmlJavaTypeAdapter.value()</code></a>引用此类型时使用。</span>
</dd>
<dd>
<span><code>adapter</code> - 要使用的适配器的实例。</span>
<span>如果为空，它将取消注册此类型的当前适配器集。</span>
</dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果type参数为null。 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code>调用JAXB 1.0实现。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="getAdapter-java.lang.Class-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAdapter</h4> <pre>&lt;A extends <a href="../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="class in javax.xml.bind.annotation.adapters">XmlAdapter</a>&gt; A getAdapter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;A&gt; type)</pre>
<div class="block">
<span>获取与指定类型相关联的适配器。</span>
<span>这是<a href="../../../javax/xml/bind/Unmarshaller.html#setAdapter-javax.xml.bind.annotation.adapters.XmlAdapter-"><code>setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter)</code></a>方法的反向操作。</span>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果type参数为null。 
           </dd>
<dd>
<code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code>调用JAXB 1.0实现。 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="setAttachmentUnmarshaller-javax.xml.bind.attachment.AttachmentUnmarshaller-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setAttachmentUnmarshaller</h4> <pre>void setAttachmentUnmarshaller(<a href="../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="class in javax.xml.bind.attachment">AttachmentUnmarshaller</a> au)</pre>
<div class="block">
<p> <span>将解析cid，content-id URI的上下文关联到作为附件传递的二进制数据。</span> </p>
<p></p>
<p> <span>即使在解组器执行XOP处理时，也必须支持通过<a href="../../../javax/xml/bind/Unmarshaller.html#setSchema-javax.xml.validation.Schema-"><code>setSchema(Schema)</code></a>启用解密时间验证。</span> </p>
</div>
<dl>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果在unmarshal操作期间尝试同时调用此方法。 
           </dd>
</dl> </li>
</ul> <a name="getAttachmentUnmarshaller--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getAttachmentUnmarshaller</h4> <pre><a href="../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="class in javax.xml.bind.attachment">AttachmentUnmarshaller</a> getAttachmentUnmarshaller()</pre> </li>
</ul> <a name="setListener-javax.xml.bind.Unmarshaller.Listener-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>setListener</h4> <pre>void setListener(<a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="class in javax.xml.bind">Unmarshaller.Listener</a> listener)</pre>
<div class="block">
<p> <span>注册解组事件回调<a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind中的类"><code>Unmarshaller.Listener</code></a>这个<a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a> 。</span> </p>
<p> <span>每个Unmarshaller只有一个监听器。</span> <span>设置侦听器将替换以前设置的侦听器。</span> <span>可以通过将侦听器设置为<tt>null</tt>来取消注册当前侦听器。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>listener</code> - 提供这个<a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code>的</a>解组事件<a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口">回调</a></span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> <a name="getListener--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>getListener</h4> <pre><a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="class in javax.xml.bind">Unmarshaller.Listener</a> getListener()</pre>
<div class="block">
<p> <span>返回<a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind中的类"><code>Unmarshaller.Listener</code></a>注册此<a href="../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind中的接口"><code>Unmarshaller</code></a> 。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<span>注册了<a href="../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind中的类"><code>Unmarshaller.Listener</code></a>或<code>null</code>如果没有监听器已经注册到这个Unmarshaller。</span>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             JAXB2.0 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>