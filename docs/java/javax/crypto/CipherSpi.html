<div class="header">
<div class="subTitle">
     javax.crypto 
   </div>
<h2 class="title" title="Class CipherSpi">Class CipherSpi</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>javax.crypto.CipherSpi</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr/> <br/> <pre>public abstract class <span class="typeNameLabel">CipherSpi</span>
extends <a href="../../java/lang/Object.html" title="class in java.lang">Object</a></pre>
<div class="block">
<span>这个类定义的 <span>（SPI）</span> <code>Cipher</code>类。</span>
<span>该类中的所有抽象方法必须由希望提供特定密码算法的实现的每个加密服务提供商来实现。</span>
<p> <span>为了创建的实例<code>Cipher</code> ，它封装了这个实例<code>CipherSpi</code>类，应用程序调用的一个<a href="../../javax/crypto/Cipher.html#getInstance-java.lang.String-"><code>getInstance</code>种</a>的工厂方法<a href="../../javax/crypto/Cipher.html" title="javax.crypto中的类"><code>Cipher</code></a>引擎类，并指定请求的<i>转换</i> 。</span> <span>可选地，应用程序还可以指定提供者的名称。</span> </p>
<p> <span><i>转换</i>是描述要在给定输入上执行的操作（或操作集）的字符串，以产生一些输出。</span> <span>转换总是包括<i>加密算法</i>的名称（例如， <i>DES</i> ），并且可以跟随有反馈模式和填充方案。</span> </p>
<p> <span>转换形式如下：</span> </p>
<ul>
<li> <span>“ <i>算法/模式/填充</i> ”或</span> </li>
<li> <span>“ <i>算法</i> ”</span> </li>
</ul>
<p> <span>（在后一种情况下，使用模式和填充方案的提供者特定的默认值）。</span> <span>例如，以下是有效的转换：</span> </p>
<pre>  <span>Cipher c = Cipher.getInstance("<i>DES/CBC/PKCS5Padding</i>");</span> </pre>
<p> <span>提供者可以为<i>算法/模式/填充的</i>每个组合提供单独的类，或者可以决定提供表示对应于<i>算法</i>或<i>算法/模式</i>或<i>算法//填充</i> （注意双斜杠）的子变换的更多通用类，其中情况下所请求模式和/或填充由自动设定<code>getInstance</code>的方法<code>Cipher</code> ，其调用<a href="../../javax/crypto/CipherSpi.html#engineSetMode-java.lang.String-"><code>engineSetMode</code></a>种<a href="../../javax/crypto/CipherSpi.html#engineSetPadding-java.lang.String-"><code>engineSetPadding</code></a>的提供者的子类的方法<code>CipherSpi</code> 。</span> </p>
<p> <span>提供者主类中的<code>Cipher</code>属性可能具有以下格式之一：</span> </p>
<ul>
<li><pre>  <span>// provider's subclass of "CipherSpi" implements "algName" with
     // pluggable mode and padding
     <code>Cipher.</code><i>algName</i></span> </pre></li>
<li><pre>  <span>// provider's subclass of "CipherSpi" implements "algName" in the
     // specified "mode", with pluggable padding
     <code>Cipher.</code><i>algName/mode</i></span> </pre></li>
<li><pre>  <span>// provider's subclass of "CipherSpi" implements "algName" with the
     // specified "padding", with pluggable mode
     <code>Cipher.</code><i>algName//padding</i></span> </pre></li>
<li><pre>  <span>// provider's subclass of "CipherSpi" implements "algName" with the
     // specified "mode" and "padding"
     <code>Cipher.</code><i>algName/mode/padding</i></span> </pre></li>
</ul>
<p> <span>例如，提供者可以提供的一个子类<code>CipherSpi</code>实现<i>DES / ECB / PKCS5Padding，</i>一个实现<i>DES / CBC / PKCS5Padding，</i>一个实现<i>DES / CFB / PKCS5Padding，</i>和又一一个实现<i>DES / OFB / PKCS5Padding。</i></span> <span>该提供商将有以下<code>Cipher</code>在其主类的属性：</span> </p>
<ul>
<li><pre>  <span><code>Cipher.</code><i>DES/ECB/PKCS5Padding</i></span> </pre></li>
<li><pre>  <span><code>Cipher.</code><i>DES/CBC/PKCS5Padding</i></span> </pre></li>
<li><pre>  <span><code>Cipher.</code><i>DES/CFB/PKCS5Padding</i></span> </pre></li>
<li><pre>  <span><code>Cipher.</code><i>DES/OFB/PKCS5Padding</i></span> </pre></li>
</ul>
<p> <span>另一个提供者可以针对上述各种模式（即<i>ECB的</i>一个类别，一个用于<i>CBC</i> ，一个用于<i>CFB</i> ，另一个用于<i>OFB</i> ）， <i>PKCS5Padding的</i>一个类以及从<code>CipherSpi</code>分类的通用<i>DES</i>类来<code>CipherSpi</code> 。</span> <span>该提供商将有以下<code>Cipher</code>在其主类的属性：</span> </p>
<ul>
<li><pre>  <span><code>Cipher.</code><i>DES</i></span> </pre></li>
</ul>
<p> <span><code>Cipher</code>引擎类的<code>getInstance</code>工厂方法遵循这些规则，以便实例化一个提供者对“ <i>算法</i> ”形式的转换的<code>CipherSpi</code>实现：</span> </p>
<ol>
<li> <span>检查提供商注册的子类<code>CipherSpi</code>为指定的“ <i>算法</i> ”。</span> <p> <span>如果答案为YES，则实例化该类，对于其模式和填充方案默认值（由提供者提供）使用。</span> </p><p> <span>如果答案为否，则抛出<code>NoSuchAlgorithmException</code>异常。</span> </p></li>
</ol>
<p> <span><code>Cipher</code>引擎类的<code>getInstance</code>工厂方法遵循这些规则，以便实例化一个提供者对“ <i>算法/模式/填充</i> ”形式的转换的<code>CipherSpi</code>实现：</span> </p>
<ol>
<li> <span>检查提供商注册的子类<code>CipherSpi</code>为指定的“ <i>算法/模式/填充</i> ”转型。</span> <p> <span>如果答案为YES，则将其实例化。</span> </p><p> <span>如果答案为否，请转到下一步。</span> </p></li>
<li> <span>检查提供商注册的子类<code>CipherSpi</code>为副变换“ <i>算法/模式</i> ”。</span> <p> <span>如果答案为YES，则将其实例化，并在新实例上调用<code>engineSetPadding(<i>padding</i>)</code> 。</span> </p><p> <span>如果答案为否，请转到下一步。</span> </p></li>
<li> <span>检查提供商注册的子类<code>CipherSpi</code>为副变换“ <i>算法//填充</i> ”（注意双斜杠）。</span> <p> <span>如果答案为YES，则将其实例化，并在新实例上调用<code>engineSetMode(<i>mode</i>)</code> 。</span> </p><p> <span>如果答案为否，请转到下一步。</span> </p></li>
<li> <span>检查提供商注册的子类<code>CipherSpi</code>为副变换“ <i>算法</i> ”。</span> <p> <span>如果答案为YES，则将其实例化，并在新实例上调用<code>engineSetMode(<i>mode</i>)</code>和<code>engineSetPadding(<i>padding</i>)</code> 。</span> </p><p> <span>如果答案为否，则抛出<code>NoSuchAlgorithmException</code>异常。</span> </p></li>
</ol>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.4 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../javax/crypto/KeyGenerator.html" title="javax.crypto中的类"><code>KeyGenerator</code></a> ， <a href="../../javax/crypto/SecretKey.html" title="javax.crypto中的接口"><code>SecretKey</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#CipherSpi--">CipherSpi</a></span>()</code> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>protected abstract byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineDoFinal-byte:A-int-int-">engineDoFinal</a></span>(byte[] input, int inputOffset, int inputLen)</code>
<div class="block">
              在单一部分操作中加密或解密数据，或完成多部分操作。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>protected abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineDoFinal-byte:A-int-int-byte:A-int-">engineDoFinal</a></span>(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)</code>
<div class="block">
              在单一部分操作中加密或解密数据，或完成多部分操作。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineDoFinal-java.nio.ByteBuffer-java.nio.ByteBuffer-">engineDoFinal</a></span>(<a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> input, <a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> output)</code>
<div class="block">
              在单一部分操作中加密或解密数据，或完成多部分操作。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>protected abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineGetBlockSize--">engineGetBlockSize</a></span>()</code>
<div class="block">
              返回块大小（以字节为单位）。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>protected abstract byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineGetIV--">engineGetIV</a></span>()</code>
<div class="block">
              返回新缓冲区中的初始化向量（IV）。 
            </div> </td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineGetKeySize-java.security.Key-">engineGetKeySize</a></span>(<a href="../../java/security/Key.html" title="interface in java.security">Key</a> key)</code>
<div class="block">
              以位为单位返回给定键对象的键大小。 
            </div> </td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>protected abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineGetOutputSize-int-">engineGetOutputSize</a></span>(int inputLen)</code>
<div class="block">
              给定输入长度 
             <code>inputLen</code> （以字节为单位），返回输出缓冲区需要保存下一个 
             <code>update</code>或 
             <code>doFinal</code>操作结果的字节长度。 
            </div> </td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>protected abstract <a href="../../java/security/AlgorithmParameters.html" title="class in java.security">AlgorithmParameters</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineGetParameters--">engineGetParameters</a></span>()</code>
<div class="block">
              返回与此密码一起使用的参数。 
            </div> </td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineInit-int-java.security.Key-java.security.spec.AlgorithmParameterSpec-java.security.SecureRandom-">engineInit</a></span>(int opmode, <a href="../../java/security/Key.html" title="interface in java.security">Key</a> key, <a href="../../java/security/spec/AlgorithmParameterSpec.html" title="interface in java.security.spec">AlgorithmParameterSpec</a> params, <a href="../../java/security/SecureRandom.html" title="class in java.security">SecureRandom</a> random)</code>
<div class="block">
              使用密钥，一组算法参数和随机源初始化此密码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineInit-int-java.security.Key-java.security.AlgorithmParameters-java.security.SecureRandom-">engineInit</a></span>(int opmode, <a href="../../java/security/Key.html" title="interface in java.security">Key</a> key, <a href="../../java/security/AlgorithmParameters.html" title="class in java.security">AlgorithmParameters</a> params, <a href="../../java/security/SecureRandom.html" title="class in java.security">SecureRandom</a> random)</code>
<div class="block">
              使用密钥，一组算法参数和随机源初始化此密码。 
            </div> </td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineInit-int-java.security.Key-java.security.SecureRandom-">engineInit</a></span>(int opmode, <a href="../../java/security/Key.html" title="interface in java.security">Key</a> key, <a href="../../java/security/SecureRandom.html" title="class in java.security">SecureRandom</a> random)</code>
<div class="block">
              用密钥和随机源初始化此密码。 
            </div> </td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineSetMode-java.lang.String-">engineSetMode</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> mode)</code>
<div class="block">
              设置此密码的模式。 
            </div> </td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineSetPadding-java.lang.String-">engineSetPadding</a></span>(<a href="../../java/lang/String.html" title="class in java.lang">String</a> padding)</code>
<div class="block">
              设置这个密码的填充机制。 
            </div> </td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>protected <a href="../../java/security/Key.html" title="interface in java.security">Key</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineUnwrap-byte:A-java.lang.String-int-">engineUnwrap</a></span>(byte[] wrappedKey, <a href="../../java/lang/String.html" title="class in java.lang">String</a> wrappedKeyAlgorithm, int wrappedKeyType)</code>
<div class="block">
              打开以前包装的钥匙。 
            </div> </td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>protected abstract byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineUpdate-byte:A-int-int-">engineUpdate</a></span>(byte[] input, int inputOffset, int inputLen)</code>
<div class="block">
              继续进行多部分加密或解密操作（取决于如何初始化该密码），处理另一个数据部分。 
            </div> </td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>protected abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineUpdate-byte:A-int-int-byte:A-int-">engineUpdate</a></span>(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)</code>
<div class="block">
              继续进行多部分加密或解密操作（取决于如何初始化该密码），处理另一个数据部分。 
            </div> </td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineUpdate-java.nio.ByteBuffer-java.nio.ByteBuffer-">engineUpdate</a></span>(<a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> input, <a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> output)</code>
<div class="block">
              继续进行多部分加密或解密操作（取决于如何初始化该密码），处理另一个数据部分。 
            </div> </td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineUpdateAAD-byte:A-int-int-">engineUpdateAAD</a></span>(byte[] src, int offset, int len)</code>
<div class="block">
              使用所提供的缓冲区的子集，继续进行附加认证数据（AAD）的多部分更新。 
            </div> </td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineUpdateAAD-java.nio.ByteBuffer-">engineUpdateAAD</a></span>(<a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> src)</code>
<div class="block">
              继续进行附加认证数据（AAD）的多部分更新。 
            </div> </td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>protected byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/crypto/CipherSpi.html#engineWrap-java.security.Key-">engineWrap</a></span>(<a href="../../java/security/Key.html" title="interface in java.security">Key</a> key)</code>
<div class="block">
              包裹钥匙 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../java/lang/Object.html#clone--">clone</a>, <a href="../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../java/lang/Object.html#notify--">notify</a>, <a href="../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../java/lang/Object.html#toString--">toString</a>, <a href="../../java/lang/Object.html#wait--">wait</a>, <a href="../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="CipherSpi--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>CipherSpi</h4> <pre>public CipherSpi()</pre> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="engineSetMode-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineSetMode</h4> <pre>protected abstract void engineSetMode(<a href="../../java/lang/String.html" title="class in java.lang">String</a> mode)
                               throws <a href="../../java/security/NoSuchAlgorithmException.html" title="class in java.security">NoSuchAlgorithmException</a></pre>
<div class="block">
            设置此密码的模式。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>mode</code> - 密码模式 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/security/NoSuchAlgorithmException.html" title="class in java.security">NoSuchAlgorithmException</a></code> - 如果请求的密码模式不存在 
           </dd>
</dl> </li>
</ul> <a name="engineSetPadding-java.lang.String-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineSetPadding</h4> <pre>protected abstract void engineSetPadding(<a href="../../java/lang/String.html" title="class in java.lang">String</a> padding)
                                  throws <a href="../../javax/crypto/NoSuchPaddingException.html" title="class in javax.crypto">NoSuchPaddingException</a></pre>
<div class="block">
            设置这个密码的填充机制。 
          </div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>padding</code> - 填充机制 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../javax/crypto/NoSuchPaddingException.html" title="class in javax.crypto">NoSuchPaddingException</a></code> - 如果请求的填充机制不存在 
           </dd>
</dl> </li>
</ul> <a name="engineGetBlockSize--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineGetBlockSize</h4> <pre>protected abstract int engineGetBlockSize()</pre>
<div class="block">
            返回块大小（以字节为单位）。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             块大小（以字节为单位），如果底层算法不是块密码，则为0 
           </dd>
</dl> </li>
</ul> <a name="engineGetOutputSize-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineGetOutputSize</h4> <pre>protected abstract int engineGetOutputSize(int inputLen)</pre>
<div class="block">
<span>给定输入长度<code>inputLen</code> （以字节为单位），返回输出缓冲区需要保存下一个<code>update</code>或<code>doFinal</code>操作的结果的字节长度。</span>
<p> <span>此呼叫考虑到来自前一个<code>update</code>呼叫，填充和<code>update</code>标记的任何未处理（缓冲）数据。</span> </p>
<p> <span>下一个<code>update</code>或<code>doFinal</code>调用的实际输出长度可能小于此方法返回的长度。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>inputLen</code> - 输入长度（字节） 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             所需的输出缓冲区大小（以字节为单位） 
           </dd>
</dl> </li>
</ul> <a name="engineGetIV--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineGetIV</h4> <pre>protected abstract byte[] engineGetIV()</pre>
<div class="block">
<span>返回新缓冲区中的初始化向量（IV）。</span>
<p> <span>这在基于密码的加密或解密的上下文中是有用的，其中IV是从用户提供的密码短语导出的。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新缓冲区中的初始化向量，如果底层算法不使用IV，或者如果IV尚未设置，则为null。 
           </dd>
</dl> </li>
</ul> <a name="engineGetParameters--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineGetParameters</h4> <pre>protected abstract <a href="../../java/security/AlgorithmParameters.html" title="class in java.security">AlgorithmParameters</a> engineGetParameters()</pre>
<div class="block">
<span>返回与此密码一起使用的参数。</span>
<p> <span>返回的参数可能与用于初始化此密码的参数相同，或者如果该密码需要算法参数但未被任何初始化，则可能包含底层密码实现使用的默认值和随机参数值的组合。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             与此密码一起使用的参数，如果此密码不使用任何参数，则为null。 
           </dd>
</dl> </li>
</ul> <a name="engineInit-int-java.security.Key-java.security.SecureRandom-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineInit</h4> <pre>protected abstract void engineInit(int opmode,
                                   <a href="../../java/security/Key.html" title="interface in java.security">Key</a> key,
                                   <a href="../../java/security/SecureRandom.html" title="class in java.security">SecureRandom</a> random)
                            throws <a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></pre>
<div class="block">
<span>用密钥和随机源初始化此密码。</span>
<p> <span>根据opmode的值，将密码初始化为以下四个操作之一：加密，解密，密钥包装或密钥解<code>opmode</code> 。</span> </p>
<p> <span>如果此密码需要不能从给定的<code>key</code>导出的任何<code>key</code> ，则底层加密实现应该自动生成所需参数（使用提供者特定的默认值或随机值），如果它被初始化为加密或密钥包装，以及提高一个<code>InvalidKeyException</code>如果它被初始化解密或密钥解包。</span> <span>生成的参数可以使用<a href="../../javax/crypto/CipherSpi.html#engineGetParameters--"><code>engineGetParameters</code></a>或<a href="../../javax/crypto/CipherSpi.html#engineGetIV--"><code>engineGetIV</code></a> （如果参数是IV）检索。</span> </p>
<p> <span>如果该密码需要不能从输入参数导出的算法参数，并且没有合理的提供者特定的默认值，则初始化必然会失败。</span> </p>
<p> <span>如果这个密码（包括其底层反馈或填充方案）需要任何随机字节（例如，用于参数生成），它将从<code>random</code>得到它们。</span> </p>
<p> <span>请注意，当一个Cipher对象被初始化时，它将失去所有先前获取的状态。</span> <span>换句话说，初始化一个Cipher相当于创建一个新的Cipher实例并对其进行初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>opmode</code> -此cipher的操作模式（这是下列之一： 
            <code>ENCRYPT_MODE</code> ， 
            <code>DECRYPT_MODE</code> ， 
            <code>WRAP_MODE</code>或 
            <code>UNWRAP_MODE</code> ） 
           </dd>
<dd>
<code>key</code> - 加密密钥 
           </dd>
<dd>
<code>random</code> - 
            <code>random</code>的来源 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></code> - 如果给定的密钥不适合初始化该密码，或者需要不能从给定密钥确定的算法参数。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <code>opmode</code>是 
            <code>WRAP_MODE</code>或 
            <code>UNWRAP_MODE</code>未被密码实现。 
           </dd>
</dl> </li>
</ul> <a name="engineInit-int-java.security.Key-java.security.spec.AlgorithmParameterSpec-java.security.SecureRandom-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineInit</h4> <pre>protected abstract void engineInit(int opmode,
                                   <a href="../../java/security/Key.html" title="interface in java.security">Key</a> key,
                                   <a href="../../java/security/spec/AlgorithmParameterSpec.html" title="interface in java.security.spec">AlgorithmParameterSpec</a> params,
                                   <a href="../../java/security/SecureRandom.html" title="class in java.security">SecureRandom</a> random)
                            throws <a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a>,
                                   <a href="../../java/security/InvalidAlgorithmParameterException.html" title="class in java.security">InvalidAlgorithmParameterException</a></pre>
<div class="block">
<span>使用密钥，一组算法参数和随机源初始化此密码。</span>
<p> <span>根据opmode的值，密码被初始化为以下四个操作之一：加密，解密，密钥包装或密钥解<code>opmode</code> 。</span> </p>
<p> <span>如果此密码需要任何算法参数，并且<code>params</code>为null，则底层加密实现应该自动生成必需的参数（使用特定于提供者的默认值或随机值），如果它被初始化为加密或密钥包装，并提出一个<code>InvalidAlgorithmParameterException</code> if正在为解密或密钥解包进行初始化。</span> <span>可以使用<a href="../../javax/crypto/CipherSpi.html#engineGetParameters--"><code>engineGetParameters</code></a>或<a href="../../javax/crypto/CipherSpi.html#engineGetIV--"><code>engineGetIV</code></a> （如果参数为IV）检索生成的参数。</span> </p>
<p> <span>如果该密码需要不能从输入参数导出的算法参数，并且没有合理的提供者特定的默认值，则初始化必然会失败。</span> </p>
<p> <span>如果这个密码（包括其底层反馈或填充方案）需要任何随机字节（例如，用于参数生成），它将从<code>random</code> 。</span> </p>
<p> <span>请注意，当一个Cipher对象被初始化时，它将失去所有先前获取的状态。</span> <span>换句话说，初始化一个Cipher相当于创建一个新的Cipher实例并对其进行初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>opmode</code> -此cipher的操作模式（这是下列之一： 
            <code>ENCRYPT_MODE</code> ， 
            <code>DECRYPT_MODE</code> ， 
            <code>WRAP_MODE</code>或 
            <code>UNWRAP_MODE</code> ） 
           </dd>
<dd>
<code>key</code> - 加密密钥 
           </dd>
<dd>
<code>params</code> - 算法参数 
           </dd>
<dd>
<code>random</code> - 
            <code>random</code>的来源 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></code> - 如果给定的密钥不适合初始化此密码 
           </dd>
<dd>
<code><a href="../../java/security/InvalidAlgorithmParameterException.html" title="class in java.security">InvalidAlgorithmParameterException</a></code> - 如果给定的算法参数不适合该密码，或者该密码需要算法参数，并且 
            <code>params</code>为空。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <code>opmode</code>是 
            <code>WRAP_MODE</code>或 
            <code>UNWRAP_MODE</code>未被密码实现。 
           </dd>
</dl> </li>
</ul> <a name="engineInit-int-java.security.Key-java.security.AlgorithmParameters-java.security.SecureRandom-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineInit</h4> <pre>protected abstract void engineInit(int opmode,
                                   <a href="../../java/security/Key.html" title="interface in java.security">Key</a> key,
                                   <a href="../../java/security/AlgorithmParameters.html" title="class in java.security">AlgorithmParameters</a> params,
                                   <a href="../../java/security/SecureRandom.html" title="class in java.security">SecureRandom</a> random)
                            throws <a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a>,
                                   <a href="../../java/security/InvalidAlgorithmParameterException.html" title="class in java.security">InvalidAlgorithmParameterException</a></pre>
<div class="block">
<span>使用密钥，一组算法参数和随机源初始化此密码。</span>
<p> <span>根据opmode的值，将密码初始化为以下四个操作之一：加密，解密，密钥包装或密钥解<code>opmode</code> 。</span> </p>
<p> <span>如果此密码需要任何算法参数，并且<code>params</code>为null，则底层加密实现应该自动生成所需参数（使用特定于提供者的默认值或随机值），如果正在初始化加密或密钥包装，并提出一个<code>InvalidAlgorithmParameterException</code> if正在为解密或密钥解包进行初始化。</span> <span>可以使用<a href="../../javax/crypto/CipherSpi.html#engineGetParameters--"><code>engineGetParameters</code></a>或<a href="../../javax/crypto/CipherSpi.html#engineGetIV--"><code>engineGetIV</code></a> （如果参数为IV）检索生成的参数。</span> </p>
<p> <span>如果该密码需要不能从输入参数导出的算法参数，并且没有合理的提供者特定的默认值，则初始化必然会失败。</span> </p>
<p> <span>如果这个密码（包括其底层反馈或填充方案）需要任何随机字节（例如，用于参数生成），它将从<code>random</code> 。</span> </p>
<p> <span>请注意，当一个Cipher对象被初始化时，它将失去所有先前获取的状态。</span> <span>换句话说，初始化一个Cipher相当于创建一个新的Cipher实例并对其进行初始化。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>opmode</code> -此cipher的操作模式（这是下列之一： 
            <code>ENCRYPT_MODE</code> ， 
            <code>DECRYPT_MODE</code> ， 
            <code>WRAP_MODE</code>或 
            <code>UNWRAP_MODE</code> ） 
           </dd>
<dd>
<code>key</code> - 加密密钥 
           </dd>
<dd>
<code>params</code> - 算法参数 
           </dd>
<dd>
<code>random</code> - 
            <code>random</code>的来源 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></code> - 如果给定的密钥不适合初始化此密码 
           </dd>
<dd>
<code><a href="../../java/security/InvalidAlgorithmParameterException.html" title="class in java.security">InvalidAlgorithmParameterException</a></code> - 如果给定的算法参数不适合该密码，或者该密码需要算法参数，并且 
            <code>params</code>为空。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
            <code>opmode</code>是 
            <code>WRAP_MODE</code>或 
            <code>UNWRAP_MODE</code>未被密码实现。 
           </dd>
</dl> </li>
</ul> <a name="engineUpdate-byte:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineUpdate</h4> <pre>protected abstract byte[] engineUpdate(byte[] input,
                                       int inputOffset,
                                       int inputLen)</pre>
<div class="block">
<span>继续进行多部分加密或解密操作（取决于如何初始化该密码），处理另一个数据部分。</span>
<p> <span>第一<code>inputLen</code>字节在<code>input</code>缓冲区中，从<code>inputOffset</code>以下，被处理，并且结果被存储在新的缓冲器。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>input</code> - 输入缓冲区 
           </dd>
<dd>
<code>inputOffset</code> - 
            <code>input</code>中输入开始的偏移量 
           </dd>
<dd>
<code>inputLen</code> - 输入长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             具有结果的新缓冲区，如果底层密码是块密码，并且输入数据太短，导致新的块，则为null。 
           </dd>
</dl> </li>
</ul> <a name="engineUpdate-byte:A-int-int-byte:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineUpdate</h4> <pre>protected abstract int engineUpdate(byte[] input,
                                    int inputOffset,
                                    int inputLen,
                                    byte[] output,
                                    int outputOffset)
                             throws <a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a></pre>
<div class="block">
<span>继续进行多部分加密或解密操作（取决于如何初始化该密码），处理另一个数据部分。</span>
<p> <span><code>input</code>缓冲区中的第<code>inputLen</code>个字节（起始于<code>inputOffset</code> ）被处理，结果存储在<code>output</code>缓冲区中，从<code>outputOffset</code>开始。</span> </p>
<p> <span>如果<code>output</code>缓冲区太小而不能保存结果，则抛出<code>ShortBufferException</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>input</code> - 输入缓冲区 
           </dd>
<dd>
<code>inputOffset</code> - 
            <code>input</code>中的输入开始的偏移量 
           </dd>
<dd>
<code>inputLen</code> - 输入长度 
           </dd>
<dd>
<code>output</code> - 结果的缓冲区 
           </dd>
<dd>
<code>outputOffset</code> - 
            <code>output</code>中存储结果的偏移量 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             存储在 
            <code>output</code>中的字节数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a></code> - 如果给定的输出缓冲区太小，不能保存结果 
           </dd>
</dl> </li>
</ul> <a name="engineUpdate-java.nio.ByteBuffer-java.nio.ByteBuffer-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineUpdate</h4> <pre>protected int engineUpdate(<a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> input,
                           <a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> output)
                    throws <a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a></pre>
<div class="block">
<span>继续进行多部分加密或解密操作（取决于如何初始化该密码），处理另一个数据部分。</span>
<p> <span>所有<code>input.remaining()</code>起始字节<code>input.position()</code>进行处理。</span> <span>结果存储在输出缓冲区中。</span> <span>返回时，输入缓冲区的位置将等于其限制;</span> <span>其限制将不会改变。</span> <span>输出缓冲区的位置将提前n，其中n是此方法返回的值;</span> <span>输出缓冲区的限制将不会改变。</span> </p>
<p> <span>如果<code>output.remaining()</code>字节不足以保存结果，则抛出<code>ShortBufferException</code> 。</span> </p>
<p> <span>子类应该考虑覆盖此方法，如果它们可以比字节数组更有效地处理ByteBuffers。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>input</code> - 输入ByteBuffer 
           </dd>
<dd>
<code>output</code> - 输出ByteByffer 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
<code>output</code>中存储的字节数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a></code> - 如果输出缓冲区中没有足够的空间 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数是 
            <code>null</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="engineDoFinal-byte:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineDoFinal</h4> <pre>protected abstract byte[] engineDoFinal(byte[] input,
                                        int inputOffset,
                                        int inputLen)
                                 throws <a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a>,
                                        <a href="../../javax/crypto/BadPaddingException.html" title="class in javax.crypto">BadPaddingException</a></pre>
<div class="block">
<span>在单一部分操作中加密或解密数据，或完成多部分操作。</span>
<span>数据被加密或解密，这取决于这个密码如何初始化。</span>
<p> <span>第一<code>inputLen</code>字节在<code>input</code>缓冲区中，从<code>inputOffset</code>以下，并且可能在上一次期间已缓存的任何输入字节<code>update</code>操作，进行处理，填充（如果要求）被施加。</span> <span>如果正在使用诸如GCM / CCM的AEAD模式，则在加密的情况下附加认证标签，或者在解密的情况下验证认证标签。</span> <span>结果存储在一个新的缓冲区。</span> </p>
<p> <span>完成后，此方法将此密码对象重置为先前通过调用<code>engineInit</code> 。</span> <span>也就是说，该对象被复位并且可用于加密或解密（取决于这是在调用所指定的操作模式<code>engineInit</code> ）更多的数据。</span> </p>
<p> <span>注意：如果发生任何异常，则可能需要重新设置此密码对象，然后才能再次使用。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>input</code> - 输入缓冲区 
           </dd>
<dd>
<code>inputOffset</code> - 
            <code>input</code>中的输入开始的偏移量 
           </dd>
<dd>
<code>inputLen</code> - 输入长度 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             新的缓冲区结果 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a></code> - 如果该密码是块密码，则不会请求填充（仅在加密模式下），并且由该密码处理的数据的总输入长度不是块大小的倍数;</span>
<span>或者如果此加密算法无法处理提供的输入数据。</span>
</dd>
<dd>
<code><a href="../../javax/crypto/BadPaddingException.html" title="class in javax.crypto">BadPaddingException</a></code> - 如果该密码处于解密模式，并且已经请求了（un）填充，但是解密的数据不受适当的填充字节的限制 
           </dd>
<dd>
<code><a href="../../javax/crypto/AEADBadTagException.html" title="class in javax.crypto">AEADBadTagException</a></code> - 如果该密码在AEAD模式（例如GCM / CCM）中进行解密，并且接收到的认证标签与计算值不匹配 
           </dd>
</dl> </li>
</ul> <a name="engineDoFinal-byte:A-int-int-byte:A-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineDoFinal</h4> <pre>protected abstract int engineDoFinal(byte[] input,
                                     int inputOffset,
                                     int inputLen,
                                     byte[] output,
                                     int outputOffset)
                              throws <a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a>,
                                     <a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a>,
                                     <a href="../../javax/crypto/BadPaddingException.html" title="class in javax.crypto">BadPaddingException</a></pre>
<div class="block">
<span>在单一部分操作中加密或解密数据，或完成多部分操作。</span>
<span>数据被加密或解密，这取决于这个密码如何初始化。</span>
<p> <span><code>input</code>缓冲区中第<code>inputLen</code>个字节（包括起始值为<code>inputOffset</code> ）以及前一个<code>update</code>操作中可能已经被缓存的任何输入字节都被处理，并应用填充（如果请求）。</span> <span>如果正在使用诸如GCM / CCM的AEAD模式，则在加密的情况下附加认证标签，或者在解密的情况下验证认证标签。</span> <span>结果存储在<code>output</code>缓冲区中，从<code>outputOffset</code>开始。</span> </p>
<p> <span>如果<code>output</code>缓冲区太小而不能保存结果，则抛出一个<code>ShortBufferException</code> 。</span> </p>
<p> <span>完成后，此方法将此密码对象重置为先前通过调用<code>engineInit</code> 。</span> <span>也就是说，该对象被复位并且可用于加密或解密（取决于这是在调用所指定的操作模式<code>engineInit</code> ）更多的数据。</span> </p>
<p> <span>注意：如果发生任何异常，则可能需要重新设置此密码对象，然后才能再次使用。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>input</code> - 输入缓冲区 
           </dd>
<dd>
<code>inputOffset</code> - 
            <code>input</code>中的输入开始的偏移量 
           </dd>
<dd>
<code>inputLen</code> - 输入长度 
           </dd>
<dd>
<code>output</code> - 结果的缓冲区 
           </dd>
<dd>
<code>outputOffset</code> - 存储结果的 
            <code>output</code>中的偏移量 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             存储在 
            <code>output</code>中的字节数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a></code> - 如果该密码是块密码，则不会请求填充（仅在加密模式下），并且由该密码处理的数据的总输入长度不是块大小的倍数;</span>
<span>或者如果此加密算法无法处理提供的输入数据。</span>
</dd>
<dd>
<code><a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a></code> - 如果给定的输出缓冲区太小，不能保存结果 
           </dd>
<dd>
<code><a href="../../javax/crypto/BadPaddingException.html" title="class in javax.crypto">BadPaddingException</a></code> - 如果该密码处于解密模式，并且已经请求了（un）填充，但是解密的数据不受适当的填充字节的限制 
           </dd>
<dd>
<code><a href="../../javax/crypto/AEADBadTagException.html" title="class in javax.crypto">AEADBadTagException</a></code> - 如果该密码在AEAD模式（例如GCM / CCM）中解密，并且接收到的认证标签与计算值不匹配 
           </dd>
</dl> </li>
</ul> <a name="engineDoFinal-java.nio.ByteBuffer-java.nio.ByteBuffer-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineDoFinal</h4> <pre>protected int engineDoFinal(<a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> input,
                            <a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> output)
                     throws <a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a>,
                            <a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a>,
                            <a href="../../javax/crypto/BadPaddingException.html" title="class in javax.crypto">BadPaddingException</a></pre>
<div class="block">
<span>在单一部分操作中加密或解密数据，或完成多部分操作。</span>
<span>数据被加密或解密，这取决于这个密码如何初始化。</span>
<p> <span>所有<code>input.remaining()</code>起始字节<code>input.position()</code>进行处理。</span> <span>如果正在使用诸如GCM / CCM的AEAD模式，则在加密的情况下附加认证标签，或者在解密的情况下验证认证标签。</span> <span>结果存储在输出缓冲区中。</span> <span>返回时，输入缓冲区的位置将等于其限制;</span> <span>其限制将不会改变。</span> <span>输出缓冲区的位置将提前n，其中n是此方法返回的值;</span> <span>输出缓冲区的限制将不会改变。</span> </p>
<p> <span>如果<code>output.remaining()</code>字节不足以保存结果，则抛出<code>ShortBufferException</code> 。</span> </p>
<p> <span>完成后，此方法将此密码对象重置为先前通过调用<code>engineInit</code> 。</span> <span>也就是说，该对象被复位并且可用于加密或解密（取决于这是在调用所指定的操作模式<code>engineInit</code> ）更多的数据。</span> </p>
<p> <span>注意：如果发生任何异常，则可能需要重新设置此密码对象，然后才能再次使用。</span> </p>
<p> <span>子类应该考虑覆盖此方法，如果它们可以比字节数组更有效地处理ByteBuffers。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>input</code> - 输入ByteBuffer 
           </dd>
<dd>
<code>output</code> - 输出ByteByffer 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             存储在 
            <code>output</code>中的字节数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a></code> - 如果该密码是块密码，则不会请求填充（仅在加密模式下），并且由该密码处理的数据的总输入长度不是块大小的倍数;</span>
<span>或者如果此加密算法无法处理提供的输入数据。</span>
</dd>
<dd>
<code><a href="../../javax/crypto/ShortBufferException.html" title="class in javax.crypto">ShortBufferException</a></code> - 输出缓冲区空间不足 
           </dd>
<dd>
<code><a href="../../javax/crypto/BadPaddingException.html" title="class in javax.crypto">BadPaddingException</a></code> - 如果该密码处于解密模式，并且已经请求了（un）填充，但是解密的数据不受适当的填充字节的限制 
           </dd>
<dd>
<code><a href="../../javax/crypto/AEADBadTagException.html" title="class in javax.crypto">AEADBadTagException</a></code> - 如果该密码在AEAD模式（如GCM / CCM）中解密，并且接收的认证标签与计算值不匹配 
           </dd>
<dd>
<code><a href="../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数是 
            <code>null</code>
</dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.5 
           </dd>
</dl> </li>
</ul> <a name="engineWrap-java.security.Key-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineWrap</h4> <pre>protected byte[] engineWrap(<a href="../../java/security/Key.html" title="interface in java.security">Key</a> key)
                     throws <a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a>,
                            <a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></pre>
<div class="block">
<span>包裹钥匙</span>
<p> <span>这个具体的方法已经添加到这个以前定义的抽象类中。</span> <span>（为了向后兼容，它不能是抽象的。）提供者可以覆盖它来包装密钥。</span> <span>如果给定的键无法被包装，这样的覆盖应该会引发IllegalBlockSizeException或InvalidKeyException（在指定的情况下）。</span> <span>如果此方法未被覆盖，则会始终抛出UnsupportedOperationException异常。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>key</code> - 要包装的关键。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             包裹的钥匙。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../javax/crypto/IllegalBlockSizeException.html" title="class in javax.crypto">IllegalBlockSizeException</a></code> - 如果该密码是块密码，则不请求填充，并且要包装的密钥的编码长度不是块大小的倍数。 
           </dd>
<dd>
<code><a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></code> - 如果使用该密码将密钥包装是不可能或不安全的（例如，硬件保护密钥正在传递给仅软件密码）。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果不支持此方法。 
           </dd>
</dl> </li>
</ul> <a name="engineUnwrap-byte:A-java.lang.String-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineUnwrap</h4> <pre>protected <a href="../../java/security/Key.html" title="interface in java.security">Key</a> engineUnwrap(byte[] wrappedKey,
                           <a href="../../java/lang/String.html" title="class in java.lang">String</a> wrappedKeyAlgorithm,
                           int wrappedKeyType)
                    throws <a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a>,
                           <a href="../../java/security/NoSuchAlgorithmException.html" title="class in java.security">NoSuchAlgorithmException</a></pre>
<div class="block">
<span>打开以前包装的钥匙。</span>
<p> <span>这个具体的方法已经添加到这个以前定义的抽象类中。</span> <span>（为了向后兼容，它不能是抽象的。）提供者可以覆盖它以解开以前包装的密钥。</span> <span>如果给定的包装密钥无法解开，这样的覆盖应该会抛出InvalidKeyException。</span> <span>如果此方法未被覆盖，则会始终抛出UnsupportedOperationException异常。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>wrappedKey</code> - 要解开的关键。 
           </dd>
<dd>
<code>wrappedKeyAlgorithm</code> - 与包裹密钥相关联的算法。 
           </dd>
<dd>
<span><code>wrappedKeyType</code> - 包装密钥的类型。</span>
<span>这是一个<code>SECRET_KEY</code> ， <code>PRIVATE_KEY</code> ，或<code>PUBLIC_KEY</code> 。</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             展开的钥匙。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/security/NoSuchAlgorithmException.html" title="class in java.security">NoSuchAlgorithmException</a></code> -如果没有安装供应商可以创建类型的键 
            <code>wrappedKeyType</code>为 
            <code>wrappedKeyAlgorithm</code> 。 
           </dd>
<dd>
<code><a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></code> -如果 
            <code>wrappedKey</code>不表示类型的包装的密钥 
            <code>wrappedKeyType</code>为 
            <code>wrappedKeyAlgorithm</code> 。 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果不支持此方法。 
           </dd>
</dl> </li>
</ul> <a name="engineGetKeySize-java.security.Key-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineGetKeySize</h4> <pre>protected int engineGetKeySize(<a href="../../java/security/Key.html" title="interface in java.security">Key</a> key)
                        throws <a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></pre>
<div class="block">
<span>以位为单位返回给定键对象的键大小。</span>
<p> <span>这个具体的方法已经添加到这个以前定义的抽象类中。</span> <span>如果提供者不被覆盖，它会抛出一个<code>UnsupportedOperationException</code> 。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>key</code> - 关键对象。 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             给定键对象的键大小。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/security/InvalidKeyException.html" title="class in java.security">InvalidKeyException</a></code> - 如果 
            <code>key</code>无效。 
           </dd>
</dl> </li>
</ul> <a name="engineUpdateAAD-byte:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>engineUpdateAAD</h4> <pre>protected void engineUpdateAAD(byte[] src,
                               int offset,
                               int len)</pre>
<div class="block">
<span>使用所提供的缓冲区的子集，继续进行附加认证数据（AAD）的多部分更新。</span>
<p> <span>当使用AEAD（GCM / CCM）等模式运行时，调用此方法可以为密码提供AAD。</span> <span>如果此密码在GCM或CCM模式下运行，则必须在密文开始操作之前（通过<code>update</code>和<code>doFinal</code>方法）提供所有AAD。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>src</code> - 包含AAD的缓冲区 
           </dd>
<dd>
<code>offset</code> - 
            <code>src</code>中AAD输入开始的偏移量 
           </dd>
<dd>
<code>len</code> - AAD字节数 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果此密码处于错误状态（例如，尚未初始化），则不接受AAD，或者在GCM或CCM模式下运行，并且 
            <code>update</code>方法中的一个已被调用用于主动加密/解密操作 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此方法尚未被实现覆盖 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.7 
           </dd>
</dl> </li>
</ul> <a name="engineUpdateAAD-java.nio.ByteBuffer-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>engineUpdateAAD</h4> <pre>protected void engineUpdateAAD(<a href="../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a> src)</pre>
<div class="block">
<span>继续进行附加认证数据（AAD）的多部分更新。</span>
<p> <span>当使用AEAD（GCM / CCM）等模式运行时，调用此方法可以为密码提供AAD。</span> <span>如果此密码在GCM或CCM模式下运行，则必须在密文开始操作之前（通过<code>update</code>和<code>doFinal</code>方法）提供所有AAD。</span> </p>
<p> <span>所有<code>src.remaining()</code>起始字节<code>src.position()</code>进行处理。</span> <span>返回时，输入缓冲区的位置将等于其限制;</span> <span>其限制将不会改变。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>src</code> - 包含AAD的缓冲区 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果此密码处于错误状态（例如尚未初始化），则不接受AAD，或者在GCM或CCM模式下运行，并且 
            <code>update</code>方法之一已被调用用于主动加密/解密操作 
           </dd>
<dd>
<code><a href="../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此方法尚未被实现覆盖 
           </dd>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
             1.7 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>