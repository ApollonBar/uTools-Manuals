<div class="header">
<div class="subTitle">
     javax.crypto.spec 
   </div>
<h2 class="title" title="Class PBEKeySpec">Class PBEKeySpec</h2>
</div><div class="contentContainer">
<ul class="inheritance">
<li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>javax.crypto.spec.PBEKeySpec</li>
</ul> </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Implemented Interfaces: 
       </dt>
<dd>
<span><a href="../../../java/security/spec/KeySpec.html" title="java.security.spec中的接口">KeySpec</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public class <span class="typeNameLabel">PBEKeySpec</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../../java/security/spec/KeySpec.html" title="interface in java.security.spec">KeySpec</a></pre>
<div class="block">
<span>用户选择的密码，可用于基于密码的加密（ <i>PBE</i> ）。</span>
<p> <span>该密码可以被看作是某种原始密钥材料，使用它的加密机制从该密钥材料获得加密密钥。</span> </p>
<p> <span>不同的PBE机制可能会消耗每个密码字符的不同位。</span> <span>例如，在定义的PBE机构<a href="http://www.ietf.org/rfc/rfc2898.txt">PKCS #5</a>着眼于仅低阶8个的每个字符的比特，而PKCS＃12着眼于每个字符的所有16位。</span> </p>
<p> <span>您可以通过创建相应密钥工厂的实例将密码字符转换为PBE密钥。</span> <span>例如，PKCS＃5的秘密密钥工厂将仅从每个密码字符的低位8位构造一个PBE密钥，而PKCS＃12的秘密密钥工厂将占用每个字符的所有16位。</span> </p>
<p> <span>还要注意，这个类将密码存储为char数组而不是<code>String</code>对象（这似乎更合乎逻辑），因为String类是不可变的，当不再需要存储在其中的密码时，没有办法覆盖其内部值。</span> <span>因此，该类将该密码作为char数组请求，因此在完成后可以被覆盖。</span> </p>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.4 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../../javax/crypto/SecretKeyFactory.html" title="javax.crypto中的类"><code>SecretKeyFactory</code></a> ， <a href="../../../javax/crypto/spec/PBEParameterSpec.html" title="javax.crypto.spec中的类"><code>PBEParameterSpec</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!-- --> </a> <h3>构造方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Constructor Summary table, listing constructors, and an explanation">
<caption>
<span>构造方法</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#PBEKeySpec-char:A-">PBEKeySpec</a></span>(char[] password)</code>
<div class="block">
              使用密码的构造方法。 
            </div> </td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#PBEKeySpec-char:A-byte:A-int-">PBEKeySpec</a></span>(char[] password, byte[] salt, int iterationCount)</code>
<div class="block">
              构造函数采用密码，盐，迭代计数，生成固定密钥大小的PBE密码的PBEKey。 
            </div> </td>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#PBEKeySpec-char:A-byte:A-int-int-">PBEKeySpec</a></span>(char[] password, byte[] salt, int iterationCount, int keyLength)</code>
<div class="block">
              构造函数，它使用密码，盐，迭代计数和待导出密钥长度来生成可变密钥大小的PBE密码的PBEKey。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t4"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#clearPassword--">clearPassword</a></span>()</code>
<div class="block">
              清除密码的内部副本。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#getIterationCount--">getIterationCount</a></span>()</code>
<div class="block">
              返回迭代计数，如果未指定则返回0。 
            </div> </td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#getKeyLength--">getKeyLength</a></span>()</code>
<div class="block">
              返回要导出的密钥长度，如果未指定则返回0。 
            </div> </td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>char[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#getPassword--">getPassword</a></span>()</code>
<div class="block">
              返回密码的副本。 
            </div> </td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/crypto/spec/PBEKeySpec.html#getSalt--">getSalt</a></span>()</code>
<div class="block">
              如果没有指定，则返回salt的副本。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!-- --> </a> <h3>Methods inherited from class java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!-- --> </a> <h3>构造方法详细信息</h3> <a name="PBEKeySpec-char:A-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>PBEKeySpec</h4> <pre>public PBEKeySpec(char[] password)</pre>
<div class="block">
<span>使用密码的构造方法。</span>
<span>如果指定了null，则使用空的char []。</span>
<p> <span>注意： <code>password</code>被存储在新的<code>PBEKeySpec</code>对象之前被克隆。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>password</code> - 密码。 
           </dd>
</dl> </li>
</ul> <a name="PBEKeySpec-char:A-byte:A-int-int-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>PBEKeySpec</h4> <pre>public PBEKeySpec(char[] password,
                  byte[] salt,
                  int iterationCount,
                  int keyLength)</pre>
<div class="block">
<span>构造函数，它使用密码，盐，迭代计数和待导出密钥长度来生成可变密钥大小的PBE密码的PBEKey。</span>
<span>一个空字符如果指定空[]使用<code>password</code> 。</span>
<p> <span>注意： <code>password</code>和<code>salt</code>在被存储在新的<code>PBEKeySpec</code>对象之前被克隆。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>password</code> - 密码。 
           </dd>
<dd>
<code>salt</code> - 盐。 
           </dd>
<dd>
<code>iterationCount</code> - 迭代计数。 
           </dd>
<dd>
<code>keyLength</code> - 要导出的密钥长度。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>salt</code>为空。 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>salt</code>为空，即0长度， 
            <code>iterationCount</code>或 
            <code>keyLength</code>不为正。 
           </dd>
</dl> </li>
</ul> <a name="PBEKeySpec-char:A-byte:A-int-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>PBEKeySpec</h4> <pre>public PBEKeySpec(char[] password,
                  byte[] salt,
                  int iterationCount)</pre>
<div class="block">
<span>构造函数采用密码，盐，迭代计数，生成固定密钥大小的PBE密码的PBEKey。</span>
<span>一个空字符如果指定空[]使用<code>password</code> 。</span>
<p> <span>注意： <code>password</code>和<code>salt</code>在被存储在新的<code>PBEKeySpec</code>对象之前被克隆。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<code>password</code> - 密码。 
           </dd>
<dd>
<code>salt</code> - 盐。 
           </dd>
<dd>
<code>iterationCount</code> - 迭代计数。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
            <code>salt</code>为空。 
           </dd>
<dd>
<code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
            <code>salt</code>为空，即0长度，或 
            <code>iterationCount</code>不为正。 
           </dd>
</dl> </li>
</ul> </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="clearPassword--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>clearPassword</h4> <pre>public final void clearPassword()</pre>
<div class="block">
            清除密码的内部副本。 
          </div> </li>
</ul> <a name="getPassword--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getPassword</h4> <pre>public final char[] getPassword()</pre>
<div class="block">
<span>返回密码的副本。</span>
<p> <span>注意：此方法返回密码的副本。</span> <span>呼叫者有责任在不再需要密码信息后将其清除。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             密码。 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - 如果通过调用 
            <code>clearPassword</code>方法清除了密码。 
           </dd>
</dl> </li>
</ul> <a name="getSalt--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getSalt</h4> <pre>public final byte[] getSalt()</pre>
<div class="block">
<span>如果没有指定，则返回salt的副本。</span>
<p> <span>注意：此方法应返回盐的副本。</span> <span>呼叫者有责任在不再需要盐信息后将其清除掉。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             盐。 
           </dd>
</dl> </li>
</ul> <a name="getIterationCount--">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getIterationCount</h4> <pre>public final int getIterationCount()</pre>
<div class="block">
            返回迭代计数，如果未指定则返回0。 
          </div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             迭代计数。 
           </dd>
</dl> </li>
</ul> <a name="getKeyLength--">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>getKeyLength</h4> <pre>public final int getKeyLength()</pre>
<div class="block">
<span>返回要导出的密钥长度，如果未指定则返回0。</span>
<p> <span>注意：这用于指示可变密钥大小密码对密钥长度的偏好。</span> <span>实际的密钥大小取决于每个提供者的实现。</span> </p>
</div>
<dl>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             the to-be-derived key length. 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>