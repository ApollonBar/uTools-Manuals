<div class="header">
<div class="subTitle">
     compact3 
   </div>
<div class="subTitle">
     javax.tools 
   </div>
<h2 class="title" title="Interface JavaCompiler">Interface JavaCompiler</h2>
</div><div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>
         All Superinterfaces: 
       </dt>
<dd>
<span><a href="../../javax/tools/OptionChecker.html" title="javax.tools中的接口">OptionChecker</a> ， <a href="../../javax/tools/Tool.html" title="javax.tools中的接口">Tool</a></span>
</dd>
</dl>
<hr/> <br/> <pre>public interface <span class="typeNameLabel">JavaCompiler</span>
extends <a href="../../javax/tools/Tool.html" title="interface in javax.tools">Tool</a>, <a href="../../javax/tools/OptionChecker.html" title="interface in javax.tools">OptionChecker</a></pre>
<div class="block">
<span>从程序中调用Java编程语言编译器的接口。</span>
<p> <span>编译器可能在编译期间生成诊断（例如，错误消息）。</span> <span>如果提供了诊断侦听器，则诊断将提供给侦听器。</span> <span>如果没有提供监听器，该诊断将在未指定的格式来格式化并写入到默认输出，这是<code>System.err</code>除非另有规定。</span> <span>即使提供诊断侦听器，某些诊断可能不适用于<code>Diagnostic</code> ，并将被写入默认输出。</span> </p>
<p> <span>编译器工具有一个相关的标准文件管理器，它是工具（或内置）的本机文件管理器。</span> <span>标准文件管理器可以通过致电<a href="../../javax/tools/JavaCompiler.html#getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-">getStandardFileManager</a>获得。</span> </p>
<p> <span>只要符合以下方法中详细的任何其他要求，编译器工具就必须与任何文件管理器一起使用。</span> <span>如果没有提供文件管理器，则编译器工具将使用标准文件管理器，例如由<a href="../../javax/tools/JavaCompiler.html#getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-">getStandardFileManager</a>返回的文件管理器。</span> </p>
<p> <span>实现此接口的实例必须符合<cite>The Java™ Language Specification</cite>和生成的类文件符合<cite>The Java™ Virtual Machine Specification。</cite></span> <span>这些规范的版本中定义<a href="../../javax/tools/Tool.html" title="javax.tools中的接口">Tool</a>接口。</span> <span>此外，该接口的实例支持<a href="../../javax/lang/model/SourceVersion.html#RELEASE_6"><code>SourceVersion.RELEASE_6</code></a>或更高版本还必须支持<a href="../../javax/annotation/processing/package-summary.html">annotation processing</a> 。</span> </p>
<p> <span>编译器依赖于两个服务： <a href="../../javax/tools/DiagnosticListener.html" title="javax.tools中的接口">diagnostic listener</a>和<a href="../../javax/tools/JavaFileManager.html" title="javax.tools中的接口">file manager</a> 。</span> <span>虽然大多数的类和接口在这个包定义了用于编译器（和工具一般）接口的API <a href="../../javax/tools/DiagnosticListener.html" title="javax.tools中的接口">DiagnosticListener</a> ， <a href="../../javax/tools/JavaFileManager.html" title="javax.tools中的接口">JavaFileManager</a> ， <a href="../../javax/tools/FileObject.html" title="javax.tools中的接口">FileObject</a>和<a href="../../javax/tools/JavaFileObject.html" title="javax.tools中的接口">JavaFileObject</a>并不意在应用中使用。</span> <span>相反，这些接口旨在实现并用于为编译器提供定制服务，从而为编译器定义SPI。</span> </p>
<p> <span>该包中有许多类和接口，旨在简化SPI的实现以自定义编译器的行为：</span> </p>
<dl>
<dt>
<span><a href="../../javax/tools/StandardJavaFileManager.html" title="javax.tools中的接口"><code>StandardJavaFileManager</code></a></span>
</dt>
<dd>
<span>实现此接口的每个编译器都提供了一个标准的文件管理器，用于定期<a href="../../java/io/File.html" title="java.io中的类">运行files</a> 。</span>
<span>StandardJavaFileManager接口定义了用于从常规文件创建文件对象的其他方法。</span>
<p> <span>标准文件管理器有两个目的：</span> </p>
<ul>
<li> <span>用于自定义编译器读取和写入文件的基本构建块</span> </li>
<li> <span>在多个编译任务之间共享</span> </li>
</ul>
<p> <span>重用文件管理器可能会减少扫描文件系统和读取jar文件的开销。</span> <span>虽然开销可能不会降低，标准文件管理器必须使用多个顺序编译，以下示例为推荐的编码模式：</span> </p>
<pre>  <span>File[] files1 = ... ; // input for first compilation task
       File[] files2 = ... ; // input for second compilation task

       JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
       StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);

       <code> Iterable&lt;? extends JavaFileObject&gt;</code> compilationUnits1 =
           fileManager.getJavaFileObjectsFromFiles(<a href="../../java/util/Arrays.html#asList-T...-">Arrays.asList</a>(files1));
       compiler.getTask(null, fileManager, null, null, null, compilationUnits1).call();

       <code> Iterable&lt;? extends JavaFileObject&gt;</code> compilationUnits2 =
           fileManager.getJavaFileObjects(files2); // use alternative method
       // reuse the same file manager to allow caching of jar files
       compiler.getTask(null, fileManager, null, null, null, compilationUnits2).call();

       fileManager.close();</span> </pre>
</dd>
<dt>
<span><a href="../../javax/tools/DiagnosticCollector.html" title="javax.tools中的类"><code>DiagnosticCollector</code></a></span>
</dt>
<dd>
<span>用于在列表中收集诊断信息，例如：</span>
<pre>  <span><code> Iterable&lt;? extends JavaFileObject&gt;</code> compilationUnits = ...;
       JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
       <code> DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();</code>
       StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);
       compiler.getTask(null, fileManager, diagnostics, null, null, compilationUnits).call();

       for (<code> Diagnostic&lt;? extends JavaFileObject&gt;</code> diagnostic : diagnostics.getDiagnostics())
           System.out.format("Error on line %d in %s%n",
                             diagnostic.getLineNumber(),
                             diagnostic.getSource().toUri());

       fileManager.close();</span> </pre>
</dd>
<dt>
<span><a href="../../javax/tools/ForwardingJavaFileManager.html" title="javax.tools中的类"><code>ForwardingJavaFileManager</code></a> ， <a href="../../javax/tools/ForwardingFileObject.html" title="javax.tools中的类"><code>ForwardingFileObject</code></a>和<a href="../../javax/tools/ForwardingJavaFileObject.html" title="javax.tools中的类"><code>ForwardingJavaFileObject</code></a></span>
</dt>
<dd>
<span>子类化不能覆盖标准文件管理器的行为，因为它是通过在编译器上调用方法而不是调用构造函数来创建的。</span>
<span>而应该使用转发（或授权）。</span>
<span>这些类使得很容易将大多数调用转发到给定的文件管理器或文件对象，同时允许自定义行为。</span>
<span>例如，考虑如何将所有调用记录到<a href="../../javax/tools/JavaFileManager.html#flush--">JavaFileManager.flush()</a> ：</span>
<pre>  <span>final <a href="../../java/util/logging/Logger.html" title="class in java.util.logging">Logger</a> logger = ...;
       <code> Iterable&lt;? extends JavaFileObject&gt;</code> compilationUnits = ...;
       JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
       StandardJavaFileManager stdFileManager = compiler.getStandardFileManager(null, null, null);
       JavaFileManager fileManager = new ForwardingJavaFileManager(stdFileManager) {
           public void flush() throws IOException {
               logger.entering(StandardJavaFileManager.class.getName(), "flush");
               super.flush();
               logger.exiting(StandardJavaFileManager.class.getName(), "flush");
           }
       };
       compiler.getTask(null, fileManager, null, null, null, compilationUnits).call();</span> </pre>
</dd>
<dt>
<span><a href="../../javax/tools/SimpleJavaFileObject.html" title="javax.tools中的类"><code>SimpleJavaFileObject</code></a></span>
</dt>
<dd>
<span>该类提供了一个基本的文件对象实现，可以用作创建文件对象的构建块。</span>
<span>例如，这里是如何定义一个代表存储在一个字符串中的源代码的文件对象：</span>
<pre>  <span>/**
        * A file object used to represent source coming from a string.
        <code> *</code>/
       public class JavaSourceFromString extends SimpleJavaFileObject {
           /**
            * The source code of this "file".
            <code> *</code>/
           final String code;

           /**
            * Constructs a new JavaSourceFromString.
            * <code> @</code>param name the name of the compilation unit represented by this file object
            * <code> @</code>param code the source code for the compilation unit represented by this file object
            <code> *</code>/
           JavaSourceFromString(String name, String code) {
               super(<a href="../../java/net/URI.html#create-java.lang.String-">URI.create</a>("string:///" + name.replace('.','/') + Kind.SOURCE.extension),
                     Kind.SOURCE);
               this.code = code;
           }

           <code> @</code>Override
           public CharSequence getCharContent(boolean ignoreEncodingErrors) {
               return code;
           }
       }</span> </pre>
</dd>
</dl>
</div>
<dl>
<dt>
<span class="simpleTagLabel">从以下版本开始：</span>
</dt>
<dd>
         1.6 
       </dd>
<dt>
<span class="seeLabel">另请参见：</span>
</dt>
<dd>
<span><a href="../../javax/tools/DiagnosticListener.html" title="javax.tools中的接口"><code>DiagnosticListener</code></a> ， <a href="../../javax/tools/Diagnostic.html" title="javax.tools中的接口"><code>Diagnostic</code></a> ， <a href="../../javax/tools/JavaFileManager.html" title="javax.tools中的接口"><code>JavaFileManager</code></a></span>
</dd>
</dl> </li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!-- --> </a> <h3>Nested Class Summary</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption>
<span>Nested Classes</span>
<span class="tabEnd"> </span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Interface and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface </code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/tools/JavaCompiler.CompilationTask.html" title="interface in javax.tools">JavaCompiler.CompilationTask</a></span></code>
<div class="block">
              代表编译任务的未来的接口。 
            </div> </td>
</tr>
</tbody>
</table> </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!-- --> </a> <h3>方法摘要</h3>
<table border="0" cellpadding="3" cellspacing="0" class="memberSummary" summary="Method Summary table, listing methods, and an explanation">
<caption>
<span class="activeTableTab" id="t0"><span>所有方法</span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t2"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd"> </span></span>
<span class="tableTab" id="t3"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd"> </span></span>
</caption>
<tbody>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../../javax/tools/StandardJavaFileManager.html" title="interface in javax.tools">StandardJavaFileManager</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/tools/JavaCompiler.html#getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-">getStandardFileManager</a></span>(<a href="../../javax/tools/DiagnosticListener.html" title="interface in javax.tools">DiagnosticListener</a>&lt;? super <a href="../../javax/tools/JavaFileObject.html" title="interface in javax.tools">JavaFileObject</a>&gt; diagnosticListener, <a href="../../java/util/Locale.html" title="class in java.util">Locale</a> locale, <a href="../../java/nio/charset/Charset.html" title="class in java.nio.charset">Charset</a> charset)</code>
<div class="block">
              获取此工具的标准文件管理器实现的新实例。 
            </div> </td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../../javax/tools/JavaCompiler.CompilationTask.html" title="interface in javax.tools">JavaCompiler.CompilationTask</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../javax/tools/JavaCompiler.html#getTask-java.io.Writer-javax.tools.JavaFileManager-javax.tools.DiagnosticListener-java.lang.Iterable-java.lang.Iterable-java.lang.Iterable-">getTask</a></span>(<a href="../../java/io/Writer.html" title="class in java.io">Writer</a> out, <a href="../../javax/tools/JavaFileManager.html" title="interface in javax.tools">JavaFileManager</a> fileManager, <a href="../../javax/tools/DiagnosticListener.html" title="interface in javax.tools">DiagnosticListener</a>&lt;? super <a href="../../javax/tools/JavaFileObject.html" title="interface in javax.tools">JavaFileObject</a>&gt; diagnosticListener, <a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;<a href="../../java/lang/String.html" title="class in java.lang">String</a>&gt; options, <a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;<a href="../../java/lang/String.html" title="class in java.lang">String</a>&gt; classes, <a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;? extends <a href="../../javax/tools/JavaFileObject.html" title="interface in javax.tools">JavaFileObject</a>&gt; compilationUnits)</code>
<div class="block">
              使用给定的组件和参数创建编译任务的未来。 
            </div> </td>
</tr>
</tbody>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.javax.tools.Tool">
<!-- --> </a> <h3>Methods inherited from interface javax.tools.<a href="../../javax/tools/Tool.html" title="interface in javax.tools">Tool</a></h3> <code><a href="../../javax/tools/Tool.html#getSourceVersions--">getSourceVersions</a>, <a href="../../javax/tools/Tool.html#run-java.io.InputStream-java.io.OutputStream-java.io.OutputStream-java.lang.String...-">run</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.javax.tools.OptionChecker">
<!-- --> </a> <h3>Methods inherited from interface javax.tools.<a href="../../javax/tools/OptionChecker.html" title="interface in javax.tools">OptionChecker</a></h3> <code><a href="../../javax/tools/OptionChecker.html#isSupportedOption-java.lang.String-">isSupportedOption</a></code></li>
</ul> </li>
</ul> </li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!-- --> </a> <h3>方法详细信息</h3> <a name="getTask-java.io.Writer-javax.tools.JavaFileManager-javax.tools.DiagnosticListener-java.lang.Iterable-java.lang.Iterable-java.lang.Iterable-">
<!-- --> </a>
<ul class="blockList">
<li class="blockList"> <h4>getTask</h4> <pre><a href="../../javax/tools/JavaCompiler.CompilationTask.html" title="interface in javax.tools">JavaCompiler.CompilationTask</a> getTask(<a href="../../java/io/Writer.html" title="class in java.io">Writer</a> out,
                                     <a href="../../javax/tools/JavaFileManager.html" title="interface in javax.tools">JavaFileManager</a> fileManager,
                                     <a href="../../javax/tools/DiagnosticListener.html" title="interface in javax.tools">DiagnosticListener</a>&lt;? super <a href="../../javax/tools/JavaFileObject.html" title="interface in javax.tools">JavaFileObject</a>&gt; diagnosticListener,
                                     <a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;<a href="../../java/lang/String.html" title="class in java.lang">String</a>&gt; options,
                                     <a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;<a href="../../java/lang/String.html" title="class in java.lang">String</a>&gt; classes,
                                     <a href="../../java/lang/Iterable.html" title="interface in java.lang">Iterable</a>&lt;? extends <a href="../../javax/tools/JavaFileObject.html" title="interface in javax.tools">JavaFileObject</a>&gt; compilationUnits)</pre>
<div class="block">
<span>使用给定的组件和参数创建编译任务的未来。</span>
<span>编译可能没有完成，如CompilationTask界面中所述。</span>
<p> <span>如果提供了文件管理器，则必须能够处理<code>StandardLocation</code>中定义的所有<a href="../../javax/tools/StandardLocation.html" title="javax.tools中的枚举">位置</a> 。</span> </p>
<p> <span>注意，注解处理可以处理要编译的源代码的编译单元，与<code>compilationUnits</code>参数一起传递，以及类文件，其名称使用<code>classes</code>参数传递。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>out</code> - 编写器用于编译器的附加输出;</span>
<span>使用<code>System.err</code>如果<code>null</code></span>
</dd>
<dd>
<span><code>fileManager</code> - 文件管理器;</span>
<span>如果<code>null</code>使用编译器的标准文件管理器</span>
</dd>
<dd>
<span><code>diagnosticListener</code> - 诊断听众;</span>
<span>如果<code>null</code>使用编译器的默认方法来报告诊断</span>
</dd>
<dd>
<code>options</code> - 编译器选项， 
            <code>null</code>表示没有选项 
           </dd>
<dd>
<code>classes</code> - 通过注释处理 
            <code>null</code>类的名称， 
            <code>null</code>表示没有类名 
           </dd>
<dd>
<code>compilationUnits</code> - 编译单元， 
            <code>null</code>表示无编译单位 
           </dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             表示编译的对象 
           </dd>
<dt>
<span class="throwsLabel">异常</span>
</dt>
<dd>
<span><code><a href="../../java/lang/RuntimeException.html" title="class in java.lang">RuntimeException</a></code> - 如果在用户提供的组件中发生不可恢复的错误。</span>
<span><a href="../../java/lang/Throwable.html#getCause--">cause</a>将是用户代码中的错误。</span>
</dd>
<dd>
<code><a href="../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果任何选项无效，或者如果任何一个给定的编译单位是 
            <a href="../../javax/tools/JavaFileObject.Kind.html#SOURCE">source</a>
</dd>
</dl> </li>
</ul> <a name="getStandardFileManager-javax.tools.DiagnosticListener-java.util.Locale-java.nio.charset.Charset-">
<!-- --> </a>
<ul class="blockListLast">
<li class="blockList"> <h4>getStandardFileManager</h4> <pre><a href="../../javax/tools/StandardJavaFileManager.html" title="interface in javax.tools">StandardJavaFileManager</a> getStandardFileManager(<a href="../../javax/tools/DiagnosticListener.html" title="interface in javax.tools">DiagnosticListener</a>&lt;? super <a href="../../javax/tools/JavaFileObject.html" title="interface in javax.tools">JavaFileObject</a>&gt; diagnosticListener,
                                               <a href="../../java/util/Locale.html" title="class in java.util">Locale</a> locale,
                                               <a href="../../java/nio/charset/Charset.html" title="class in java.nio.charset">Charset</a> charset)</pre>
<div class="block">
<span>获取此工具的标准文件管理器实现的新实例。</span>
<span>文件管理器将使用给定的诊断侦听器来生成任何非致命诊断。</span>
<span>将发出致命错误，并附有适当的例外。</span>
<p> <span>标准文件管理器将在调用<code>flush</code>或<code>close</code>访问时自动重新打开。</span> <span>标准文件管理器必须与其他工具一起使用。</span> </p>
</div>
<dl>
<dt>
<span class="paramLabel">参数</span>
</dt>
<dd>
<span><code>diagnosticListener</code> - 用于非致命诊断的诊断侦听器;</span>
<span>如果<code>null</code>使用编译器的默认方法来报告诊断</span>
</dd>
<dd>
<span><code>locale</code> - 格式化诊断时应用的区域设置;</span>
<span><code>null</code>是指<a href="../../java/util/Locale.html#getDefault--">default locale</a> 。</span>
</dd>
<dd>
<span><code>charset</code> - 用于解码字节的字符集;</span>
<span>如果<code>null</code>使用平台默认</span>
</dd>
<dt>
<span class="returnLabel">结果</span>
</dt>
<dd>
             标准文件管理器 
           </dd>
</dl> </li>
</ul> </li>
</ul> </li>
</ul>
</div>
</div>